## cppcryptfs

출처: https://github.com/bailey27/cppcryptfs

git clone :  https://github.com/bailey27/cppcryptfs.git

cppcryptfs는 Go로 작성된 암호화 된 오버레이 파일 시스템 인 gocryptfs의 설계를 기반으로합니다.

cppcryptfs는 Windows 용 C++에서 gocryptfs 파일 시스템을 구현 한 것입니다. cppcryptfs는 gocryptfs와 호환됩니다. 하나를 사용하여 생성 된 파일 시스템은 일반적으로 다른 파일 시스템과 마운트 (그리고 동기화) 될 수 있습니다. 이 문서의 끝 부분에있는 호환성에 관한 내용을 참조하십시오.

cppcrypts는 가상 파일 시스템에서 파일 및 파일 이름을 즉시, at-the-cloud 및 in-the-cloud로 암호화합니다. Dokany 드라이버와 라이브러리를 사용하여 Windows에서 사용자 모드의 가상 파일 시스템을 제공합니다.

cppcryptfs를 사용하여 폴더에 암호화 된 파일 시스템을 만들 수 있습니다. 암호화 된 파일 시스템은 사용자가 선택한 암호로 보호됩니다.

cppcryptfs를 사용하여 암호를 제공하여 암호화 된 파일 시스템을 마운트하면 Windows에 새 드라이브 문자가 생깁니다. 이 가상 드라이브 문자는 파일의 암호화되지 않은보기를 제공합니다. 암호화 및 암호 해독은 즉시 수행되며 해당 가상 드라이브의 파일을 사용하는 응용 프로그램 에게는 투명합니다.

이후 가상 드라이브 문자를 분리하도록 cppcryptfs에 지시하면 파일 시스템이 암호를 사용하여 다시 마운트되지 않는 한 암호화되지 않은 데이터를 가져올 수 없습니다.

컴퓨터를 종료하면 모든 cppcryptfs 드라이브 문자가 자동으로 마운트 해제됩니다.

암호화 된 파일이 보관되는 폴더가 클라우드 서비스와 동기화되면 암호화 된 파일 이름을 가진 암호화 된 파일 만 클라우드 서비스에 업로드됩니다.

이렇게하면 클라우드 서비스 직원이나 클라우드 서비스를 해킹 한 사람도 파일을 사용할 수 없습니다.

또한 누군가 컴퓨터를 훔쳐서 암호화 된 파일 시스템이 마운트되어 있지 않으면 도둑이 파일을 사용할 수 없습니다.

암호화는 컨테이너 파일을 사용하여 데이터를 저장하는 대신 파일 단위로 수행되기 때문에 필요한 암호화 된 스토리지의 양을 미리 결정할 필요가 없습니다. cppcryptfs는 최소한의 스토리지 오버 헤드를 가지며 암호화 된 파일 시스템은 암호화 된 파일 시스템이있는 물리적 드라이브의 여유 공간의 양에 의해서만 동적으로 제한 될 수 있습니다.

컨테이너 기반 암호화에 비해 파일 별 암호화의 또 다른 장점은 파일 별 암호화가 클라우드 기반 서비스와 매우 빠르고 효율적으로 동기화된다는 점입니다.



## 현재 상태

개발자는 2 년 넘게 forward (normal) 모드에서 cppcryptfs를 사용하고 있으며 데이터를 잃지 않았습니다. 적어도 한 명의 다른 사람이 그것을 사용하고 있습니다.

리버스 모드는 개발자가 제한된 테스트를 거쳤습니다.

개발자 인 Bailey Brown이 서명 한 이진 릴리스는 [릴리스 페이지](https://github.com/bailey27/cppcryptfs/releases)에 있습니다.

문제가 발생할 경우를 대비하여 데이터 백업을 유지하는 것이 좋습니다.



## Testing

cppcryptfs는 관리자로 실행될 때 winfstest에서 500/500 테스트를 통과합니다. 관리자 권한이 없으면 cppcryptfs는 494/500 테스트를 통과합니다. 이 winfstest는 Dokany 프로젝트에서 사용하는 버전에서 분기됩니다. Dokany 팀은 추가 테스트를 추가했습니다.

관리자 권한없이 실행될 때 cppcryptfs가 실패하는 테스트는 DACL (임의 액세스 제어 목록) 작업과 관련이 있습니다. 이러한 작업을 수행하려면 cppcryptfs를 관리자 권한으로 실행해야합니다. 관리자 권한없이 실행해도 cppcryptfs의 일반적인 사용에는 영향을 미치지 않는 것으로 보입니다.



## 빌드 요구 사항

```
Microsoft Visual Studio 2017 Community Edition, perl, nasm, and git (all free)
OpenSSL - https://github.com/openssl/openssl (static build required)
RapidJSON - https://github.com/miloyip/rapidjson (for parsing gocryptfs.conf)
Dokany - https://github.com/dokan-dev/dokany

For Dokany, you probably want to use the binary distribution from here:
	https://github.com/dokan-dev/dokany/releases
(be sure to select "install development files" in the installer options)
```

INSTALL.md에 자세한 빌드 지침이 있습니다.

cppcryptfs는 현재 Dokany 1.2.1.2000과 함께 최신 버전입니다.



## 사용

cppcryptfs는 관리자 권한이 필요하지 않지만 관리자 권한으로 실행되지 않는 경우 SE_SECURITY_NAME 권한을 얻을 수 없습니다. SE_SECURITY_NAME은 Windows API 함수 SetFileSecurity () 및 GetFileSecurity ()에 의해 수행되는 일부 작업에 필요합니다.

cppcryptfs가 SE_SECURITY_NAME없이 작동하는 것 같습니다. 문제가 발생하면 cppcryptfs를 adminstrator로 실행하여 도움이되는지 확인하십시오.

새로운 암호화 된 가상 파일 시스템을 만들려면 먼저 '생성'탭을 클릭하십시오.

![](.\images\screenshot_create.png)

파일 시스템의 루트가 될 디렉토리를 찾거나 만들어야합니다. UI의 디렉토리 선택자에서 디렉토리를 만들 수 있습니다.

일반 (전달) 모드를 사용하는 경우이 디렉토리는 비어 있어야합니다.

역방향 모드를 사용하는 경우 디렉토리는 비어있을 필요가 없습니다 (이 절의 뒤쪽에있는이 문서의 역 모드 절 참조).

이 디렉토리는 NTFS 파일 시스템에 존재하는 것이 좋습니다.

그런 다음 (희망적으로 강력한) 비밀번호를 선택하고 반복해야합니다. 대화 상자는 암호에 최대 255자를 허용합니다.

AES256-EME를 사용하여 파일 이름을 암호화하거나 파일 이름 (일반 텍스트)을 암호화하지 않도록 선택할 수 있습니다.

'긴 파일 이름'을 선택하면 암호화 된 파일 이름을 사용할 때 파일 및 디렉토리의 이름을 최대 255 자까지 사용할 수 있습니다. 일반 텍스트 파일 이름 (일반 텍스트 파일 이름은 최대 255 자까지 가능)을 사용하는 경우이 옵션은 아무 효과가 없습니다. 자세한 내용은이 문서 끝 부분의 '파일 이름 및 경로 길이 제한'섹션을 참조하십시오.

파일 데이터 암호화를 위해 AES256-GCM 또는 AES256-SIV (RFC 5297) 중에서 선택할 수 있습니다. 기본값은 AES256-GCM으로 권장됩니다. GCM은 스트리밍 읽기 및 쓰기에 대해 SIV보다 약 두 배 빠릅니다. SIV는 역방향 모드를 지원하기 위해 구현되었습니다.

Note:  gocryptfs 문서에서 SIV 모드는이 작동 모드의 적절한 이름 인 AES-512-SIV라고합니다. 그러나 512 비트 SIV 키는 256 비트 마스터 키에서 파생되기 때문에 cppcryptfs에서 AES256-SIV라고합니다 (gocryptfs의 경우와 동일). 또한 cppcryptfs 개발자는 사용자 인터페이스에서 AES512-SIV라고 부르기를 원하지 않습니다. 사용자가 AES256-GCM보다 안전하다고 생각할 수 있기 때문입니다.

Reverse를 선택하면 Reverse Mode 파일 시스템이 생성됩니다. 자세한 내용은이 문서의 역 모드에 대한 섹션을 참조하십시오.

원하는 경우 구성 파일을 지정할 수 있습니다. 이 파일에는 파일 시스템에 대한 설정과 암호를 사용하여 암호화 된 무작위 256 비트 AES 마스터 키가 들어 있습니다. 구성 파일 파일은 보안 수준을 높이기 위해 암호화 된 파일 시스템 외부에 보관할 수 있습니다.

'생성'버튼을 클릭하면 설정 파일이 생성됩니다. 대체 구성 파일을 지정하지 않으면 암호화 된 파일 시스템의 루트 디렉토리에 gocryptfs.conf로 생성됩니다. 일반 텍스트 파일 이름을 사용하기로 선택하지 않으면 gocryptfs.diriv 파일도 생성됩니다. 파일을 분실하거나 손상된 경우를 대비하여 백업해야합니다. gocryptfs.conf에 문제가 발생하면 어떤 데이터라도 액세스 할 수 없습니다. 볼륨 레이블을 변경하지 않으면 gocryptfs.conf가 파일 시스템의 수명 동안 절대로 변경되지 않습니다 (아래 참조).

볼륨에 레이블을 지정하면 gocryptfs.conf에서 레이블이 암호화됩니다. 최대 볼륨 레이블 길이는 32 자입니다.

볼륨 레이블은 마스터 키와 128 비트 무작위 초기화 벡터 및 8 바이트의 인증 데이터를 사용하여 암호화 된 AES256-GCM입니다. 그런 다음 initilization 벡터와 함께 base64로 인코딩되고 gocryptfs.conf에 저장됩니다.

파일 탐색기에서 탑재 된 드라이브 문자를 마우스 오른쪽 단추로 클릭하고 '속성'을 선택한 다음 볼륨 레이블을 변경할 수 있습니다. 그러나 그렇게하면 cppcryptfs가 드라이브 마운트 해제시 gocryptfs.conf를 다시 작성하게됩니다. 이것은 gocryptfs.conf에 위험을 수반합니다. 다시 말하지만 gocryptfs.conf 파일을 어딘가에 백업하는 것이 좋습니다.

그런 다음 '마운트'탭으로 가서 드라이브 문자를 선택하고 파일 시스템을 만든 폴더를 선택하십시오. 그런 다음 암호를 입력하고 '마운트'버튼을 클릭하십시오.

![](.\images\screenshot_mount.png)

드라이브 문자 목록을 마우스 오른쪽 단추로 클릭하고 '마운트 지점 추가'를 선택할 수도 있습니다. 이렇게하면 드라이브 문자 목록에 빈 디렉토리를 추가 할 수 있습니다. 이 비어있는 디렉토리는 NTFS 볼륨에 있어야하며 드라이브 문자 대신 마운트 포인트로 사용할 수 있습니다. 추가 된 탑재 지점이 드라이브 문자 아래의 목록에 추가됩니다. 또한 추가 된 마운트 포인트를 마우스 오른쪽 단추로 클릭하고 목록에서 삭제할 수 있습니다. 추가 한 마운트 포인트 디렉토리는 Windows 레지스트리에 저장됩니다.

마운트 된 파일 시스템을 마우스 오른쪽 버튼으로 클릭하고 마운트 해제하거나 속성을 볼 수도 있습니다.

파일 시스템을 만들 때 설정 파일에 대한 커스텀 경로를 지정했다면 여기에 지정해야합니다.

설정 파일에 대한 커스텀 경로를 지정했다면, 역 파일 시스템이라면 'reverse'를 선택해야합니다. 그렇지 않으면 cppcryptfs는 파일 시스템이 정방향 또는 역방향 모드로 마운트되어야하는지 자동으로 감지합니다.

Note: cppcryptfs는 암호화 된 파일 시스템에 대한 경로를 구성 파일 (있는 경우) 및 역방향 및 읽기 전용과 같은 기타 설정에 대한 사용자 지정 경로를 수정하는 키로 사용합니다. 따라서 마운트 할 경로를 선택할 때이 설정이 이번에 사용할 것인지 확인하십시오.

파일 시스템을 마운트 한 후에는 새로운 드라이브 문자를 갖게되며 일반 드라이브 문자처럼 사용하여 중요한 정보를 저장할 수 있습니다. 데이터는 암호화되어 지정한 폴더의 파일에 저장됩니다.

'읽기 전용'을 선택하면 파일 시스템이 읽기 전용으로 마운트 (쓰기 보호)됩니다.

cppcryptfs에서 저장된 암호가 작동하는 방법에 대한 설명은 아래의 '저장된 암호'섹션을 참조하십시오.

gocryptfs의 암호화 설계에 대한 기술적 인 세부 사항은 [gocryptfs 프로젝트 페이지](https://github.com/rfjakob/gocryptfs)를 방문하십시오.

드라이브 문자 사용이 끝나면 '마운트'탭으로 이동하여 드라이브 문자를 선택하고 '마운트 해제'를 클릭하거나 '모두 마운트 해제'를 클릭하십시오. 드라이브 문자가 분리되고 암호화 키가 메모리에서 지워집니다.

사용 가능한 드라이브 문자가 사용되지 않은만큼 많은 gocryptfs 파일 시스템을 마운트 할 수 있습니다.

암호와 키는 VirtualLock ()을 사용하여 메모리에 잠겨 있습니다. 더 이상 필요하지 않으면 SecureZeroMemory ()를 사용하여 지우고 잠금을 해제합니다. 컴퓨터를 절전 모드로 전환하지 않으면 하드 드라이브에 쓰여진 암호 나 키에 대해 걱정할 필요가 없습니다.

cppcryptfs 창을 닫으면 시스템 트레이에서 자신을 숨 깁니다. cppcryptfs를 종료하려면 마운트 페이지 또는 시스템 트레이 아이콘의 상황에 맞는 메뉴에서 종료 버튼을 사용하십시오.



## Settings

설정 탭이 있습니다.

![](.\images\screenshot_settings.png)

표시된 권장 설정

설정 탭에서 값을 변경하면 이후에 마운트되는 모든 파일 시스템에 영향을줍니다. 이미 마운트 된 파일 시스템은 영향을받지 않습니다.

현재 설정은 Windows 레지스트리에 저장되며 다음에 파일 시스템이 마운트 될 때 사용되며 심지어 명령 행에서도 사용됩니다.

설정 탭의 설정은 다음과 같습니다.

### **Per-filesystem threads**

각 파일 시스템에 대한 요청을 처리하기 위해 둘 이상의 스레드를 사용하면 성능이 향상 될 수 있습니다.

'Dokany default'를 사용하면 Dokany는 적절한 수의 스레드를 선택하게됩니다. 현재 5 개의 스레드를 사용합니다.

### **I/O buffer size (KB)**

이 설정은 cppcryptfs가 기본 파일 시스템에서 수행하는 읽기 및 쓰기의 최대 크기를 제어합니다.

cppcryptfs는 실제로 4,128 바이트 인 암호화 된 블록 크기의 배수로 I/O를 수행합니다. 따라서 4KB를 지정하면 버퍼 크기는 실제로 4,128 바이트이고 1024KB를 지정하면 실제로 버퍼 크기는 1,056,768 바이트입니다.

I/O 버퍼 크기를 늘리면 특히 기본 파일 시스템이 원격 네트워크 파일 시스템 인 경우 성능이 향상 될 수 있습니다.

원격 파일 시스템의 경우, 파일 시스템 스레드 당 'Dokany 기본값 (5)'과 I/O 버퍼 크기가 64KB가 좋습니다.

### **Cache time to live**

cppcryptfs는 파일 시스템에 대한 정보를 캐시합니다. 캐시의 항목이 TTL보다 오래된 경우 해당 항목을 사용하기 전에 해당 항목의 유효성을 다시 검사합니다.

캐시 시간을 늘리거나 무한대로 설정하면 성능이 향상됩니다.

그러나 cppcryptfs 또는 gocryptfs의 다른 인스턴스에서 실행중인 다른 컴퓨터에있는 파일 시스템의 다른 복사본과 cppcryptfs 파일 시스템을 지속적으로 동기화하는 경우 시간을 너무 길게 설정하면 파일 시스템 다른 컴퓨터에서 수정되었습니다.

동시에 실행되는 두 개의 cppcryptfs 인스턴스간에 또는 cppcryptfs 인스턴스와 gocryptfs 인스턴스간에 파일 시스템을 동기화하지 않으면 캐시 시간을 높게 설정하거나 무한대로 설정하지 않아도됩니다.

### **Case insensitive**

이 옵션은 전달 모드에서만 유효하며 암호화 된 파일 이름이 사용되는 경우에만 적용됩니다. 암호화 된 파일 이름을 가진 역 모드 파일 시스템은 항상 대소 문자를 구분하며, 일반 텍스트 파일 이름을 가진 파일 시스템은 대소 문자를 구분하지 않습니다.

일반적으로 파일 이름 암호화가 사용되면 cppcryptfs는 파일 및 디렉토리를 만들 때 사용한 것과 동일한 대소 문자를 사용하여 파일 및 디렉토리를 열어야합니다.

대소 문자를 구분하지 않는 옵션이 선택되어 있으면 cppcryptfs는 파일 이름 암호화가 사용되는 경우에도 전달 모드에서 파일 및 디렉토리 이름의 대소 문자를 무시합니다. 이것이 Windows API가 정상적으로 작동하는 방식입니다. 또한 성능이 조금 느려집니다.

자세한 내용은 '대소 문자 구분'섹션을 참조하십시오.

### **Enable Mount Manager (Recycle Bin)**

이 설정은 기본값 또는 권장 설정을 선택한 경우 현재 활성화되어 있지 않습니다. 사용하려면 별도로 활성화해야합니다. 그것은 철저하게 테스트되지 않았습니다.

이 설정을 사용하면 암호화 된 볼륨에서 Windows Mount Manager 를 사용할 수 있습니다. 마운트 관리자를 사용하면 휴지통을 사용할 수 있습니다. 이 설정은 cppcryptfs가 관리자로 실행되는 경우에만 작동합니다. 이 설정이 선택된 상태에서 파일 시스템을 마운트하려고 시도하고 cppcryptfs가 관리자 권한으로 실행되고 있지 않으면 cppcyrptfs는 경고 대화 상자를 표시하고 (비활성화 될 수 있음) 마운트 관리자를 활성화하지 않습니다.

이 설정은 역 파일 시스템이나 파일 시스템이 읽기 전용으로 마운트 된 경우에는 아무런 영향을 미치지 않습니다.

Note: 파일 시스템의 암호화 된 파일을 Dropbox와 동기화하는 경우 마운트 관리자 (휴지통)를 사용하면 Dropbox는 충분한 권한이 없기 때문에 휴지통에있는 파일을 동기화 할 수 없습니다.

관리자로 Dropbox를 실행하거나 Dropbox의 선택 동기화 기능을 사용하여 어떤 암호화 된 폴더 이름이 휴지통의 이름인지 확인하고 제외해야합니다. 일반 텍스트 파일 이름을 사용하는 경우 휴지통은 "$RECYCLE.BIN"이됩니다. --list 명령 줄 스위치는 파일 시스템의 루트 디렉토리에 대한 (암호화되지 않은) 경로가 인수로 주어지면 휴지통의 암호화 된 이름을 찾는 데 사용될 수 있습니다.

e.g.

```
cppcryptfs --list=d:\
```



### **Enable saved passwords**

이 설정을 사용하면 암호를 저장할 수 있습니다. 저장된 암호에 대한 자세한 내용은 아래 저장된 암호 섹션을 참조하십시오.

이 설정을 사용하면 마운트 탭의 '비밀번호 저장'확인란을 사용할 수 있습니다.

'저장된 암호 사용'설정이 선택에서 선택 취소로 변경되면 cppcryptfs는 저장된 암호를 모두 삭제해야하는지 묻습니다.

이 설정은 기본 또는 권장 설정에서는 사용할 수 없습니다.

### **Never save history**

이 설정은 cppcryptfs가이 페이지에서 설명하는 값을 제외하고 Windows 레지스트리에 값을 저장하지 못하게합니다. 예 : 저장된 암호가 활성화되어 있어도 기록에서 경로를 저장하거나 암호를 저장하지 못하게합니다.

이 설정을 선택하면 저장된 암호를 제외하고 이 페이지에 설명 된 설정을 제외하고 Windows 레지스트리의 cppcryptfs에 저장된 모든 값이 삭제됩니다. 그러나 이 설정이 적용되는 동안 새 암호는 저장되지 않습니다.

저장된 비밀번호를 삭제하려면 '비밀번호 저장'설정의 선택을 취소해야합니다.

이 설정은 기본 또는 권장 설정에서는 사용할 수 없습니다.

### **Defaults and Recommended**

현재 기본 설정과 권장 설정은 동일합니다.

이전 기본 설정을 여기에서 볼 수 있습니다. [Previous default settings screenshot](https://github.com/bailey27/cppcryptfs/blob/master/screenshots/screenshot_previous_defaults.png?raw=true)

### **Reset Warnings**

경고 재설정 버튼을 누르면 '이 메시지를 다시 표시하지 않음'을 선택하여 이전에 비활성화 된 경고 대화 상자가 다시 표시됩니다.



### Saved Passwords

설정 탭에서 '저장된 비밀번호 사용'설정을 사용하면 마운트 탭의 '비밀번호 저장'확인란을 사용할 수 있습니다.

cppcryptfs가 암호를 저장하면 Windows Data Protection API (DPAPI)를 사용하여 암호를 암호화합니다. 여기서는 Windows DPAPI에 대해 설명합니다.

<https://msdn.microsoft.com/en-us/library/ms995355.aspx>

Windows DPAPI를 사용하여 암호화 된 데이터는 Windows에 로그인하는 데 사용되는 암호의 강도와 보안 수준만큼 안전합니다.

저장된 암호는 암호화 된 파일 시스템의 루트에 대한 경로와 연관됩니다.

또한 '비밀번호 저장'설정 자체가 경로와 연결됩니다.

암호를 저장하려면 파일 시스템을 마운트 할 때 '암호 저장'상자가 선택되어 있는지 확인하십시오.

암호는 DPAPI를 사용하여 암호화되고 Windows 레지스트리에 저장됩니다.

암호를 입력하지 않고 파일 시스템을 마운트하려면 '암호 저장'이 선택되어 있는지 확인한 다음 경로 기록에서 경로를 선택하십시오.이 경우 해당 경로의 암호 (찾을 경우)가 채워집니다 (점으로 표시) 암호 필드에. 또는 패스를 선택하는 대신 패스 필드에 패스를 입력하고 패스워드를 입력하지 않고 마운트 버튼을 누르면 해당 패스의 저장된 패스워드가 발견되면 사용됩니다.

-P 명령 행 옵션을 사용하여 해당 경로에 저장된 암호를 사용하여 명령 행에서 파일 시스템을 마운트 할 수 있습니다.



## Reverse Mode

역방향 모드에서 파일 시스템에 사용되는 소스 (루트) 디렉토리는 암호화되지 않은 파일로 구성됩니다. 이 디렉토리가 마운트되면 cppcryptfs 드라이브 문자는이 파일의 암호화 된보기를 제공합니다.

또한 역방향 모드에서는 구성 파일 (gocryptfs.conf)을 볼 수 있으며 암호화 된 파일 이름을 사용하면 각 디렉토리에있는 gocryptfs.diriv 파일을 볼 수 있습니다. 그리고 긴 파일 이름이 암호화 된 파일 이름과 함께 사용되면 특별한 긴 파일 이름 파일도 제공됩니다.

역 모드 파일 시스템은 항상 읽기 전용으로 마운트됩니다.

역방향 모드 파일 시스템을 만들 때 파일 시스템의 루트 디렉토리는 비어있을 필요가 없습니다 (일반적인 포워드 모드 파일 시스템을 만드는 경우와 달리). cppcryptfs는 파일 시스템의 루트 디렉토리에 config 파일을 만듭니다. 이 파일은 .gocryptfs.reverse.conf라는 숨겨진 파일입니다 (일반 / 전달 모드에서 사용되는 숨겨진 gocryptfs.conf 대신).

파일 시스템을 마운트 할 때 cppcryptfs는 먼저 .gocryptfs.reverse.conf를 찾고, 발견하면 파일 시스템을 반대 모드로 마운트합니다. .gocryptfs.reverse.conf를 찾지 못하면 gocryptfs.conf를 열려고 시도하고 성공하면 파일 시스템이 정상 (normal) 모드로 마운트됩니다.

설정 파일에 대한 커스텀 경로를 지정했다면, 파일 시스템을 역방향 모드로 마운트하기 위해서는 'reverse'를 체크해야합니다.

역 파일 시스템을 마운트 한 다음 전체 디렉토리 트리를 다른 위치에 복사하는 경우 암호화 된 파일과 일반 모드 구성 파일 및 기타 지원 파일을 포함하는 사본을 정방향 (일반) 파일 시스템으로 마운트 할 수 있습니다.

역방향 모드는 암호화되지 않은 파일의 디렉토리 트리를 백업하려고하지만 백업을 암호화하려는 경우에 유용합니다.

리버스 모드는 파일 데이터에 대한 결정 론적 AES256-SIV 암호화 모드 (실제로 AES512-SIV이지만 256 비트 마스터 키에서 파생 된 512 비트 SIV 키 사용)를 사용하며 파일 이름 암호화도 결정적으로 수행합니다.

Note:  forward 모드에서 AES256-SIV를 사용하여 파일 시스템을 마운트하면 새로운 암호화는 (gocryptfs의 경우처럼) 비 결정적으로 수행됩니다.

역방향 모드의 암호화가 결정적이기 때문에 rsync와 같은 유틸리티를 사용하여 암호화 된 파일을 백업 할 수 있으며 변경된 파일 만 복사합니다. 또한 백업 유틸리티가 암호화되지 않은 데이터로 작업 할 때 델타 동기화 (rsync처럼)를 지원하면 데이터가 현재 위치에서 변경되는 한 역방향 모드로 암호화 된 데이터와 델타 동기화도 수행합니다. 그러나 데이터가 파일에 삽입되면 데이터가 삽입 된 시점 (실제로는 전체 암호화 블록으로 시작)에서부터 암호화 된 파일 데이터에 계단식 변경 사항이 나타나고 거기에있는 데이터가 있어야합니다. 다시 복사했습니다.

마운트 된 역 파일 시스템을 포워드 모드로 마운트하는 것이 가능합니다. 앞으로 파일 시스템도 읽기 전용이됩니다. 이것은 주로 테스트에 유용합니다.



## Command Line Options

cppcryptfs는 파일 시스템 마운트 및 마운트 해제를위한 몇 가지 명령 행 옵션을 허용합니다. 현재 파일 시스템은 GUI를 사용해서 만 만들 수 있습니다.

명령 행을 통과 한 암호는 실제로 안전하지 않습니다. cppcryptfs는 명령 줄의 내부 복사본을 잠 그거나 0으로 만듭니다. 예를 들어 Windows PEB (Process Environment Block)에 저장된 명령 줄을 0으로 만들지 않습니다. 또한 cppcyrptfs가 이미 실행 중이면 명령 줄에서 cppcryptfs를 호출하면 WM_COPYDATA 메시지를 사용하여 이미 실행중인 인스턴스에 명령 줄을 전달할 수 있습니다. Windows에서 cppcryptfs 명령을 통해 명령 줄을 몇 번 복사 할 수 있는지는 알 수 없습니다. 따라서 페이징 파일이 사용중인 경우 명령 줄을 통해 전달 된 암호가 페이징 파일에서 종료 될 수있는 가능성이 있습니다.

```
usage: cppcryptfs [OPTIONS]

Mounting:
  -m, --mount=PATH      mount filesystem located at PATH
  -d, --drive=D         mount to drive letter D
  -p, --password=PASS   use password PASS
  -P, --saved-password  use saved password
  -r, --readonly        mount read-only
  -c, --config=PATH     path to config file
  -s, --reverse         mount reverse filesystem

Unmounting:
  -u, --unmount=D       unmount drive letter D or dir DIR
  -u, --unmount=all     unmount all drives

Misc:
  -t, --tray            hide in system tray
  -x, --exit            exit if no drives mounted
  -l, --list            list available and mounted drive letters (with paths)
  -ld:\p, --list=d:\p   list encrypted and plaintext filenames
  -i, --info=D          show information about mounted filesystem
  -v, --version         print version
  -h, --help            display this help message

```

Note: 옵션의 짧은 버전을 사용할 때 옵션과 인수 사이에 등호를 사용하면 안됩니다. 긴 버전의 옵션을 사용할 때 등호는 선택적입니다. 예 : 이것들은 작동 할 것이다.

```
cppcryptfs -m c:\tmp\test -d k -p XYZ
cppcryptfs --mount=c:\tmp\test --drive=k --password=XYZ
cppcryptfs --mount c:\tmp\test --drive k --password XYZ
```

--list 옵션에는 선택적 인수가 있습니다. 주어진 인수가 없으면, 드라이브 문자를 나열하고 마운트 된 파일 시스템에 대한 암호화 된 파일 시스템의 루트에 대한 경로를 표시합니다.

list 명령은 선택적 경로로 전체 경로를 사용합니다. 경로는 드라이브 문자를 포함하는 파일 또는 디렉토리의 암호화되지 않은 이름이어야합니다. 인수가 파일이면 cppcryptfs는 암호화되지 않은 파일 경로를 왼쪽에 표시하고 암호화 된 경로는 오른쪽에 인쇄합니다. 인수가 디렉토리 인 경우 cppcryptfs는 암호화되지 않은 파일 이름을 왼쪽에 표시하고 암호화 된 이름은 오른쪽에 인쇄합니다.

선택적 인수가 처리되는 방식 때문에, 짧은 형식의 목록 스위치 (-l)를 사용하는 경우 공백없이 -l 다음에 경로를 넣어야합니다. 그리고 긴 양식 (--list)을 사용하는 경우 '='기호를 사용해야합니다. 예 :

```
cppcryptfs -lk:\foo

cppcryptfs --list=k:\foo
```

cppcryptfs는 Windows GUI 응용 프로그램이며 콘솔 응용 프로그램이 아닙니다. 그러나 명령 행 옵션을 사용하여 시작하면 콘솔을 시작한 콘솔에 오류 메시지를 쓰려고 시도합니다 (있는 경우).

불행하게도 Windows는 이러한 방식으로 생성 된 파이프 출력을 처리하지 않는 것 같습니다. cppcryptfs의 출력을 정렬과 같은 다른 명령을 통해 파이프하거나 파일로 리디렉션 할 수 없습니다.

cppcryptfs 인스턴스는 언제든지 하나만 실행할 수 있습니다.

cppcryptfs가 호출되면 다른 인스턴스가 실행 중인지 확인합니다. 있을 경우 명령 줄 옵션이 없으면 두 번째 cppcryptfs 인스턴스가 종료됩니다. 실행중인 다른 인스턴스가 없으면 명령 행 옵션 (있는 경우)을 처리하고 --exit가 지정되고 마운트 된 드라이브가없는 경우 계속 실행됩니다.

다른 인스턴스가 실행되는 동안 두 번째 인스턴스가 명령 줄 옵션과 함께 호출되면 두 번째 인스턴스는 WM_COPYDATA 메시지를 사용하여 이미 실행중인 인스턴스에 명령 줄을 보냅니다. 이미 실행중인 인스턴스가 명령 행을 처리하고 종료 할 때까지 차단됩니다. 명령 행 처리로 인한 오류 메시지 또는 기타 출력은 두 번째 인스턴스가 호출 된 cmd 창에 인쇄됩니다.

따라서 배치 파일에서 cppcryptfs를 사용하려면 먼저 백그라운드에서 인스턴스를 시작해야합니다. 그런 다음 다른 작업을 포 그라운드에서 수행해야 완료 될 때까지 차단됩니다.

백그라운드에서 'cppcryptfs --tray'를 시작하면 이미 실행중인 인스턴스가있는 경우 해당 인스턴스가 시스템 트레이에서 자신을 숨기도록 지시됩니다. 이미 인스턴스가 실행되고 있지 않으면 백그라운드에서 실행중인 cppcryptfs가 시스템 트레이에 숨겨져있을 것입니다.

다음은 cppcryptfs를 사용하는 Windows cmd 일괄 처리 파일의 예입니다.

```
@rem ====================================================
@rem run cppcryptfs in background and give it time to start up
@rem ====================================================

start cppcryptfs.exe --tray
timeout /t 1 >nul

@rem ====================================================
@rem Mount drive U:
@rem ====================================================

cppcryptfs.exe --mount=d:\TestCppCryptFS --drive=u --password=PASSWORD --tray  --exit

@rem ====================================================
@rem Mount drive V:
@rem ====================================================

cppcryptfs.exe --mount=d:\TestCppCryptFS2 --drive=v --password=PASSWORD --tray  --exit

@rem ====================================================
@rem Run any command with the mounted drives
@rem ====================================================

copy  C:\test.txt U:\test.txt
copy  C:\test.txt V:\test.txt
```

다음은 cygwin bash scrypt 예제입니다. bash에서는 마운트 경로에 이중 백 슬래시를 사용해야합니다.

```bash

#!/bin/bash
# start cppcryptfs in the background and hidden in the system tray
/cygdrive/c/bin/cppcryptfs -t &
# give it time to initialize
sleep 1
# mount a filesystem and wait for the mount operation to complete
/cygdrive/c/bin/cppcryptfs --mount c:\\tmp\\test -d k -p XYZ
# do backup operation
rsync .....
# unmount all drives and exit
/cygdrive/c/bin/cppcryptfs -u all -x

```



## File name and path length limits

파일 시스템을 만들 때 '긴 파일 이름'(기본값)을 지정했거나 일반 텍스트 파일 이름을 사용하고 기본 파일 시스템이 비교적 최신 인 경우 (예 : NTFS / exFAT / FAT32) 파일 또는 디렉토리 이름은 최대 255 자, 전체 경로는 약 32,000 자일 수 있습니다.

'긴 파일 이름'이 지정되지 않고 일반 텍스트 파일 이름이 사용되지 않으면 파일 또는 디렉토리 이름의 최대 길이는 160 자입니다. 그러나 전체 경로 제한은 여전히 약 32,000 자입니다 (NTFS / exFAT / FAT32라고 가정).

파일 이름이 암호화되면 UNICODE-16에서 UTF-8로 변환되어 언어에 따라 문자 수가 증가 할 수 있습니다. 그런 다음 암호화되어 최대 16 바이트까지 패딩됩니다. 그런 다음 base64로 인코딩되어 일반적으로 길이가 33 % 증가합니다. 따라서 암호화 된 파일 이름은 암호화되지 않은 이름보다 훨씬 길 수 있습니다.

또한 암호화 된 파일 시스템이 상주하는 디렉토리의 경로는 암호화 된 파일 이름의 경로에 선행되어야합니다.

FAT16과 같은 오래된 파일 시스템은 총 경로 길이를 259 자로 제한합니다.

따라서 가능할 때마다 NTFS, exFAT 또는 FAT32와 같은 최신 파일 시스템을 사용하는 것이 좋습니다.

Windows와 함께 제공되는 File Explorer를 비롯한 많은 Windows 프로그램에는 기본 파일 시스템이 사용되는 것과 관계없이 이전 259 자 제한보다 긴 경로에 문제가 있습니다. 암호화 된 파일 이름을 사용하는 경우 암호화 된 파일 시스템의 루트를 이동하려면 긴 파일 경로를 처리하는 타사 파일 관리자를 사용해야 할 수 있습니다. 파일 관리자에 문제가있을 경우를 대비하여 복사하는 대신 이전 파일을 복사하여 삭제하는 것이 좋습니다.



## Case Sensitivity

Windows API는 파일 이름과 관련하여 대소 문자를 구분하지 않지만 Windows 파일 시스템 (NTFS 및 FAT32)은 파일 이름의 대 / 소문자를 유지합니다.

Windows에서 'Foo.txt'로 파일을 만든 다음 'foo.txt'로 열려고하면 파일이 제대로 작동합니다.

전부는 아니지만 대부분의 소프트웨어는 파일을 만들 때 사용한 것과 동일한 대 / 소문자를 사용하여 파일을 엽니 다.

암호화 된 파일 이름이 사용 된 경우 cppcryptfs는 원래 항상 대소 문자를 구분합니다. 이것이 gocryptfs가 작동하는 방법입니다.

따라서 암호화 된 파일 이름이 사용 된 경우 파일이 'Foo.txt'로 생성 된 경우 'foo.txt'를 열려고 시도하면 파일을 찾을 수 없습니다.

cppcryptfs에는 이제 암호화 된 파일 이름이 사용되지만 전달 (일반) 모드에서만 대소 문자를 구분하지 않는 '대소 문자를 구분하지 않는'설정이 있습니다.

역방향 모드에서 파일 이름은 대 / 소문자를 구분하지 않는 설정과 상관없이 암호화 된 파일 이름을 사용하는 경우 항상 대 / 소문자를 구분합니다. 암호화 된 파일 이름이 변경된 경우 (예 : 파일 시스템을 백업 할 때) 파일 시스템 복사본이 이후에 순방향 모드로 마운트되면 파일 이름이 제대로 해독되지 않기 때문에 필요한 예방 조치입니다.

일반 텍스트 파일 이름이 사용되는 경우 파일 이름은 대 / 소문자를 구분하지 않는 설정과 관계없이 정방향 및 역방향 모드에서 항상 대 / 소문자를 구분합니다.



## Performance

아래는 몇 가지 벤치 마크 결과입니다. 이 테스트는 Intel i5-4200U CPU에서 실행되는 Windows 10 64 비트에서 Cygwin 유틸리티를 사용하여 중요한 M500 240GB ssd를 사용하여 수행되었습니다. cppcryptfs를 사용하여 AES256-GCM이 파일 데이터를 암호화하고 암호화 된 파일 이름에 사용되고 긴 파일 이름이 사용되었습니다.

Windows Defender 실시간 검색은 cygwin tar의 속도가 심각하게 느려지므로 테스트 중에 사용하지 않도록 설정되었습니다. 실시간 검색이 가능한 네이티브 NTFS에서 linux-3.0.tar.gz를 추출하는 데 2m43.600 초가 걸렸습니다.

cppcryptfs는 암호화를 수행하지 않는 Dokany의 미러 샘플 프로그램과 거의 동일한 기능을 수행합니다. SSD는 250 MB / 초 스트리밍 쓰기 성능으로 평가됩니다.

```
                                cppcryptfs      native NTFS     Dokany mirror

Streaming Write                 168 MB/s        224 MB/s        181 MB/s
Extract linux-3.0.tar.gz        1m36.412s       0m21.291s       1m34.125s	
ls -lR linux-3.0                1m1.979s        0m2.983s        1m11.618s
Delete linux-3.0                1m28.749s       0m10.144s       1m24.677s

```



## Compatibility with gocryptfs

cppcryptfs는 gocryptfs v0.7 이상에서 만든 모든 파일 시스템을 마운트 할 수 있습니다. 마찬가지로 '긴 파일 이름 = off'인 cppcryptfs로 만든 파일 시스템은 gocryptfs v0.7 이상에서 마운트 할 수 있습니다. '긴 파일 이름 = on'인 파일 시스템은 gocryptfs v0.9 이상에서 마운트 할 수 있습니다.

gocryptfs 호환성 매트릭스는 더 자세한 내용을 제공합니다. cppcryptfs에는 DirIV, EMENames 및 GCMIV128 기능 플래그가 필요합니다. LongNames를 지원하고 플래그를 켜고 끄는 파일 시스템을 만들 수 있습니다.

Note:  cppcryptfs는 gocryptfs와의 호환성을 나타 내기 위해 gocryptfs와 버전 번호 패리티를 유지합니다. cppcryptfs는 이제 1.4 버전이며 gocryptfs 1.4로 만든 모든 파일 시스템을 마운트 할 수 있어야합니다.



### - 끝 -

