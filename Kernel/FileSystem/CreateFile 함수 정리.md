## CreateFile 함수 정리

파일 또는 I/O 장치를 만들거나 엽니다. 가장 일반적으로 사용되는 I/O 장치는 파일,  파일 스트림,  디렉터리,  실제 디스크,  볼륨,  콘솔 버퍼, 테이프 드라이브, 통신 리소스, 메일 슬롯 및 파이프입니다. 이 함수는 파일이나 장치, 지정된 플래그 및 속성에 따라 다양한 유형의 I/O에 대해 파일이나 장치에 액세스하는 데 사용할 수있는 핸들을 반환합니다.

이 작업을 트랜잭션 된 작업으로 수행하면 트랜잭션 I/O에 사용할 수있는 핸들이 만들어 지므로 CreateFileTransacted 함수를 사용하십시오.

### 1. Syntax

```c++
HANDLE CreateFileA(
  LPCSTR                lpFileName,
  DWORD                 dwDesiredAccess,
  DWORD                 dwShareMode,
  LPSECURITY_ATTRIBUTES lpSecurityAttributes,
  DWORD                 dwCreationDisposition,
  DWORD                 dwFlagsAndAttributes,
  HANDLE                hTemplateFile
);
```

### 2. Parameters

#### 2.1 lpFileName

작성 또는 열 파일 또는 장치의 이름. 이 이름에는 슬래시 (/) 또는 백 슬래시 ()를 사용할 수 있습니다.

이 함수의 ANSI 버전에서 이름의 길이는 MAX_PATH 문자로 제한됩니다. 이 제한을 32,767 와이드 문자로 확장하려면 유니 코드 버전의 함수를 호출하고 앞에 "\?" 를 추가하십시오.  자세한 내용은 파일, 경로 및 네임 스페이스 이름 지정을 참조하십시오.

특수 장치 이름에 대한 자세한 내용은 [MS-DOS 장치 이름 정의](https://msdn.microsoft.com/7d802e9f-dc09-4e3d-b064-e9b57af396e2)를 참조하십시오.

파일 스트림을 만들려면 파일 이름, 콜론 및 스트림 이름을 지정합니다. 자세한 내용은 파일 스트림을 참조하십시오.

#### 2.2 dwDesiredAccess

파일 또는 장치에 대한 요청 된 액세스. 읽기, 쓰기, 둘 다 또는 모두 0으로 요약 할 수 있습니다.

가장 일반적으로 사용되는 값은 GENERIC_READ, GENERIC_WRITE 또는 둘 다입니다 (GENERIC_READ | GENERIC_WRITE). 자세한 내용은 일반 액세스 권한, 파일 보안 및 액세스 권한, 파일 액세스 권한 상수 및 [ACCESS_MASK](https://msdn.microsoft.com/f115ee54-3333-4109-8004-d71904a7a943)를 참조하십시오.

이 매개 변수가 0 이면 응용 프로그램은 GENERIC_READ 액세스가 거부 된 경우에도 해당 파일이나 장치에 액세스하지 않고 파일, 디렉토리 또는 장치 속성과 같은 특정 메타 데이터를 쿼리 할 수 있습니다.

이미 열린 핸들이 있는 열린 요청에서 dwShareMode 매개 변수로 지정된 공유 모드와 충돌하는 액세스 모드를 요청할 수 없습니다.

자세한 내용은 이 항목의 주의 절 및 [파일 만들기 및 열기](https://msdn.microsoft.com/094cac29-c66d-409e-8928-878dc693d393)를 참조하십시오.



#### 2.3 dwShareMode

파일 또는 장치의 요청 된 공유 모드. 읽기, 쓰기, 둘 다, 삭제, 모두 또는 없음 (다음 표 참조). 속성 또는 확장 속성에 대한 액세스 요청은 이 플래그의 영향을받지 않습니다.

이 매개 변수가 0 이고 CreateFile이 성공하면 파일이나 장치를 공유 할 수 없으며 파일이나 장치에 대한 핸들이 닫힐 때까지 다시 열 수 없습니다. 자세한 내용은주의 섹션을 참조하십시오.

열린 핸들이 있는 기존 요청에 지정된 액세스 모드와 충돌하는 공유 모드를 요청할 수 없습니다. CreateFile이 실패하고 GetLastError 함수가 ERROR_SHARING_VIOLATION을 반환합니다.

다른 프로세스가 파일 이나 장치를 연 상태에서 프로세스가 파일이나 장치를 공유 할 수있게하려면 다음 값 중 하나 이상의 호환 가능한 조합을 사용하십시오. 이 매개 변수와 dwDesiredAccess 매개 변수의 유효한 조합에 대한 자세한 내용은  [파일 만들기 및 열기](https://msdn.microsoft.com/094cac29-c66d-409e-8928-878dc693d393)를 참조하십시오.

```
참고: 열려있는 각 핸들의 공유 옵션은 프로세스 컨텍스트에 관계없이 핸들이 닫힐 때까지 유효합니다.
```

| Value                            | Meaning                                                      |
| -------------------------------- | ------------------------------------------------------------ |
| **0** <br/>0x00000000            | 파일, 장치가 삭제, 읽기 또는 쓰기 액세스를 요청하면 다른 프로세스가 파일이나 장치를 열지 못하도록합니다. |
| **FILE_SHARE_DELETE** 0x00000004 | 파일 또는 장치에 대한 후속 열기 작업을 통해 삭제 액세스를 요청할 수 있습니다. <br/>그렇지 않으면 다른 프로세스가 삭제 액세스를 요청하면 파일이나 장치를 열 수 없습니다.<br/>이 플래그가 지정되지 않았지만 파일 또는 장치가 삭제 액세스를 위해 열린 경우, 함수는 실패합니다.<br/>**Note**  삭제 액세스는 삭제 및 이름 변경 작업을 허용합니다. |
| **FILE_SHARE_READ** 0x00000001   | 파일 또는 장치에 대한 후속 열기 작업을 사용하여 읽기 액세스를 요청할 수 있습니다. 그렇지 않으면 다른 프로세스가 읽기 액세스를 요청하면 파일이나 장치를 열 수 없습니다. 이 플래그가 지정되지 않았지만 파일이나 장치가 읽기 액세스를 위해 열린 경우이 함수는 실패합니다. |
| **FILE_SHARE_WRITE** 0x00000002  | 파일 또는 장치에 대한 후속 열기 작업을 통해 쓰기 액세스를 요청할 수 있습니다. 그렇지 않으면 쓰기 액세스를 요청하면 다른 프로세스가 파일이나 장치를 열 수 없습니다. 이 플래그가 지정되지 않았지만 파일이나 장치가 쓰기 액세스를 위해 열렸거나 쓰기 액세스 권한이있는 파일 매핑을 가지고 있으면 함수가 실패합니다. |



#### 2.4 lpSecurityAttributes

별도의 관련 데이터 멤버 인 선택적 보안 설명자와 반환 된 핸들을 자식 프로세스에서 상속 할 수 있는지 여부를 결정하는 부울 값을 포함하는 [SECURITY_ATTRIBUTES](https://msdn.microsoft.com/56b5b350-f4b7-47af-b5f8-6a35f32c1009) 구조체에 대한 포인터입니다.

이 매개 변수는 NULL 일 수 있습니다.

이 매개 변수가 NULL이면 CreateFile에 의해 반환 된 핸들을 응용 프로그램에서 만들 수있는 자식 프로세스가 상속받을 수 없으며 반환 된 핸들과 연결된 파일이나 장치가 기본 보안 설명자를 가져옵니다.

구조체의 lpSecurityDescriptor 멤버는 파일 또는 장치에 대한 [SECURITY_DESCRIPTOR](https://msdn.microsoft.com/653992aa-4e32-4187-b3ac-727e82bfe0b6) 를 지정합니다. 이 멤버가 NULL이면 반환 된 핸들과 연결된 파일이나 장치에 기본 보안 설명자가 할당 됩니다.

CreateFile은 기존 파일이나 장치를 열 때 lpSecurityDescriptor 멤버를 무시하지만 bInheritHandle 멤버를 계속 사용합니다.

구조체 bInheritHandlemember는 반환 된 핸들을 상속 할 수 있는지 여부를 지정합니다.

자세한 내용은 **Remarks section** 을 참조하십시오.



#### 2.5 dwCreationDisposition

존재하거나 존재하지 않는 파일이나 장치를 취하는 작업.

파일이 아닌 장치의 경우이 매개 변수는 일반적으로 OPEN_EXISTING으로 설정됩니다.

자세한 내용은 **Remarks section** 을 참조하십시오.

이 매개 변수는 결합 할 수없는 다음 값 중 하나 여야합니다.

| Value                   | Meaning                                                      |
| ----------------------- | ------------------------------------------------------------ |
| **CREATE_ALWAYS** 2     | 항상 새 파일을 만듭니다. 지정된 파일이 있고 쓰기 가능한 경우 함수는 파일을 덮어 쓰고 함수는 성공하고 마지막 오류 코드는 ERROR_ALREADY_EXISTS (183)로 설정됩니다.<br/><br/>지정된 파일이 존재하지 않고 유효한 경로 인 경우, 새 파일이 작성되고 함수가 성공하며 마지막 오류 코드가 0으로 설정됩니다.<br/><br/>자세한 내용은이 항목의주의 섹션을 참조하십시오. |
| **CREATE_NEW** 1        | 새 파일을 아직 작성하지 않은 경우에만 작성합니다.<br/><br/>지정된 파일이 있으면 함수는 실패하고 마지막 오류 코드는 ERROR_FILE_EXISTS (80)로 설정됩니다.<br/><br/>지정된 파일이 존재하지 않고 쓰기 가능한 위치에 대한 유효한 경로 인 경우 새 파일이 작성됩니다. |
| **OPEN_ALWAYS** 4       | 항상 파일을 엽니 다. 지정된 파일이 있으면 함수는 성공하고 마지막 오류 코드는 ERROR_ALREADY_EXISTS (183)로 설정됩니다.<br/><br/>지정된 파일이 존재하지 않고 쓰기 가능한 위치에 대한 유효한 경로 인 경우이 함수는 파일을 만들고 마지막 오류 코드는 0으로 설정됩니다. |
| **OPEN_EXISTING**3      | 파일 또는 장치가있는 경우에만 엽니 다. 지정된 파일이나 장치가 없으면이 함수는 실패하고 마지막 오류 코드는 ERROR_FILE_NOT_FOUND (2)로 설정됩니다.<br/><br/>장치에 대한 자세한 내용은주의 섹션을 참조하십시오. |
| **TRUNCATE_EXISTING** 5 | 파일을 열고 크기가 0 바이트가되도록 자릅니다. 지정된 파일이 존재하지 않으면 함수는 실패하고 마지막 오류 코드는 ERROR_FILE_NOT_FOUND (2)로 설정됩니다.<br/><br/>호출 프로세스는 dwDesiredAccess 매개 변수의 일부로 설정된 GENERIC_WRITE 비트를 사용하여 파일을 열어야합니다. |



#### 2.6 dwFlagsAndAttributes

파일 또는 장치 속성 및 플래그 FILE_ATTRIBUTE_NORMAL은 파일의 가장 일반적인 기본값입니다.

이 매개 변수에는 사용 가능한 파일 속성 (FILE_ATTRIBUTE_ *)의 모든 조합을 포함 할 수 있습니다. 다른 모든 파일 특성은 FILE_ATTRIBUTE_NORMAL보다 우선합니다.

이 매개 변수에는 파일 또는 장치 캐싱 동작, 액세스 모드 및 기타 특수 목적 플래그 제어를위한 플래그 조합 (FILE_FLAG_)도 포함될 수 있습니다. 이것은 FILE_ATTRIBUTE_ 값과 결합됩니다.

이 매개 변수에는 SECURITY_SQOS_PRESENT 플래그를 지정하여 SQOS (Security Quality of Service) 정보를 포함 할 수도 있습니다. 추가 SQOS 관련 플래그 정보는 속성 및 플래그 테이블 다음의 테이블에 표시됩니다.

```
CreateFile이 기존 파일을 열 때 그것은 일반적으로 기존 파일의 파일 특성과 파일 플래그를 결합하고, dwFlagsAndAttributes에의 일부로 제공되는 파일 특성을 무시합니다. 특별한 경우는 파일 생성 및 열기에서 자세히 설명합니다.
```

다음 파일 특성 및 플래그 중 일부는 파일에만 적용될 수 있으며 CreateFile에서 열 수있는 다른 모든 유형의 장치에 적용 할 필요는 없습니다. 자세한 내용은이 항목의주의 절 및 파일 만들기 및 열기를 참조하십시오.

파일 특성에 대한 고급 액세스 방법은 [SetFileAttributes](https://msdn.microsoft.com/3d5400c3-555f-44fc-9470-52a36d04d90b)를 참조하십시오. 값과 설명이있는 모든 파일 속성의 전체 목록을 보려면 **파일 속성 상수**를 참조하십시오.

| Attribute                                   | Meaning                                                      |
| ------------------------------------------- | ------------------------------------------------------------ |
| **FILE_ATTRIBUTE_ARCHIVE** 32 (0x20)        | 백업 또는 제거용 으로 적합한 파일. **일반 파일**             |
| **FILE_ATTRIBUTE_ENCRYPTED** 16384 (0x4000) | 파일 또는 디렉토리가 암호화됩니다. 파일의 경우 이는 파일의 모든 데이터가 암호화됨을 의미합니다. 디렉토리의 경우 이는 새로 생성 된 파일 및 하위 디렉토리의 암호화가 기본임을 의미합니다. 자세한 내용은 파일 암호화를 참조하십시오.<br/><br/>FILE_ATTRIBUTE_SYSTEM도 지정되어 있으면이 플래그는 아무 효과가 없습니다.<br/><br/>Home, Home Premium, Starter 또는 ARM 버전의 Windows에서는 이 플래그가 지원되지 않습니다. |
| **FILE_ATTRIBUTE_HIDDEN** 2 (0x2)           | 파일이 숨겨져 있습니다. 일반 디렉토리 목록에 포함시키지 마십시오. |
| **FILE_ATTRIBUTE_NORMAL** 128 (0x80)        | 파일에 다른 속성이 설정되어 있지 않습니다. 이 속성은 단독으로 사용하는 경우에만 유효합니다. |
| **FILE_ATTRIBUTE_OFFLINE** 4096 (0x1000)    | 파일의 데이터는 즉시 사용할 수 없습니다. 이 특성은 파일 데이터가 물리적으로 오프라인 저장소로 이동되었음을 나타냅니다. 이 특성은 계층 적 저장소 관리 소프트웨어 인 원격 저장소에서 사용됩니다. 응용 프로그램은이 속성을 임의로 변경하면 안됩니다. |
| **FILE_ATTRIBUTE_READONLY** 1 (0x1)         | 파일은 읽기 전용입니다. 응용 프로그램은 파일을 읽을 수는 있지만 파일에 쓰거나 지울 수는 없습니다. |
| **FILE_ATTRIBUTE_SYSTEM** 4 (0x4)           | 파일은 운영 체제의 일부이거나 독점적으로 사용됩니다.         |
| **FILE_ATTRIBUTE_TEMPORARY** 256 (0x100)    | 파일이 임시 저장에 사용되고 있습니다. 자세한 내용은이 항목의 [캐싱 동작](https://docs.microsoft.com/) 섹션을 참조하십시오. |

| Flag                                        | Meaning                                                      |
| ------------------------------------------- | ------------------------------------------------------------ |
| **FILE_FLAG_BACKUP_SEMANTICS** 0x02000000   | 백업 또는 복원 작업을 위해 파일을 열거 나 만들었습니다. 시스템은 프로세스에 SE_BACKUP_NAME 및 SE_RESTORE_NAME 권한이 있으면 호출 프로세스가 파일 보안 검사를 무시하도록합니다. 자세한 내용은 [토큰에서 권한 변경](https://msdn.microsoft.com/b8e47d04-07c1-4d57-8209-6b0c397476e5)을 참조하십시오.<br/><br/>디렉토리에 대한 핸들을 얻으려면이 플래그를 설정해야합니다. 디렉터리 핸들은 파일 핸들 대신 일부 기능으로 전달 될 수 있습니다. 자세한 내용은주의 섹션을 참조하십시오. |
| **FILE_FLAG_DELETE_ON_CLOSE** 0x04000000    | 파일은 지정된 핸들과 다른 열려 있거나 중복 된 핸들을 포함하여 모든 핸들이 닫힌 후 즉시 삭제됩니다. 파일에 대한 열린 핸들이있는 경우 FILE_SHARE_DELETE 공유 모드로 모두 열지 않으면 호출이 실패합니다.<br/><br/>FILE_SHARE_DELETE 공유 모드가 지정되어 있지 않으면 파일에 대한 후속 열기 요청이 실패합니다. |
| **FILE_FLAG_NO_BUFFERING** 0x20000000       | 파일 또는 장치가 데이터 읽기 및 쓰기를위한 시스템 캐싱없이 열리고 있습니다. 이 플래그는 하드 디스크 캐싱 또는 메모리 매핑 된 파일에는 영향을주지 않습니다. FILE_FLAG_NO_BUFFERING 플래그를 사용하여 CreateFile로 열린 파일을 성공적으로 사용하기위한 엄격한 요구 사항이 있습니다. 자세한 내용은 [파일 버퍼링](https://msdn.microsoft.com/ae1e5d0f-9b55-4aae-8402-b9c8e33d9363)을 참조하십시오. |
| **FILE_FLAG_OPEN_NO_RECALL** 0x00100000     | 파일 데이터가 요청되었지만 원격 저장소에 계속 있어야합니다. 로컬 저장소로 다시 전송하면 안됩니다. 이 플래그는 원격 스토리지 시스템에서 사용됩니다. |
| **FILE_FLAG_OPEN_REPARSE_POINT** 0x00200000 | 정상적인 재분석 처리는 발생하지 않습니다. CreateFile은 재분석 지점을 열려고 시도합니다. 파일을 열면 재분석 지점을 제어하는 필터가 작동하는지 여부에 관계없이 파일 핸들이 반환됩니다.<br/><br/>이 플래그는 CREATE_ALWAYS 플래그와 함 2 사용할 수 없습니다.<br/><br/>파일이 재분석 지점이 아니면이 플래그는 무시됩니다.<br/><br/>자세한 내용은주의 섹션을 참조하십시오. |
| **FILE_FLAG_OVERLAPPED **0x40000000         | 비동기 I/O를 위해 파일 또는 장치를 열거 나 만들었습니다. 이 핸들에서 후속 I/O 작업이 완료되면 OVERLAPPED 구조에 지정된 이벤트가 신호 상태로 설정됩니다.<br/><br/>이 플래그가 지정되면, 파일은 동시 읽기/쓰기 조작에 사용될 수 있습니다.<br/><br/>이 플래그를 지정하지 않으면 읽기/쓰기 함수에 대한 호출이 OVERLAPPED 구조를 지정하더라도 I/O 조작이 직렬화됩니다..<br/><br/>이 플래그로 작성된 파일 핸들을 사용할 때 고려해야 할 사항에 대해서는이 항목의 동기 및 비동기 I/O 핸들 절을 참조하십시오. |
| **FILE_FLAG_POSIX_SEMANTICS **0x0100000     | POSIX 규칙에 따라 액세스가 발생합니다. 여기에는 해당 이름을 지원하는 파일 시스템에 대해 이름이 다른 여러 파일 (대소 문자 만 다를 수 있음)이 허용됩니다. 이 플래그를 사용하여 만든 파일은 MS-DOS 또는 16 비트 Windows 용으로 작성된 응용 프로그램에서 액세스 할 수 없으므로이 옵션을 사용할 때는주의하십시오. |
| **FILE_FLAG_RANDOM_ACCESS **0x10000000      | 액세스는 무작위로 이루어집니다. 시스템은이를 파일 캐싱을 최적화하기위한 힌트로 사용할 수 있습니다. 파일 시스템이 캐시 된 I/O 및 FILE_FLAG_NO_BUFFERING을 지원하지 않으면이 플래그는 아무 효과가 없습니다.<br/><br/>자세한 내용은이 항목의 캐싱 동작 섹션을 참조하십시오. |
| **FILE_FLAG_SESSION_AWARE** 0x00800000      | 파일 또는 장치가 세션 인식으로 열리고 있습니다. 이 플래그를 지정하지 않으면 세션 0에서 실행중인 프로세스에서 세션 별 장치 (예 : RemoteFX USB 리디렉션을 사용하는 장치)를 열 수 없습니다.이 플래그는 세션 0에 있지 않은 호출자에게는 아무런 영향을 미치지 않습니다. Windows 서버 에디션. Windows Server 2008 R2 및 Windows Server 2008 :이 플래그는 Windows Server 2012 이전에는 지원되지 않습니다. |
| **FILE_FLAG_SEQUENTIAL_SCAN** 0x08000000    | 액세스는 처음부터 끝까지 순차적으로 이루어집니다. 시스템은이를 파일 캐싱을 최적화하기위한 힌트로 사용할 수 있습니다..<br/>읽기 전용 (역방향 스캔)이 사용되는 경우이 플래그를 사용하면 안됩니다.<br/><br/>파일 시스템이 캐시 된 I/O 및 FILE_FLAG_NO_BUFFERING을 지원하지 않으면이 플래그는 아무 효과가 없습니다.<br/><br/>자세한 내용은이 항목의 캐싱 동작 섹션을 참조하십시오. |
| **FILE_FLAG_WRITE_THROUGH** 0x80000000      | 쓰기 작업은 중간 캐시를 통과하지 않으며 직접 디스크로 이동합니다.<br/>**가급적이면 캐시를 사용하지 않고 곧바로 디스크로 입출력을 행하도록 한다. 그러나 이 플래그를 지정해도 시스템이 쓰기 캐시를 사용할 수는 있되 다만 너무 늦게 버퍼를 비우지 않도록 해 준다. 기록 후 곧바로 사용해야 하는 데이터는 이 플래그를 주는 것이 좋다.** |

dwFlagsAndAttributes 매개 변수는 SQOS 정보를 지정할 수도 있습니다. 자세한 내용은 가장 (Impersonation) 수준을 참조하십시오. 호출 응용 프로그램이 dwFlagsAndAttributes의 일부로 SECURITY_SQOS_PRESENT 플래그를 지정하면 다음 값 중 하나 이상을 포함 할 수도 있습니다.

| Security flag                 | Meaning                                                      |
| ----------------------------- | ------------------------------------------------------------ |
| **SECURITY_ANONYMOUS**        | 익명의 가장 수준에서 클라이언트를 가장합니다.                |
| **SECURITY_CONTEXT_TRACKING** | 보안 추적 모드는 동적입니다. 이 플래그를 지정하지 않으면 보안 추적 모드가 고정됩니다. |
| **SECURITY_DELEGATION**       | 위임 위임 수준에서 클라이언트를 가장합니다.                  |
| **SECURITY_EFFECTIVE_ONLY**   | 클라이언트 보안 컨텍스트의 활성화 된 부분 만 서버에서 사용할 수 있습니다. 이 플래그를 지정하지 않으면 클라이언트 보안 컨텍스트의 모든 측면을 사용할 수 있습니다.rn |
| **SECURITY_IDENTIFICATION**   | 식별 가장 (impersonation) 수준에서 클라이언트를 가장합니다.  |
| **SECURITY_IMPERSONATION**    | 가장 (impersonation) 수준에서 클라이언트를 가장합니다. SECURITY_SQOS_PRESENT 플래그와 함께 다른 플래그가 지정되지 않은 경우 이것이 기본 작동입니다. |



#### 2.7 hTemplateFile

GENERIC_READ 액세스 권한이있는 템플리트 파일에 대한 유효한 핸들. 템플리트 파일은 작성중인 파일에 대한 파일 속성 및 확장 속성을 제공합니다.

이 매개 변수는 NULL 일 수 있습니다.

기존 파일을 열 때 CreateFile은이 매개 변수를 무시합니다.

새 암호화 된 파일을 열 때 파일은 상위 디렉토리에서 임의 액세스 제어 목록을 상속합니다. 자세한 내용은 [파일 암호화](https://msdn.microsoft.com/5f20109f-727d-44a9-90a1-0adc19b00d28)를 참조하십시오.



**Return Value**

함수가 성공하면 반환 값은 지정된 파일, 장치, 명명 된 파이프 또는 메일 슬롯에 대한 열린 핸들입니다.

함수가 실패하면 반환 값은 INVALID_HANDLE_VALUE입니다. 확장 된 오류 정보를 얻으려면 GetLastError를 호출하십시오.



**Remarks**

CreateFile은 원래 파일 상호 작용을 위해 특별히 개발되었지만 Windows 개발자가 사용할 수있는 대부분의 다른 유형의 I/O 장치와 메커니즘을 포함하도록 확장 및 향상되었습니다. 이 섹션에서는 CreateFile을 다양한 컨텍스트 및 다양한 I/O 유형으로 사용할 때 개발자가 겪을 수있는 다양한 문제를 다루려고합니다. 텍스트는 파일 시스템의 실제 파일에 저장된 데이터를 구체적으로 언급 할 때만 파일이라는 단어를 사용하려고 시도합니다. 그러나 파일의 일부 사용은 파일과 유사한 메커니즘을 지원하는 I/O 객체를보다 일반적으로 참조 할 수 있습니다. 파일이라는 용어의 자유로운 사용은 이전에 언급 된 역사적인 이유로 인해 상수 이름과 매개 변수 이름에서 특히 빈번합니다.

CreateFile에서 반환 된 개체 핸들을 사용하여 응용 프로그램이 끝나면 CloseHandle 함수를 사용하여 핸들을 닫습니다. 이렇게하면 시스템 리소스가 확보 될뿐 아니라 파일이나 장치를 공유하고 데이터를 디스크에 커밋하는 것과 같은 일에 더 많은 영향을 미칠 수 있습니다. 이 주제에는 구체적인 내용이 적혀 있습니다.

기타 더 많은 정보는 https://docs.microsoft.com/ko-kr/windows/desktop/api/fileapi/nf-fileapi-createfilea 를 참조 하도록 한다.

