# 파일 버퍼링

출처: <https://docs.microsoft.com/ko-kr/windows/desktop/FileIO/file-buffering>

정렬 및 파일 액세스 요구 사항

이 항목에서는 버퍼링되지 않은 파일 입출력 (I/O)이라고도하는 파일 버퍼링의 응용 프로그램 제어에 대한 다양한 고려 사항에 대해 설명합니다. 파일 버퍼링은 대개 배후의 시스템에서 처리하며 달리 지정하지 않는 한 Windows 운영 체제 내에서 파일 캐싱의 일부로 간주됩니다. 캐싱과 버퍼링이라는 용어는 때때로 같은 의미로 사용 되기는하지만이 주제에서는 시스템에서 캐시되지 않는 (버퍼링 된) 데이터와 상호 작용하는 방법을 설명하는 컨텍스트에서 특별히 버퍼링이라는 용어를 사용합니다. 사용자 모드 응용 프로그램

CreateFile 함수를 사용하여 파일을 열거 나 만들 때 FILE_FLAG_NO_BUFFERING 플래그를 지정하여 파일에서 읽거나 파일에 쓰는 데이터의 시스템 캐싱을 비활성화 할 수 있습니다. 이것은 데이터 I/O 버퍼링을 완벽하고 직접 제어 할 수 있지만 파일 및 유사한 장치의 경우 고려해야하는 데이터 정렬 요구 사항이 있습니다.

**참고**

```
이 정렬 정보는 탐색을 지원하는 파일 및 파일 위치 포인터 (또는 오프셋)의 개념과 같은 장치의 I/O에 적용됩니다. 명명 된 파이프 또는 통신 장치와 같이 검색하지 않는 장치의 경우 버퍼링을 해제하면 특정 정렬이 필요하지 않을 수 있습니다. 이 경우 정렬을 통해 얻을 수있는 모든 제한 사항이나 효율성은 기본 기술에 따라 다릅니다.
```

간단한 예제에서 응용 프로그램은 FILE_FLAG_NO_BUFFERING 플래그로 쓰기 액세스를 위해 파일을 연 다음 응용 프로그램 내에 정의 된 데이터 버퍼를 사용하여 WriteFile 함수를 호출합니다. 이 로컬 버퍼는 이러한 상황에서이 작업을 위해 존재하는 유일한 파일 버퍼입니다. 물리적 디스크 레이아웃, 파일 시스템 저장소 레이아웃 및 시스템 수준 파일 포인터 위치 추적으로 인해 로컬 정의 데이터 버퍼가 다음 섹션에서 설명하는 특정 정렬 기준을 충족시키지 않으면이 쓰기 작업이 실패합니다.

**참고**

```
캐싱에 대한 논의는 물리적 디스크 자체에 하드웨어 캐싱을 고려하지 않았으며 어떠한 경우에도 시스템을 직접 제어 할 수는 없습니다. 이것은이 주제에서 지정된 요구 사항에 영향을 미치지 않습니다.
```

FILE_FLAG_NO_BUFFERING이 다른 캐시 관련 플래그와 상호 작용하는 방법에 대한 자세한 내용은 CreateFile을 참조하십시오.



## 정렬 및 파일 액세스 요구 사항

앞에서 설명한 것처럼 응용 프로그램은 FILE_FLAG_NO_BUFFERING으로 열린 파일로 작업 할 때 특정 요구 사항을 충족해야합니다. 다음 세부 사항이 적용됩니다.

- OVERLAPPED 구조의 선택적 파일 오프셋을 포함하여 파일 액세스 크기 (지정된 경우)는 볼륨 섹터 크기의 정수배 인 바이트 수 여야합니다. 예를 들어 섹터 크기가 512 바이트 인 경우 응용 프로그램은 512, 1,024, 1,536 또는 2,048 바이트의 읽기 및 쓰기를 요청할 수 있지만 335, 981 또는 7,171 바이트의 읽기 및 쓰기는 요청할 수 없습니다.
- 읽기 및 쓰기 작업을위한 파일 액세스 버퍼 주소는 물리적 섹터 정렬이어야합니다. 즉, 메모리의 물리적 물리 섹터 크기의 정수배 인 주소에 정렬되어야합니다. 디스크에 따라이 요구 사항이 적용되지 않을 수도 있습니다.

응용 프로그램 개발자는 물리적 미디어 섹터 크기가 4,096 바이트 인 새로운 유형의 저장 장치를 시장에 도입해야합니다. 이러한 장치의 산업 이름은 '고급 형식'입니다. 미디어에 대한 주소 지정 단위로 4,096 바이트를 직접 도입하는 것과 호환성 문제가있을 수 있으므로 임시 호환성 솔루션은 일반 512 바이트 섹터 저장 장치를 에뮬레이트하지만 실제 ATA를 통해 실제 섹터 크기에 대한 정보를 제공하는 장치를 도입하는 것입니다 및 SCSI 명령.

이 에뮬레이션의 결과로 개발자는 이해해야 할 두 가지 섹터 크기가 본질적으로 있습니다.

- 논리 섹터 : 미디어의 논리 블록 주소 지정에 사용되는 단위입니다. 또한 스토리지를 수용 할 수있는 가장 작은 단위로 생각할 수 있습니다. 이것은 '에뮬레이션'입니다.
- 물리적 섹터 : 장치에 대한 읽기 및 쓰기 작업이 단일 작업으로 완료되는 장치입니다. 이것은 원자 쓰기의 단위이며, 최적의 성능 및 신뢰성 특성을 갖기 위해 언 버퍼 드 I/O가 정렬되어야하는 요소입니다.

IOCTL_DISK_GET_DRIVE_GEOMETRY 및 GetDiskFreeSpace와 같은 최신 Windows API는 논리 섹터 크기를 반환하지만 STORAGE_ACCESS_ALIGNMENT_DESCRIPTOR 구조의 BytesPerPhysicalSector 멤버에 포함 된 관련 정보와 함께 IOCTL_STORAGE_QUERY_PROPERTY 제어 코드를 통해 실제 섹터 크기를 검색 할 수 있습니다. 예를 들어 STORAGE_ACCESS_ALIGNMENT_DESCRIPTOR의 샘플 코드를 참조하십시오. Microsoft는 IOCTL_STORAGE_QUERY_PROPERTY 제어 코드가보고 한 실제 섹터 크기에 버퍼되지 않은 I / O를 정렬하여 응용 프로그램이이 섹터 크기 전환에 대비할 수 있도록하는 것이 좋습니다.