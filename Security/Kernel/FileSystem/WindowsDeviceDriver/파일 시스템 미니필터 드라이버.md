# 파일 시스템 미니필터 드라이버

이 절에는 파일 시스템 미니 필터 드라이버를 설명하는 다음 항목이 포함되어 있습니다.

[필터 관리자 및 Minifilter 드라이버 아키텍처](https://docs.microsoft.com/ko-kr/windows-hardware/drivers/ifs/filter-manager-and-minifilter-driver-architecture)

[미니 필터 드라이버 설치](https://docs.microsoft.com/ko-kr/windows-hardware/drivers/ifs/installing-a-minifilter-driver)

[미니 필터 드라이버에 대한 DriverEntry 루틴 작성](https://docs.microsoft.com/ko-kr/windows-hardware/drivers/ifs/writing-a-driverentry-routine-for-a-minifilter-driver)

[Minifilter 드라이버에 대한 FilterUnloadCallback 루틴 작성](https://docs.microsoft.com/ko-kr/windows-hardware/drivers/ifs/writing-a-filterunloadcallback-routine-for-a-minifilter-driver)

[사전 및 사후 콜백 루틴 작성](https://docs.microsoft.com/ko-kr/windows-hardware/drivers/ifs/writing-preoperation-and-postoperation-callback-routines)

[미니 필터 드라이버에서 컨텍스트 관리](https://docs.microsoft.com/ko-kr/windows-hardware/drivers/ifs/managing-contexts-in-a-minifilter-driver)

[기타 정보](https://docs.microsoft.com/ko-kr/windows-hardware/drivers/ifs/miscellaneous-information)





## <span style="color:blue">필터 관리자 및 Minifilter 드라이버 아키텍처</span>

필터 관리자는 레거시 파일 시스템  필터 모델을 준수하고 파일 시스템 필터 드라이버에 일반적으로 필요한 기능을 제공하는 커널 모드 드라이버입니다. 이 기능을 이용함으로써 타사 개발자는 레거시 파일 시스템 필터 드라이버 보다 개발이 간단한 미니 필터 드라이버를 작성할 수 있으므로 개발 프로세스가 단축되고 고품질의 견고한 드라이버가 생성됩니다.

이 섹션에는 다음 내용이 포함됩니다.

[필터 관리자 개념](https://docs.microsoft.com/ko-kr/windows-hardware/drivers/ifs/filter-manager-concepts)

[Filter Manager 모델의 장점](https://docs.microsoft.com/ko-kr/windows-hardware/drivers/ifs/advantages-of-the-filter-manager-model) 

[Filter Manager Minifilter 드라이버 지원](https://docs.microsoft.com/ko-kr/windows-hardware/drivers/ifs/filter-manager-support-for-minifilter-drivers) 

[Filter Manager 운영 제어](https://docs.microsoft.com/ko-kr/windows-hardware/drivers/ifs/controlling-filter-manager-operation) 

[개발 및 테스트 도구](https://docs.microsoft.com/ko-kr/windows-hardware/drivers/ifs/development-and-testing-tools) 

[레거시 필터 드라이버 포팅 지침](https://docs.microsoft.com/ko-kr/windows-hardware/drivers/ifs/guidelines-for-porting-legacy-filter-drivers)



## <span style="color:green">필터 관리자 개념</span>

**필터 관리자는 Windows와 함께 설치되지만 미니 필터 드라이버가 로드 될 때만 활성화됩니다.** 필터 관리자는 대상 볼륨에 대한 파일 시스템 스택에 연결합니다. 미니 필터 드라이버는 필터를 위해 선택한 I/O 작업에 대한 필터 관리자에 등록하여 간접적으로 파일 시스템 스택에 연결합니다.

파일 시스템 I/O 스택의 레거시 필터 드라이버가 다른 필터 드라이버와 관련하여 시스템 시작시 부하 순서 그룹에 의해 결정됩니다. 예를 들어 바이러스 백신 필터 드라이버는 복제 필터 드라이버보다 스택에서 더 높아야하므로 원격 서버에 복제되기 전에 바이러스를 탐지하고 파일을 치료할 수 있습니다. 따라서 FSFilter Anti-Virus 로드 순서 그룹의 필터 드라이버는, FSFilter Replication(복제) 그룹의 필터 드라이버보다 먼저로드됩니다. 각 로드 순서 그룹에는 해당 시스템 정의 클래스와 클래스 GUID가 필터 드라이버의 INF 파일에 사용됩니다.

레거시 필터 드라이버와 마찬가지로 미니 필터 드라이버도 특정 순서로 연결됩니다. **그러나 부착 순서는 고도(Altitude)라고하는 고유 식별자로 결정**됩니다. 특정 볼륨에서 특정 고도에서 미니 필터 드라이버를 부착하는 것을 미니 필터 드라이버의 인스턴스라고합니다.

미니 필터 드라이버의 고도(Altitude)는 미니 필터 드라이버의 인스턴스가 항상 다른 미니 필터 드라이버 인스턴스와 관련된 적절한 위치에로드되고 필터 관리자가 미니 필터 드라이버를 호출하여 I/O를 처리하는 순서를 결정합니다. 고도(Altitude)는 Microsoft에서 할당하고 관리합니다.

다음 그림은 필터 관리자와 세 개의 미니 필터 드라이버가있는 단순화 된 I/O 스택을 보여줍니다.

![](.\Images\filter-manager-architecture-1.gif)

미니 필터 드라이버는 고속 I/O 및 FSFilter (FSFilter) 콜백 작업은 물론 IRP 기반 I/O 작업도 필터링 할 수 있습니다. 필터링 할 I/O 작업 각각에 대해 미니 필터 드라이버는 **[사전 콜백 루틴](https://docs.microsoft.com/ko-kr/windows-hardware/drivers/ifs/writing-preoperation-and-postoperation-callback-routines), 사후 콜백 루틴** 또는 둘 다를 등록 할 수 있습니다. I/O 작업을 처리 할 때 필터 관리자는 해당 작업에 대해 등록 된 각 미니 필터 드라이버에 대해 적절한 콜백 루틴을 호출합니다. 해당 콜백 루틴이 반환되면 필터 관리자는 해당 작업에 대해 등록 된 다음 minifilter 드라이버에 대한 적절한 콜백 루틴을 호출합니다.

예를 들어, 위의 그림에서 세 개의 미니 필터 드라이버가 모두 동일한 I/O 작업에 등록되었다고 가정하면 필터 관리자는 고도(Altitude)에서 순서대로 (A, B, C) 사전 실행 콜백 루틴을 호출 한 다음 I/O 요청을 처리해야합니다. 필터 관리자는 완료를위한 I/O 요청을 받으면 가장 낮은 순서 (C, B, A)의 역순으로 각 미니 필터 드라이버의 사후 콜백 루틴을 호출합니다.

레거시 필터 드라이버와의 상호 운용성을 위해 필터 관리자는 필터 장치 개체를 둘 이상의 위치에서 파일 시스템 I/O 스택에 첨부 할 수 있습니다. 필터 관리자의 필터 장치 개체 각각을 프레임이라고합니다. 레거시 필터 드라이버의 관점에서 각 필터 관리자 프레임은 다른 레거시 필터 드라이버입니다.

각 필터 관리자 프레임은 고도(Altitude) 범위를 나타냅니다. 필터 관리자는 기존 프레임을 조정하거나 새 프레임을 만들어 미니 필터 드라이버를 올바른 위치에 부착 할 수 있습니다.

필터 매니저는, 필터 매니저 프레임이 이미 존재하지 않는 한, 2 개의 부속 레거시 필터의 사이에 미니 필터를 첨부 할 수 없다. 미니 필터를 레거시 필터 위에 부착하려는 경우 두 번째 연결된 레거시 필터의 존재 여부에 따라 미니 필터를 아래에 연결할 수 있습니다. 대신 레거시 필터 아래에 부착하려는 미니 필터를 레거시 필터 위에 부착 할 수 있습니다.

<span style="color:red">중요</span> 레거시 필터와 미니 필터의 상호 운용성을 항상 확인하거나 **레거시 필터를 미니 필터로 교체**하십시오. 자세한 내용은 [레거시 필터 드라이버 포팅 지침](https://docs.microsoft.com/ko-kr/windows-hardware/drivers/ifs/guidelines-for-porting-legacy-filter-drivers)을 참조하십시오.

미니 필터 드라이버가 언로드되고 다시 로드되면 언로드 된 동일한 프레임의 동일한 고도에서 다시로드됩니다.

다음 그림은 두 개의 필터 관리자 프레임, 미니 필터 드라이버 인스턴스 및 레거시 필터 드라이버가있는 단순화 된 I/O 스택을 보여줍니다.

![](.\Images\filter-manager-architecture-2.gif)

## <span style="color:green">필터 관리자 모델의 장점</span>

필터 관리자 모델은 기존 레거시 필터 드라이버 모델에 비해 다음과 같은 이점을 제공합니다.

- **필터로드 순서를보다 효과적으로 제어 할 수 있습니다.**  레거시 필터 드라이버와 달리 미니 필터 드라이버는 언제든지로드 할 수 있으며 고도(Altitude)에 따라 적절한 위치에 부착 할 수 있습니다.
- **시스템이 실행되는 동안 언로드하는 기능.** 시스템이 실행되는 동안 언로드 할 수없는 레거시 필터 드라이버와 달리 minifilter 드라이버는 필요 할 경우 언제든지 언로드 될 수 있습니다. 필터 관리자는 모든 미니 필터 드라이버 첨부 파일의 안전한 제거를 동기화하며 미니 필터 드라이버가 언로드 된 후 완료되는 작업을 처리합니다.
- **필요한 작업 만 처리 할 수있는 기능.** 필터 관리자는 미니 필터 드라이버가 필터링 할 I/O 작업 유형 (IRP 기반, 고속 I/O 또는 FSFilter)을 선택할 수있는 콜백 모델을 사용합니다. <span style="color:red">**minifilter 드라이버는 콜백 루틴을 등록한 I/O 요청 만받습니다.**</span> 미니 필터 드라이버는 고유 한 사전작업 또는 사후작업 콜백 루틴 또는 둘 다를 등록 할 수 있으며 페이징 I/O 및 캐시 된 I/O와 같은 특정 유형의 작업을 무시할 수 있습니다.
- **커널 스택을보다 효율적으로 사용합니다.** 필터 관리자는 사용하는 커널 스택의 양을 줄이기 위해 최적화되어 있으며 콜백 모델은 미니 필터 드라이버가 스택에 미치는 영향을 크게 줄입니다. 필터 관리자는 스택의 하위 드라이버 만 볼 수있는 필터 시작 입출력을 지원하여 재귀적 I/O의 영향을 줄입니다.
- **덜 중복 된 코드.**  필터 관리자는 이름 생성을위한 인프라를 제공하고 둘 이상의 minifilter 드라이버가 사용할 파일 이름을 캐싱하는 것과 같이 여러 가지 방법으로 미니 필터 드라이버에 필요한 코드 양을 줄입니다. 필터 관리자는 볼륨에 연결하고 볼륨이 사용 가능할 때 미니 필터 드라이버에 알립니다. 필터 관리자는 다중 프로세서 시스템을 지원하도록 최적화되어있어보다 효율적이고 오류가 적게 발생합니다.
- **복잡성 감소.** 필터 관리자는 이름 지정, 컨텍스트 관리, 사용자 모드와 커널 모드 간의 통신, 파일 시스템 간의 차이점 마스킹과 같은 공통 기능에 대한 지원 루틴을 제공하여 I/O 요청 필터링을 단순화합니다. 필터 관리자는 보류중인 IRP 열거 및 파일 시스템 스택에 연결과 같은 미니 필터 드라이버를 대신하여 특정 작업을 처리합니다.
- **새로운 작업의 손쉬운 추가.** 미니 필터 드라이버는 처리 할 I/O 작업 만 등록하므로 기존 미니 필터 드라이버를 손상시키지 않고 필터 관리자에 새로운 작업에 대한 지원을 추가 할 수 있습니다.
- **여러 플랫폼에 대한 지원 향상.** 미니 필터 드라이버는 필터 관리자를 지원하는 모든 Windows 버전에서 실행할 수 있습니다. 미니 필터 드라이버가 런타임에 사용할 수없는 I/O 작업을 등록하면 필터 관리자는 해당 작업에 대한 minifilter 드라이버를 호출하지 않습니다. 미니 필터 드라이버는 함수가 사용 가능한지 프로그래밍 방식으로 결정할 수 있으며 필터 관리자 구조는 확장 가능하도록 설계됩니다.
- **사용자 모드 응용 프로그램 지원 향상.** 필터 관리자는 미니필터 드라이버와 함께 작동하는 사용자 모드 서비스 및 제어 프로그램에 공통 기능을 제공합니다. **필터 관리자 사용자 모드 라이브러리 인 Filterlib.dll은 사용자 모드 서비스 나 제어 프로그램과 미니 필터 드라이버 간의 통신을 가능하게합니다. Filterlib.dll은 관리 도구에 대한 인터페이스도 제공합니다.**

<span style="color:navy">**위의 Filterlib 는 Fltlib 로 변경 된것으로 보임. Everything 으로 Local Machine 을 검색 해본 결과 나오지 않아 구글링 해 본 결과 바뀐것으로 보임. 다음은 link 주소**</span>

 https://docs.microsoft.com/en-us/windows-hardware/drivers/ifs/user-mode-library

다음은 간단한 개요

<span style="color:navy">**필터 관리자 사용자 모드 인터페이스는 필터 드라이버가 포함 된 제품에 공통 기능을 제공합니다. 사용자 모드 라이브러리는 Fltlib.dll입니다. 응용 프로그램에는 FltUser.h 및 FltUserStructures.h 헤더 파일과 FltLib.lib 링크가 있습니다.**</span>

<span style="color:navy">**이러한 사용자 모드 인터페이스는 사용자 모드 서비스 또는 제어 프로그램과 필터 드라이버 간의 최소 필터 드라이버 및 통신을 전반적으로 제어 할 수있게합니다. 또한 사용자 모드 인터페이스는 필터, 볼륨 및 인스턴스의 열거를 허용하는 관리 도구에 대한 인터페이스를 제공합니다.**</span>

<span style="color:navy">**미니 필터의 경우 사용자 모드 통신 API에는 관리자 권한이 필요하지 않습니다. 대신 미니 필터는 포트에 정의 된 ACL을 사용하여 필요한 권한을 정의합니다.**</span>



## <span style="color:green">Minifilter 드라이버에 대한 필터 관리자 지원</span>

이 절에서는 minifilter 드라이버가 수행하는 일반 작업에 대한 필터 관리자 지원에 대해 설명합니다.

이 섹션에는 다음 주제가 포함되어 있습니다.

[Loading and Unloading](https://docs.microsoft.com/ko-kr/windows-hardware/drivers/ifs/loading-and-unloading)

[Processing I/O Operations](https://docs.microsoft.com/ko-kr/windows-hardware/drivers/ifs/processing-i-o-operations)

[Modifying Parameters](https://docs.microsoft.com/ko-kr/windows-hardware/drivers/ifs/modifying-parameters)

[Accessing User Buffers](https://docs.microsoft.com/ko-kr/windows-hardware/drivers/ifs/accessing-user-buffers)

[Managing File Names](https://docs.microsoft.com/ko-kr/windows-hardware/drivers/ifs/managing-file-names)

[Managing Contexts](https://docs.microsoft.com/ko-kr/windows-hardware/drivers/ifs/managing-contexts)

[I/O Requests Generated by the Minifilter Driver](https://docs.microsoft.com/ko-kr/windows-hardware/drivers/ifs/i-o-requests-generated-by-the-minifilter-driver)

[Communication Between User Mode and Kernel Mode](https://docs.microsoft.com/ko-kr/windows-hardware/drivers/ifs/communication-between-user-mode-and-kernel-mode)

[User-Mode Library](https://docs.microsoft.com/ko-kr/windows-hardware/drivers/ifs/user-mode-library)



### Loading and Unloading

미니필터 드라이버는 시스템이 실행 중일 때 언제든지 로드 할 수 있습니다. 미니 필터 드라이버의 [INF 파일](https://docs.microsoft.com/ko-kr/windows-hardware/drivers/ifs/creating-an-inf-file-for-a-minifilter-driver)에서 드라이버 시작 유형을 **SERVICE_BOOT_START, SERVICE_SYSTEM_START** 또는 **SERVICE_AUTO_START**로 지정하면 기존 필터 드라이버와의 상호 운용성을 지원하기 위해 파일 시스템 필터 드라이버의 기존 로드 순서 그룹 정의에 따라 미니 필터 드라이버가로드됩니다. **시스템이 실행 중일 때 서비스 시작 요청 (sc start, net start 또는 서비스 API)을 통해 또는 명시적 로드 요청 (fltmc load, [FltLoadFilter](https://msdn.microsoft.com/library/windows/hardware/ff543366) 또는 [FilterLoad](https://msdn.microsoft.com/library/windows/hardware/ff541504))을 통해 미니 필터 드라이버를로드 할 수 있습니다.**

minifilter 드라이버가 로드 될 때 minifilter 드라이버의 [DriverEntry](https://docs.microsoft.com/ko-kr/windows-hardware/drivers/ifs/writing-a-driverentry-routine-for-a-minifilter-driver) 루틴이 호출되므로 minifilter 드라이버는 minifilter 드라이버의 모든 인스턴스에 적용되는 초기화를 수행 할 수 있습니다. 해당 DriverEntry 루틴 내에서 minifilter 드라이버는 [FltRegisterFilter](https://msdn.microsoft.com/library/windows/hardware/ff544305)를 호출하여 콜백 루틴을 필터 관리자에 등록하고 [FltStartFiltering](https://msdn.microsoft.com/library/windows/hardware/ff544569)을 호출하여 필터 관리자에게 볼륨에 연결하고 I/O 요청을 필터링 할 준비가되었음을 필터 관리자에 알립니다.

Minifilter 드라이버 인스턴스는 minifilter 드라이버를 설치하는 데 사용되는 INF 파일에 정의됩니다. 미니 필터 드라이버의 INF 파일은 기본 인스턴스를 정의해야하며 추가 인스턴스를 정의 할 수 있습니다. 이러한 정의는 모든 볼륨에 적용됩니다. 각 인스턴스 정의에는 인스턴스 이름, 고도 및 인스턴스를 자동으로, 수동으로 또는 둘 다 연결할 수 있는지 여부를 나타내는 플래그가 포함됩니다. 기본 인스턴스는 필터 관리자가 minifilter 드라이버의 마운트 및 인스턴스 설치 콜백 루틴을 올바른 순서로 호출하도록 minifilter 드라이버를 주문하는 데 사용됩니다. 호출자가 인스턴스 이름을 지정하지 않으면 기본 인스턴스가 명시적 첨부 요청과 함께 사용됩니다.

필터 관리자는 볼륨을 마운트 한 후 첫 번째 작성 작업에서 [InstanceSetupCallback ](https://msdn.microsoft.com/library/windows/hardware/ff551096) 루틴을 호출하여 사용 가능한 볼륨을 미니 필터 드라이버에 자동으로 알립니다. 시스템 시작시 필터 관리자가 기존 볼륨을 열거 할 때 [FltStartFiltering](https://msdn.microsoft.com/library/windows/hardware/ff544569)이 반환되기 전에 이 문제가 발생할 수 있습니다. 런타임 중에 볼륨이 마운트되거나 명시적인 첨부 요청 (fltmc attach, [FltAttachVolume](https://msdn.microsoft.com/library/windows/hardware/ff541772) 또는 [FilterAttach](https://msdn.microsoft.com/library/windows/hardware/ff540442) )의 결과로 발생할 수도 있습니다.

minifilter 드라이버 인스턴스는 미니 필터 드라이버가 언로드 되거나 인스턴스가 연결된 볼륨이 분리되거나 명시 적 분리 요청 (fltmc detach, FltDetachVolume 또는 FilterDetach)의 결과로 제거됩니다. 미니 필터 드라이버가 [InstanceQueryTeardownCallback](https://msdn.microsoft.com/library/windows/hardware/ff551095) 루틴을 등록하면 [FilterDetach](https://msdn.microsoft.com/library/windows/hardware/ff540475) 또는 [FltDetachVolume](https://msdn.microsoft.com/library/windows/hardware/ff542041) 을 호출하여 명시적 분리 요청을 실패 할 수 있습니다. 해체는 다음과 같이 진행됩니다.

- minifilter 드라이버가 [InstanceTeardownStartCallback](https://msdn.microsoft.com/library/windows/hardware/ff551098) 콜백 루틴을 등록한 경우 필터 관리자는 teardown 프로세스 시작시 이를 호출합니다. 이 루틴에서 minifilter 드라이버는 보류중인 모든 작업을 완료하고 minifilter 드라이버에서 생성된 I/O 요청과 같은 다른 작업을 취소하거나 완료해야하며 새 작업 항목 큐를 중지해야합니다.
- 인스턴스 해체 중에 현재 실행중인 사전 또는 사후 콜백 루틴은 정상적인 처리를 계속 수행하며 사후 콜백을 기다리는 모든 I/O 요청은 '소모되거나'취소 될 수 있으며 미니 필터 드라이버에서 생성 된 모든 I/O 요청은 정상 처리를 계속합니다 (완료 될 때까지)
- 미니 필터 드라이버가[ InstanceTeardownCompleteCallback](https://msdn.microsoft.com/library/windows/hardware/ff551098) 루틴을 등록한 경우 필터 관리자는 모든 미해결 I/O 작업이 완료된 후 이 루틴을 호출합니다. 이 루틴에서 minifilter 드라이버는 아직 열려있는 파일을 모두 닫습니다.
- 인스턴스에 대한 모든 미결 참조가 해제되면 필터 관리자는 나머지 컨텍스트를 삭제하고 인스턴스가 완전히 제거됩니다.

시스템이 실행되는 동안 minifilter 드라이버는 서비스 중지 요청 (sc stop, net stop 또는 서비스 API)을 통해 또는 명시 적 언로드 요청 (fltmc unload, [FltUnloadFilter](https://msdn.microsoft.com/library/windows/hardware/ff544602) 또는 [FilterUnload](https://msdn.microsoft.com/library/windows/hardware/ff541516))을 통해 언로드 될 수 있습니다.

minifilter 드라이버가 언로드되면 Minifilter 드라이버의 [FilterUnloadCallback](https://msdn.microsoft.com/library/windows/hardware/ff551085) 루틴이 호출됩니다. 이 루틴은 열려있는 통신 서버 포트를 모두 닫고 [FltUnregisterFilter](https://msdn.microsoft.com/library/windows/hardware/ff544606) 를 호출하고 필요한 정리를 수행합니다. 이 루틴을 등록하는 것은 선택 사항입니다. 그러나 Minifilter 드라이버가 FilterUnloadCallback 루틴을 등록하지 않으면 미니 필터 드라이버를 언로드 할 수 없습니다. 이 루틴에 대한 자세한 정보는 [FilterUnloadCallback 루틴 작성](https://docs.microsoft.com/ko-kr/windows-hardware/drivers/ifs/writing-a-filterunloadcallback-routine) 을 참조하십시오.



### Minifilter 드라이버로드 및 언로드 필터 관리자 루틴

필터 관리자는 명시적 로드 및 언로드 요청에 대해 다음과 같은 지원 루틴을 제공하며 사용자 모드 또는 커널 모드에서 실행할 수 있습니다.

[**FilterLoad**](https://msdn.microsoft.com/library/windows/hardware/ff541504)

[**FilterUnload**](https://msdn.microsoft.com/library/windows/hardware/ff541516)

[**FltLoadFilter**](https://msdn.microsoft.com/library/windows/hardware/ff543366)

[**FltUnloadFilter**](https://msdn.microsoft.com/library/windows/hardware/ff544602)

다음 루틴은 인스턴스 설정 및 teardown에 대한 콜백 루틴을 등록 및 등록 취소하는 데 사용됩니다.

[**FltRegisterFilter**](https://msdn.microsoft.com/library/windows/hardware/ff544305)

[**FltStartFiltering**](https://msdn.microsoft.com/library/windows/hardware/ff544569)

[**FltUnregisterFilter**](https://msdn.microsoft.com/library/windows/hardware/ff544606)



### 인스턴스 설정, 해제 및 언로드를위한 Minifilter 드라이버 콜백 루틴

다음 Minifilter 드라이버 콜백 루틴은 [FltRegisterFilter](https://msdn.microsoft.com/library/windows/hardware/ff544305) 에 매개 변수로 전달되는 [FLT_REGISTRATION](https://msdn.microsoft.com/library/windows/hardware/ff544811) 구조체에 저장됩니다.

| Callback Routine Name                                        | Callback Routine Type                                        |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| [*InstanceSetupCallback*](https://msdn.microsoft.com/library/windows/hardware/ff551096) | [**PFLT_INSTANCE_SETUP_CALLBACK**](https://msdn.microsoft.com/library/windows/hardware/ff551096) |
| [*InstanceQueryTeardownCallback*](https://msdn.microsoft.com/library/windows/hardware/ff551095) | [**PFLT_INSTANCE_QUERY_TEARDOWN_CALLBACK**](https://msdn.microsoft.com/library/windows/hardware/ff551095) |
| [*InstanceTeardownStartCallback*](https://msdn.microsoft.com/library/windows/hardware/ff551098) | [**PFLT_INSTANCE_TEARDOWN_CALLBACK**](https://msdn.microsoft.com/library/windows/hardware/ff551098) |
| [*InstanceTeardownCompleteCallback*](https://msdn.microsoft.com/library/windows/hardware/ff551098) | [**PFLT_INSTANCE_TEARDOWN_CALLBACK**](https://msdn.microsoft.com/library/windows/hardware/ff551098) |
| [*FilterUnloadCallback*](https://msdn.microsoft.com/library/windows/hardware/ff551085) | [**PFLT_FILTER_UNLOAD_CALLBACK**](https://msdn.microsoft.com/library/windows/hardware/ff551085) |



### Processing I/O Operations

필터 관리자는 미니 필터 드라이버에 대한 I/O 작업 처리를 간소화합니다. 레거시 필터 드라이버는 모든 I/O 요청을 다음 하위 드라이버로 올바르게 전달하고 보류중인 요청, 동기화 및 I/O 완료를 올바르게 처리해야, 레거시 필터 드라이버가 요청과 관련된 모든 작업을 수행하는지 여부와 상관없이 미니 필터 드라이버 처리해야하는 I/O 조작에 대해서만 등록합니다.

주어진 I/O 작업의 경우 필터 관리자는 해당 작업에 대한 [사전 콜백 루틴](https://msdn.microsoft.com/library/windows/hardware/ff551109)을 등록한 미니 필터 드라이버 만 호출합니다. 또한 필터 관리자는 매개 변수를 다음 스택 위치로 복사하고 IRP PendingReturned 플래그를 전파하는 등의 minifilter 드라이버 대신 특정 IRP 유지 관리 작업을 처리합니다.

사전 콜백 루틴에서 미니 필터 드라이버는 I/O 작업에 필요한 처리를 수행하고 사전 콜백 루틴에서 적절한 값을 반환하여 IRP에 수행해야 할 작업을 나타냅니다. 예를 들어 완료 루틴을 사용하지 않고 IRP를 다음 하위 드라이버로 전달하려면 minifilter 드라이버가 **FLT_PREOP_SUCCESS_NO_CALLBACK**을 반환합니다. 완료 루틴 (I/O 작업에 대한 미니 필터 드라이버의 사후 콜백 루틴)을 사용하여 동일한 작업을 수행하기 위해 minifilter 드라이버는 **FLT_PREOP_SUCCESS_WITH_CALLBACK**을 반환합니다.

사전 콜백 루틴에서 Minifilter 드라이버는 필요한 경우 [FltQueueDeferredIoWorkItem](https://msdn.microsoft.com/library/windows/hardware/ff543449)을 호출하여 작업을 스레드 대기열에 넣을 수 있습니다. 이렇게하면 minifilter 드라이버는 I/O 작업이 보류 중 임을 나타 내기 위해 사전 콜백 루틴에서 **FLT_PREOP_PENDING**을 반환하고 minifilter 드라이버는 요청 처리를 완료하거나 다시 시작합니다. 처리를 다시 시작하기 위해 minifilter 드라이버는 작업자 스레드에서 [FltCompletePendedPreOperation](https://msdn.microsoft.com/library/windows/hardware/ff541913)을 호출합니다.

미니 필터 드라이버가 처리 할 뛰어난 I/O 작업의 자체 인스턴스 단위 취소 안전 큐를 유지해야하는 경우 **InstanceSetupCallback** 루틴에서 [FltCbdqInitialize](https://msdn.microsoft.com/library/windows/hardware/ff541802) 를 호출하고 필요에 따라 사전 콜백 루틴에서 [FltCbdqInsertIo](https://msdn.microsoft.com/library/windows/hardware/ff541815) 를 호출하여 이러한 큐를 설정할 수 있습니다 I/O 조작을 큐에 삽입합니다.

하위 필터 드라이버 (레거시 필터 및 미니 필터 드라이버)가 처리를 완료하면 필터 관리자는 I/O 작업에 대한 미니 필터 드라이버의 [사후 콜백 루틴](https://msdn.microsoft.com/library/windows/hardware/ff551107) 을 호출합니다.

사후 콜백 루틴에서 minifilter 드라이버는 [FltDoCompletionProcessingWhenSafe](https://msdn.microsoft.com/library/windows/hardware/ff542047)를 호출하여 안전한 IRQL에서 완료 처리가 수행되도록 할 수 있습니다. 또는 필요한 경우 [FltQueueDeferredIoWorkItem](https://msdn.microsoft.com/library/windows/hardware/ff543449)을 호출하여 작업 완료 처리를 작업자 스레드에 대기시킬 수 있습니다. 그렇게하면 minifilter 드라이버는 사후 콜백 루틴에서 **FLT_POSTOP_MORE_PROCESSING_REQUIRED**를 반환하여 I/O 작업에 대한 필터 관리자의 완료 처리를 중지합니다. 완료 처리를 다시 시작하기 위해 minifilter 드라이버는 작업자 스레드에서 [FltCompletePendedPostOperation](https://msdn.microsoft.com/library/windows/hardware/ff541897)을 호출합니다.

필터 관리자는 I/O 작업 대신 minifilter 드라이버 또는 minifilter 드라이버 인스턴스와 관련된 작업 항목 인 '일반'작업 항목의 대기열 지원을 제공합니다. 미니 필터 드라이버는 [FltQueueGenericWorkItem](https://msdn.microsoft.com/library/windows/hardware/ff543452) 을 호출하여 시스템 작업 큐에 작업 항목을 삽입 할 수 있습니다. 이 루틴은 [ExQueueWorkItem](https://msdn.microsoft.com/library/windows/hardware/ff540216)과 같은 루틴과 유사합니다. 예를 들어 [FltAllocateGenericWorkItem](https://msdn.microsoft.com/library/windows/hardware/ff541749)을 호출하여 할당 된 작업 항목을 다시 사용할 수 있습니다. 그러나 FltQueueGenericWorkItem은 minifilter 드라이버가 사용하는 것이 더 안전합니다. 필터 관리자가 해결되지 않은 작업 항목이 여전히 처리되는 동안 minifilter 드라이버 또는 minifilter 드라이버 인스턴스가 언로드되도록 허용하지 않기 때문입니다.

필터 관리자는 oplock (oplock) 작업을 지원합니다. oplock 작업의 경우 미니 필터 드라이버는 파일 시스템 및 레거시 필터 드라이버에서 사용하는 [FsRtlInitializeOplock](https://msdn.microsoft.com/library/windows/hardware/ff543289) 및 [FsRtlOplockFsctrl](https://msdn.microsoft.com/library/windows/hardware/ff543398) 루틴과 동일한 FltInitializeOplock 및 FltOplockFsctrl과 같은 필터 관리자 루틴을 사용할 수 있습니다.



#### I/O 처리를 하기위한 필터 관리자 루틴

필터 관리자는 작업 전 및 후 작업 콜백 루틴에서 보류중인 I/O에 대해 다음과 같은 지원 루틴을 제공합니다.

[**FltCompletePendedPostOperation**](https://msdn.microsoft.com/library/windows/hardware/ff541897)

[**FltCompletePendedPreOperation**](https://msdn.microsoft.com/library/windows/hardware/ff541913)

[**FltDoCompletionProcessingWhenSafe**](https://msdn.microsoft.com/library/windows/hardware/ff542047)

다음 루틴은 작업 전 및 사후 콜백 루틴에서 작업 항목 대기열에 사용됩니다.

[**FltAllocateDeferredIoWorkItem**](https://msdn.microsoft.com/library/windows/hardware/ff541720)

[**FltAllocateGenericWorkItem**](https://msdn.microsoft.com/library/windows/hardware/ff541749)

[**FltFreeDeferredIoWorkItem**](https://msdn.microsoft.com/library/windows/hardware/ff542955)

[**FltFreeGenericWorkItem**](https://msdn.microsoft.com/library/windows/hardware/ff542971)

[**FltQueueDeferredIoWorkItem**](https://msdn.microsoft.com/library/windows/hardware/ff543449)

[**FltQueueGenericWorkItem**](https://msdn.microsoft.com/library/windows/hardware/ff543452)

다음 루틴은 취소 안전 대기열 지원을 제공합니다.

[*FltCbdqDisable*](https://msdn.microsoft.com/library/windows/hardware/ff541796)

[*FltCbdqEnable*](https://msdn.microsoft.com/library/windows/hardware/ff541799)

[*FltCbdqInitialize*](https://msdn.microsoft.com/library/windows/hardware/ff541802)

[*FltCbdqInsertIo*](https://msdn.microsoft.com/library/windows/hardware/ff541815)

[*FltCbdqRemoveIo*](https://msdn.microsoft.com/library/windows/hardware/ff541821)

[*FltCbdqRemoveNextIo*](https://msdn.microsoft.com/library/windows/hardware/ff541825)

다음 루틴은 oplock 지원을 제공합니다.

[*FltCheckOplock*](https://msdn.microsoft.com/library/windows/hardware/ff541844)

[**FltCurrentBatchOplock**](https://msdn.microsoft.com/library/windows/hardware/ff541946)

[**FltInitializeOplock**](https://msdn.microsoft.com/library/windows/hardware/ff543289)

[**FltOplockFsctrl**](https://msdn.microsoft.com/library/windows/hardware/ff543398)

[**FltOplockIsFastIoPossible**](https://msdn.microsoft.com/library/windows/hardware/ff543404)

[**FltUninitializeOplock**](https://msdn.microsoft.com/library/windows/hardware/ff544598)



#### I/O 작업 처리를위한 Minifilter 드라이버 콜백 루틴

| Callback Routine Name | Callback Routine Type                                        |
| --------------------- | ------------------------------------------------------------ |
| *PostOperation*       | [**PFLT_POST_OPERATION_CALLBACK**](https://msdn.microsoft.com/library/windows/hardware/ff551107) |
| *PreOperation*        | [**PFLT_PRE_OPERATION_CALLBACK**](https://msdn.microsoft.com/library/windows/hardware/ff551109) |



### 매개 변수 수정

미니 필터 드라이버는 대상 인스턴스, 대상 파일 객체 및 버퍼 주소 및 메모리 설명자 목록 (MDL) 주소를 포함하는 작업 관련 매개 변수와 같은 I/O 작업과 관련된 특정 매개 변수를 수정할 수 있습니다. minifilter 드라이버는 일반적으로 I/O 요청에 대한 작업 전 콜백에서 매개 변수를 수정합니다. 미니 필터 드라이버가 매개 변수를 수정하면 [FltSetCallbackDataDirty](https://msdn.microsoft.com/library/windows/hardware/ff544383)를 호출하여 매개 변수가 변경되었음을 필터 관리자에 알립니다. 또한 작업 전 콜백에서 전달 된 컨텍스트의 변경 사항을 기록해야 작업 후 콜백에 사용할 수 있습니다.

미니 필터 드라이버는 작업 전 콜백에서 작업을 완료하거나 작업 후 콜백에서 작업을 실패 할 때 (예 : STATUS_SUCCESS를 오류 상태로 변경) 작업의 I/O 상태를 변경할 수 있습니다. 이 경우 FltSetCallbackDataDirty를 호출 할 필요는 없습니다.

매개 변수 수정에 대한 자세한 내용은 [I/O 작업에 대한 매개 변수 수정](https://docs.microsoft.com/ko-kr/windows-hardware/drivers/ifs/modifying-the-parameters-for-an-i-o-operation)을 참조하십시오.

미니 필터 드라이버는 I/O 요청의 버퍼 필드를 자체 버퍼로 바꾸어 '버퍼를 스왑'할 수 있습니다. 이러한 minifilter 드라이버는 I/O 요청의 MDL 및 버퍼 필드를 동기화 상태로 유지합니다. 필터 관리자는 [FLT_CALLBACK_DATA](https://msdn.microsoft.com/library/windows/hardware/ff544620) 구조체에 FLTFL_CALLBACK_DATA_SYSTEM_BUFFER_FLAG를 설정하여 버퍼가 시스템 버퍼인지 여부를 나타냅니다. 그렇다면 미니 필터 드라이버가 비 페이징 풀에서 대체 버퍼를 할당하고 MDL 필드를 NULL로 설정해야합니다. 그렇지 않으면 페이징 된 풀이나 비 페이징 된 풀에서 버퍼를 할당 할 수 있으며 minifilter 드라이버는 항상 MDL을 만들고 설정해야합니다. (빠른 I / O 작업의 경우 새 버퍼는 페이징 된 풀이나 비 페이징 된 풀에서 할당 할 수 있으며 MDL은 NULL이어야합니다.) 미니 필터 드라이버는 버퍼 또는 교체 할 MDL을 해제하지 않아야하며, 콜백 데이터 구조에 성공적으로 삽입 된 MDL을 해제하십시오 (필터 관리자는 미니 필터 드라이버 대신 MDL을 해제합니다). MDL 또는 버퍼를 변경 한 후 Minifilter 드라이버는 [FltSetCallbackDataDirty](https://msdn.microsoft.com/library/windows/hardware/ff544383)를 호출해야합니다.

미니 필터 드라이버는 버퍼를 스왑하는 모든 작업에 대해 작업 후 콜백을 등록해야합니다. 이 콜백 루틴에서 minifilter 드라이버는 할당 된 버퍼를 모두 해제해야합니다. Minifilter 드라이버가 [FltRetainSwappedBufferMdlAddress](https://msdn.microsoft.com/library/windows/hardware/ff544352)를 호출하지 않으면 필터 관리자는 MDL을 해제합니다. 이 경우 미니 필터 드라이버가 MDL을 해제해야합니다. minifilter 드라이버는 [FltGetSwappedBufferMdlAddress](https://msdn.microsoft.com/library/windows/hardware/ff543161) 를 호출하여 작업 전 콜백에 설정된 버퍼에 대한 MDL을 가져올 수 있습니다.

버퍼를 스왑 한 작업 중에 미니 필터 드라이버가 언로드되면 작업을 '소모'할 수 없습니다. 대신 작업이 취소되고 필터 관리자는 미니 필터 드라이버를 언로드하기 전에 작업이 완료 될 때까지 대기합니다.

버퍼를 스왑하는 미니 필터 드라이버의 예는 SwapBuffers 샘플을 참조하십시오.



#### 매개 변수 수정을위한 필터 관리자 루틴

필터 관리자는 사전 작동 및 후 작동 콜백 루틴에서 I/O 작동 매개 변수를 수정하기위한 다음과 같은 지원 루틴을 제공합니다.

[**FltClearCallbackDataDirty**](https://msdn.microsoft.com/library/windows/hardware/ff541853)

[**FltIsCallbackDataDirty**](https://msdn.microsoft.com/library/windows/hardware/ff543311)

[**FltSetCallbackDataDirty**](https://msdn.microsoft.com/library/windows/hardware/ff544383)

다음 루틴은 버퍼 교체를 지원합니다.

[**FltGetSwappedBufferMdlAddress**](https://msdn.microsoft.com/library/windows/hardware/ff543161)

[**FltRetainSwappedBufferMdlAddress**](https://msdn.microsoft.com/library/windows/hardware/ff544352)



### 사용자 버퍼 액세스

버퍼 및 메모리 설명자 목록 (MDL)을 비롯하여 지정된 I/O 연산에 특정한 모든 매개 변수는 [FLT_PARAMETERS](https://msdn.microsoft.com/library/windows/hardware/ff544673) 합집합에 정의됩니다. 이 공용체는 I/O 조작을 나타내는 FLT_CALLBACK_DATA 구조체의 Iopb 멤버를 통해 액세스되는 [FLT_IO_PARAMETER_BLOCK](https://msdn.microsoft.com/library/windows/hardware/ff544638) 구조체에 포함됩니다. 필터 관리자와 미니 필터 드라이버는 모두 [FLT_CALLBACK_DATA](https://msdn.microsoft.com/library/windows/hardware/ff544620) 구조를 사용하여 I/O 작업을 시작하고 처리합니다.

[FLT_PARAMETERS](https://msdn.microsoft.com/library/windows/hardware/ff544673) 결합에는 해당 작업에 사용되는 버퍼링 방법 (버퍼링 된 직접 I/O 또는 버퍼링되지 않은 직접 I/O도 없음)에 특정한 IRP 기반 작업에 대한 매개 변수 정의가 포함됩니다. 또한 IRP가 아닌 작업 (빠른 I/O 및 FsFilter 콜백 루틴)에 대한 매개 변수 정의가 포함되어 있습니다.

미니 필터 드라이버는 [FltDecodeParameters](https://msdn.microsoft.com/library/windows/hardware/ff541956) 를 호출하여 I/O 작업에 대한 MDL 주소, 버퍼 포인터, 버퍼 길이 및 원하는 액세스 매개 변수에 대한 포인터를 가져올 수 있습니다. 이렇게하면 minifilter 드라이버가 switch 문을 사용하여 여러 I/O 작업에서 이러한 매개 변수에 액세스하는 도우미 루틴에서 이러한 매개 변수의 위치를 찾을 수 없습니다.

사용자 버퍼와 관련된 I/O 작업을 처리 할 때 미니 필터 드라이버는 MDL이 사용 가능한 경우 항상 사용해야합니다. 그렇다면 미니 필터 드라이버는 [MmGetSystemAddressForMdlSafe](https://msdn.microsoft.com/library/windows/hardware/ff554559) 를 호출하여 MDL에 대한 시스템 주소를 가져와 시스템 주소를 사용하여 사용자 버퍼에 액세스해야합니다.

버퍼 주소 만 사용 할 수 있는 경우 minifilter 드라이버는 try / except 블록의 버퍼 액세스 시도를 항상 포함해야합니다. 미니 필터 드라이버가 동기화되지 않은 사후 콜백 루틴에서 버퍼에 액세스해야하거나 I/O 작업이 작업자 스레드에 게시되는 경우 minifilter 드라이버는 [FltLockUserBuffer](https://msdn.microsoft.com/library/windows/hardware/ff543371)를 호출하여 사용자 버퍼를 잠 가야합니다. 이 함수는 I/O 작업 유형에 따라 잠긴 버퍼에 적용 할 적절한 액세스 방법을 결정하고 잠긴 페이지를 가리키는 MDL을 만듭니다.

#### 사용자 버퍼 액세스를위한 필터 관리자 루틴

필터 관리자는 사전 작동 및 사후 콜백 루틴에서 사용자 버퍼에 액세스하기위한 다음과 같은 지원 루틴을 제공합니다.

[**FltDecodeParameters**](https://msdn.microsoft.com/library/windows/hardware/ff541956)

[**FltLockUserBuffer**](https://msdn.microsoft.com/library/windows/hardware/ff543371)



### 파일 이름 관리

필터 관리자는 레거시 필터 드라이버가 파일 이름을 검색하고 관리하는 데 필요한 많은 작업을 제거합니다. 이름이 요청되면 필터 관리자는 정규화 된 이름, 열린 이름 또는 짧은 이름과 같은 현재 작업에 적합한 형식으로 참조 카운트 된 구조의 이름을 제공합니다.

미니 필터 드라이버는 [FltGetDestinationFileNameInformation](https://msdn.microsoft.com/library/windows/hardware/ff543003)을 호출하여 이름이 바뀌거나 NTFS 하드 링크가 생성되는 파일이나 디렉터리의 전체 대상 경로 이름을 구성 할 수 있습니다. 이 이름은 정규화 된 파일 형식이나 열린 파일 형식으로 반환 될 수 있습니다.

필터 관리자는 또한 파일 이름 터널링으로 인해 무효화되는 정규화 된 파일 이름 정보를 검색하기위한 [FltGetTunneledName](https://msdn.microsoft.com/library/windows/hardware/ff543177) 루틴을 제공합니다.

성능을 향상시키기 위해 필터 관리자는 시스템의 모든 미니 필터 드라이버에서 공유되는 캐시 (가능하면)에 이름을 지정합니다. 미니 필터 드라이버는 캐시 또는 파일 시스템 중 하나 또는 둘 모두를 질의 할 수 있습니다.

네임 스페이스를 수정하는 미니 필터 드라이버는 이름을 생성하거나 정규화하기위한 상위 미니 필터 드라이버의 요청과 같은 이름 쿼리 작업을 가로 채기 위해 콜백 루틴을 등록하여 이름 공급자에 대한 필터 관리자의 지원을 이용할 수 있습니다.

#### 이름 관리를위한 필터 관리자 루틴

필터 관리자는 이름 관리를 위해 다음과 같은 지원 루틴을 제공합니다.

[**FltGetDestinationFileNameInformation**](https://msdn.microsoft.com/library/windows/hardware/ff543003)

[**FltGetFileNameInformation**](https://msdn.microsoft.com/library/windows/hardware/ff543032)

[**FltGetFileNameInformationUnsafe**](https://msdn.microsoft.com/library/windows/hardware/ff543035)

[**FltGetTunneledName**](https://msdn.microsoft.com/library/windows/hardware/ff543177)

[**FltParseFileNameInformation**](https://msdn.microsoft.com/library/windows/hardware/ff543417)

[**FltReleaseFileNameInformation**](https://msdn.microsoft.com/library/windows/hardware/ff544320)

#### 이름 관리를위한 Minifilter 드라이버 콜백 루틴

다음 콜백 루틴은 [FLT_REGISTRATION](https://msdn.microsoft.com/library/windows/hardware/ff544811) 구조체에 저장되어 네임 스페이스를 수정하는 미니 필터 드라이버에 대해 [FltRegisterFilter](https://msdn.microsoft.com/library/windows/hardware/ff544305)에 매개 변수로 전달됩니다.

| Callback Routine Name             | Callback Routine Type                                        |
| --------------------------------- | ------------------------------------------------------------ |
| *GenerateFileNameCallback*        | [**PFLT_GENERATE_FILE_NAME**](https://msdn.microsoft.com/library/windows/hardware/ff551087) |
| *NormalizeContextCleanupCallback* | [**PFLT_NORMALIZE_CONTEXT_CLEANUP**](https://msdn.microsoft.com/library/windows/hardware/ff551100) |
| *NormalizeNameComponentCallback*  | [**PFLT_NORMALIZE_NAME_COMPONENT**](https://msdn.microsoft.com/library/windows/hardware/ff551102) |



### 컨텍스트 관리

필터 관리자는 미니 필터 드라이버가 컨텍스트를 개체와 연결하여 I/O 작업 전반에서 상태를 보존 할 수있게합니다. 컨텍스트를 포함 할 수 있는 객체에는 볼륨, 인스턴스, 스트림 및 스트림 핸들이 포함됩니다.

타사 파일 시스템은 스트림 및 스트림 핸들 컨텍스트에서 제대로 작동하려면 [FSRTL_COMMON_FCB_HEADER](https://msdn.microsoft.com/library/windows/hardware/ff547334) 구조 대신 [FSRTL_ADVANCED_FCB_HEADER](https://msdn.microsoft.com/library/windows/hardware/ff547343) 구조체를 사용해야합니다.

컨텍스트는 비 페이징 풀에서 할당해야하는 볼륨 컨텍스트를 제외하고 페이징되거나 비 페이징 된 풀에서 할당 될 수 있습니다.

모든 미결 참조가 해제되면 컨텍스트가 자동으로 해제됩니다. minifilter 드라이버가 컨텍스트 정리 콜백 루틴을 정의하면 필터 관리자는 컨텍스트가 해제되기 전에 루틴을 호출합니다.

필터 매니저는 관련 객체가 삭제 될 때, 인스턴스가 분리 될 때, 그리고 minifilter 드라이버가 언로드 될 때 컨텍스트를 삭제합니다.

<span style="color:red">**미니 필터 드라이버가 볼륨 당 하나의 인스턴스 만 지원하는 경우 성능 향상을 위해 볼륨 컨텍스트가 아닌 인스턴스 컨텍스트를 사용하십시오.**</span> 스트림 또는 스트림 핸들 컨텍스트 내부에 minifilter 드라이버 인스턴스 컨텍스트에 대한 포인터를 저장하여 성능을 향상시킬 수도 있습니다.

컨텍스트는 페이징 파일이나 다음 작업 중에 지원되지 않습니다.

- create 요청에 대한 사전 처리
- close 요청에 대한 사후 처리
- IRP_MJ_NETWORK_QUERY_OPEN 요청 처리

컨텍스트를 사용하는 미니 필터 드라이버의 예는 CTX 샘플을 참조하십시오.

#### 컨텍스트 관리를위한 필터 관리자 루틴

필터 관리자는 컨텍스트 생성, 등록 및 설정을위한 다음과 같은 지원 루틴을 제공합니다.

[**FltAllocateContext**](https://msdn.microsoft.com/library/windows/hardware/ff541710)

[**FltRegisterFilter**](https://msdn.microsoft.com/library/windows/hardware/ff544305)

[**FltSetInstanceContext**](https://msdn.microsoft.com/library/windows/hardware/ff544521)

[**FltSetStreamContext**](https://msdn.microsoft.com/library/windows/hardware/ff544543)

[**FltSetStreamHandleContext**](https://msdn.microsoft.com/library/windows/hardware/ff544552)

[**FltSetVolumeContext**](https://msdn.microsoft.com/library/windows/hardware/ff544557)

컨텍스트 지원을 쿼리하는 데 다음과 같은 루틴이 제공됩니다.

[**FltSupportsStreamContexts**](https://msdn.microsoft.com/library/windows/hardware/ff544581)

[**FltSupportsStreamHandleContexts**](https://msdn.microsoft.com/library/windows/hardware/ff544586)

컨텍스트 가져 오기 및 참조를 위해 다음과 같은 루틴이 제공됩니다.

[**FltGetContexts**](https://msdn.microsoft.com/library/windows/hardware/ff542997)

[**FltGetInstanceContext**](https://msdn.microsoft.com/library/windows/hardware/ff543058)

[**FltGetStreamContext**](https://msdn.microsoft.com/library/windows/hardware/ff543144)

[**FltGetStreamHandleContext**](https://msdn.microsoft.com/library/windows/hardware/ff543155)

[**FltGetVolumeContext**](https://msdn.microsoft.com/library/windows/hardware/ff543189)

[**FltReferenceContext**](https://msdn.microsoft.com/library/windows/hardware/ff544291)

컨텍스트를 해제하고 삭제하는 데 다음과 같은 루틴이 제공됩니다.

[**FltDeleteContext**](https://msdn.microsoft.com/library/windows/hardware/ff541960)

[**FltDeleteInstanceContext**](https://msdn.microsoft.com/library/windows/hardware/ff541982)

[**FltDeleteStreamContext**](https://msdn.microsoft.com/library/windows/hardware/ff541997)

[**FltDeleteStreamHandleContext**](https://msdn.microsoft.com/library/windows/hardware/ff542016)

[**FltDeleteVolumeContext**](https://msdn.microsoft.com/library/windows/hardware/ff542030)

[**FltReleaseContext**](https://msdn.microsoft.com/library/windows/hardware/ff544314)

[**FltReleaseContexts**](https://msdn.microsoft.com/library/windows/hardware/ff544317)

#### 컨텍스트 관리를위한 Minifilter 드라이버 콜백 루틴

다음 콜백 루틴은 [FLT_REGISTRATION](https://msdn.microsoft.com/library/windows/hardware/ff544811) 구조체에 저장되어 컨텍스트를 관리하는 미니 필터 드라이버의 [FltRegisterFilter](https://msdn.microsoft.com/library/windows/hardware/ff544305)에 매개 변수로 전달됩니다.

| Callback Routine Name     | Callback Routine Type                                        |
| ------------------------- | ------------------------------------------------------------ |
| *ContextAllocateCallback* | [**PFLT_CONTEXT_ALLOCATE_CALLBACK**](https://msdn.microsoft.com/library/windows/hardware/ff551075) |
| *ContextCleanupCallback*  | [**PFLT_CONTEXT_CLEANUP_CALLBACK**](https://msdn.microsoft.com/library/windows/hardware/ff551078) |
| *ContextFreeCallback*     | [**PFLT_CONTEXT_FREE_CALLBACK**](https://msdn.microsoft.com/library/windows/hardware/ff551082) |



### 미니 필터 드라이버가 생성 한 I/O 요청

미니 필터 드라이버는 현재 볼륨이나 다른 볼륨의 미니 필터 드라이버 인스턴스 중 하나에서 IRP 기반 I/O 요청을 생성하여 보낼 수 있습니다. 생성 된 I/O는 지정된 인스턴스 아래에 첨부 된 미니 필터 드라이버 인스턴스 및 레거시 필터 드라이버 및 파일 시스템에서만 볼 수 있습니다. 레거시 필터 드라이버 모델에서 재귀 적 I/O와 관련된 많은 문제를 해결합니다. 레거시 필터 드라이버에서 생성 된 I/O 요청은 최상위 드라이버부터 전체 파일 시스템 스택을 통과해야합니다.

필터 관리자는 모든 미해결 I/O 작업이 완료 될 때까지 minifilter 드라이버를 언로드하지 않습니다.

#### Minifilter 드라이버가 생성 한 I/O 요청에 대한 필터 관리자 루틴

필터 관리자는 파일을 작성, 열기, 읽기 및 쓰기위한 지원 루틴을 제공합니다.

[**FltClose**](https://msdn.microsoft.com/library/windows/hardware/ff541863)

[**FltCreateFile**](https://msdn.microsoft.com/library/windows/hardware/ff541935)

[**FltCreateFileEx**](https://msdn.microsoft.com/library/windows/hardware/ff541937)

[**FltReadFile**](https://msdn.microsoft.com/library/windows/hardware/ff544286)

[**FltWriteFile**](https://msdn.microsoft.com/library/windows/hardware/ff544610)

다음 지원 루틴은 재분석 지점 설정 및 제거를 위해 제공됩니다.

[**FltTagFile**](https://msdn.microsoft.com/library/windows/hardware/ff544589)

[**FltUntagFile**](https://msdn.microsoft.com/library/windows/hardware/ff544608)

I/O 요청 생성을 위해 다음과 같은 지원 루틴이 제공됩니다.

[*FltAllocateCallbackData*](https://msdn.microsoft.com/library/windows/hardware/ff541703)

[**FltFreeCallbackData**](https://msdn.microsoft.com/library/windows/hardware/ff542949)

[**FltPerformAsynchronousIo**](https://msdn.microsoft.com/library/windows/hardware/ff543420)

[*FltPerformSynchronousIo*](https://msdn.microsoft.com/library/windows/hardware/ff543421)

[**FltReuseCallbackData**](https://msdn.microsoft.com/library/windows/hardware/ff544358)

다음 지원 루틴은 파일 열기 요청을 취소하고 I/O 요청을 다시 발행하기 위해 제공됩니다.

[**FltCancelFileOpen**](https://msdn.microsoft.com/library/windows/hardware/ff541784)

[**FltReissueSynchronousIo**](https://msdn.microsoft.com/library/windows/hardware/ff544311)

필터 관리자는 다음과 같은 범용 루틴도 제공합니다.

[**FltDeviceIoControlFile**](https://msdn.microsoft.com/library/windows/hardware/ff542046)

[**FltFlushBuffers**](https://msdn.microsoft.com/library/windows/hardware/ff542099)

[**FltFsControlFile**](https://msdn.microsoft.com/library/windows/hardware/ff542988)

[**FltQueryInformationFile**](https://msdn.microsoft.com/library/windows/hardware/ff543439)

[**FltQuerySecurityObject**](https://msdn.microsoft.com/library/windows/hardware/ff543441)

[**FltQueryVolumeInformationFile**](https://msdn.microsoft.com/library/windows/hardware/ff543446)

[**FltSetInformationFile**](https://msdn.microsoft.com/library/windows/hardware/ff544516)

[**FltSetSecurityObject**](https://msdn.microsoft.com/library/windows/hardware/ff544538)



### 사용자 모드와 커널 모드 간의 통신

필터 관리자는 통신 포트를 통해 사용자 모드와 커널 모드 간의 통신을 지원합니다. minifilter 드라이버는 통신 포트 개체에 적용 할 보안 설명자를 지정하여 포트의 보안을 제어합니다. 통신 포트를 통한 통신은 버퍼링되지 않으므로보다 빠르고 효율적입니다. 사용자 모드 응용 프로그램 또는 서비스는 양방향 통신을 위해 미니 필터 드라이버의 메시지에 응답 할 수 있습니다.

미니 필터 드라이버가 통신 서버 포트를 만들면 암시 적으로 포트에서 들어오는 연결을 수신 대기하기 시작합니다. 사용자 모드 호출자가 포트에 연결을 시도하면 필터 관리자는 새로 만든 연결에 대한 핸들을 사용하여 minifilter 드라이버의 [ConnectNotifyCallback](https://msdn.microsoft.com/library/windows/hardware/ff541931) 루틴을 호출합니다. 필터 관리자가 제어를 다시 얻으면 사용자 모드 호출자에게 사용자 모드 호출자의 끝점을 연결로 나타내는 별도의 파일 핸들을 전달합니다. 이 핸들을 사용하여 I/O 완료 포트를 리스너 포트와 연관시킬 수 있습니다.

사용자 모드 호출자가 포트의 보안 설명자가 지정한대로 충분한 액세스 권한을 가진 경우에만 연결이 허용됩니다. 포트에 대한 각 연결은 자체 메시지 대기열과 개인용 끝점을 갖습니다.

엔드 포인트 (커널 또는 사용자)를 닫으면 해당 연결이 종료됩니다. 사용자 모드 호출자가 끝점에 대한 핸들을 닫으면 필터 관리자는 minifilter 드라이버의 [DisconnectNotifyCallback](https://msdn.microsoft.com/library/windows/hardware/ff541931) 루틴을 호출하여 minifilter 드라이버가 연결 핸들을 닫을 수 있도록합니다.

통신 서버 포트를 닫으면 새 연결은 차단되지만 기존 연결은 종료되지 않습니다. 필터 관리자는 미니 필터 드라이버가 언로드 될 때 기존 연결을 종료합니다.

#### 사용자 모드와 커널 모드 간의 통신을위한 필터 관리자 루틴

필터 관리자는 커널 모드 미니 필터 드라이버가 사용자 모드 응용 프로그램과 통신 할 수 있도록 다음과 같은 지원 루틴을 제공합니다.

[**FltCloseClientPort**](https://msdn.microsoft.com/library/windows/hardware/ff541867)

[**FltCloseCommunicationPort**](https://msdn.microsoft.com/library/windows/hardware/ff541871)

[**FltCreateCommunicationPort**](https://msdn.microsoft.com/library/windows/hardware/ff541931)

[**FltSendMessage**](https://msdn.microsoft.com/library/windows/hardware/ff544378)

사용자 모드 응용 프로그램이 미니 필터 드라이버와 통신 할 수 있도록 다음과 같은 지원 루틴이 제공됩니다.

[**FilterConnectCommunicationPort**](https://msdn.microsoft.com/library/windows/hardware/ff540460)

[**FilterGetMessage**](https://msdn.microsoft.com/library/windows/hardware/ff540506)

[**FilterReplyMessage**](https://msdn.microsoft.com/library/windows/hardware/ff541508)

[**FilterSendMessage**](https://msdn.microsoft.com/library/windows/hardware/ff541513)

#### 사용자 모드와 커널 모드 간의 통신을위한 Minifilter 드라이버 콜백 루틴

다음 Minifilter 드라이버 콜백 루틴은 [FltCreateCommunicationPort](https://msdn.microsoft.com/library/windows/hardware/ff541931)에 매개 변수로 전달됩니다.



### 사용자 모드 라이브러리

필터 관리자 사용자 모드 인터페이스는 필터 드라이버가 포함 된 제품에 공통 기능을 제공합니다. **사용자 모드 라이브러리는 Fltlib.dll**입니다. 응용 프로그램에는 FltUser.h 및 FltUserStructures.h 헤더 파일과 FltLib.lib 링크가 있습니다.

이러한 사용자 모드 인터페이스는 사용자 모드 서비스 또는 제어 프로그램과 필터 드라이버 간의 최소 필터 드라이버 및 통신을 전반적으로 제어 할 수있게합니다. 또한 사용자 모드 인터페이스는 필터, 볼륨 및 인스턴스의 열거를 허용하는 관리 도구에 대한 인터페이스를 제공합니다.

미니 필터의 경우 사용자 모드 통신 API에는 관리자 권한이 필요하지 않습니다. 대신 미니 필터는 포트에 정의 된 ACL을 사용하여 필요한 권한을 정의합니다.

#### 필터 관리자 사용자 모드 라이브러리 루틴

필터 관리자는 미니 모드 드라이버로드 및 언로드에 사용할 사용자 모드 응용 프로그램에 대한 다음 지원 루틴을 제공합니다.

[**FilterLoad**](https://msdn.microsoft.com/library/windows/hardware/ff541504)

[**FilterUnload**](https://msdn.microsoft.com/library/windows/hardware/ff541516)

미니 파일 드라이버 및 인스턴스 핸들을 만들고 닫는 데 다음과 같은 지원 루틴이 제공됩니다.

[**FilterClose**](https://msdn.microsoft.com/library/windows/hardware/ff540453)

[**FilterCreate**](https://msdn.microsoft.com/library/windows/hardware/ff540467)

[**FilterInstanceClose**](https://msdn.microsoft.com/library/windows/hardware/ff540524)

[**FilterInstanceCreate**](https://msdn.microsoft.com/library/windows/hardware/ff540528)

다음과 같은 지원 루틴이 미니 필터 드라이버 인스턴스 연결 및 분리에 제공됩니다.

[**FilterAttach**](https://msdn.microsoft.com/library/windows/hardware/ff540442)

[**FilterAttachAtAltitude**](https://msdn.microsoft.com/library/windows/hardware/ff540448)

[**FilterDetach**](https://msdn.microsoft.com/library/windows/hardware/ff540475)

필터, 볼륨 및 인스턴스를 열거하기 위해 다음과 같은 지원 루틴이 제공됩니다.

[**FilterFindFirst**](https://msdn.microsoft.com/library/windows/hardware/ff540485)

[**FilterFindNext**](https://msdn.microsoft.com/library/windows/hardware/ff540488)

[**FilterInstanceFindFirst**](https://msdn.microsoft.com/library/windows/hardware/ff540541)

[**FilterInstanceFindNext**](https://msdn.microsoft.com/library/windows/hardware/ff541493)

[**FilterVolumeFindFirst**](https://msdn.microsoft.com/library/windows/hardware/ff541525)

[**FilterVolumeFindNext**](https://msdn.microsoft.com/library/windows/hardware/ff541530)

[**FilterVolumeInstanceFindFirst**](https://msdn.microsoft.com/library/windows/hardware/ff541541)

[**FilterVolumeInstanceFindNext**](https://msdn.microsoft.com/library/windows/hardware/ff541551)

정보를 조회하기 위해 다음과 같은 지원 루틴이 제공됩니다.

[**FilterGetDosName**](https://msdn.microsoft.com/library/windows/hardware/ff540492)

[**FilterGetInformation**](https://msdn.microsoft.com/library/windows/hardware/ff540500)

[**FilterInstanceGetInformation**](https://msdn.microsoft.com/library/windows/hardware/ff541499)

다음 지원 루틴은 사용자 조작에 의해 시작된 통신을 위해 제공됩니다.

[**FilterConnectCommunicationPort**](https://msdn.microsoft.com/library/windows/hardware/ff540460)

[**FilterSendMessage**](https://msdn.microsoft.com/library/windows/hardware/ff541513)

다음과 같은 지원 루틴은 미니 필터 드라이버에 의해 시작된 통신에 응답하기 위해 제공됩니다.

[**FilterGetMessage**](https://msdn.microsoft.com/library/windows/hardware/ff540506)

[**FilterReplyMessage**](https://msdn.microsoft.com/library/windows/hardware/ff541508)



### 필터 관리자 작업 제어

Windows Vista 이전 버전의 Windows에서 필터 관리자의 작동은 다음 키에 저장된 REG_DWORD AttachWhenLoaded 레지스트리 값에 의해 제어됩니다.

```c
HKLM\System\CurrentControlSet\Services\FltMgr
```

AttachWhenLoaded가 0으로 설정되면 필터 관리자는 미니 필터 드라이버가 필터 관리자에 등록 할 때까지 모든 볼륨에 연결하지 않습니다. AttachWhenLoaded를 1로 설정하면 필터 관리자가 부팅시 모든 볼륨에 연결됩니다.

AttachWhenLoaded의 기본값은 Windows XP 서비스 팩 2 (SP2) 이상에서 0입니다.

AttachWhenLoaded의 기본값은 Windows Server 2003 SP1 (서비스 팩 1) 이상 버전에서 1입니다.

AttachWhenLoaded 레지스트리 값은 Windows Vista에는없고 이전 버전의 Windows에만 적용됩니다.

Windows Vista 이전에 Windows에 최소 필터 드라이버가 설치되어 있으면이 레지스트리 값이 현재 1로 설정되어 있지 않으면 소프트웨어 설치 관리자가 AttachWhenLoaded를 1로 설정해야합니다. AttachWhenLoaded의 이전 값이 0이면 설치 후 설치 프로그램이 시스템을 재부팅해야합니다 minifilter 드라이버의.



### 개발 및 테스트 도구

이 섹션에서 설명하는 필터 관리자 도구는 Windows Server 2003 SP1 용 IFS Kit 및 Windows Vista 용 Windows Driver Kit (WDK)에서 제공됩니다.

Minifilter 드라이버 개발자는 드라이버 별 규칙이있는 PREfast와 같은 범용 커널 모드 개발 및 테스트 도구를 사용하는 것이 좋습니다.

#### Fltmc.exe 제어 프로그램

Fltmc.exe 제어 프로그램은 일반적인 미니 필터 드라이버 관리 작업을위한 명령 줄 유틸리티입니다. 개발자는 Fltmc.exe를 사용하여 미니 필터 드라이버를 로드 및 언로드하고 볼륨에 미니 필터 드라이버를 연결하거나 볼륨에서 분리하고 미니 필터 드라이버, 인스턴스 및 볼륨을 열거 할 수 있습니다.

#### !fltkd Debugger Extension

! fltkd 디버거 확장은 [Windows 디버깅](https://msdn.microsoft.com/library/windows/hardware/ff551063) 도구에서 제공됩니다. 일반적으로 사용되는 명령은 다음과 같습니다.

| Command       | Description                                                  |
| ------------- | ------------------------------------------------------------ |
| **!cbd**      | ! irp와 같은 필터 관리자                                     |
| **!filter**   | 지정한 필터에 대한 자세한 정보를 나열합니다.                 |
| **!filters**  | 첨부 된 모든 미니 필터 드라이버를 나열합니다.                |
| **!frames**   | 모든 필터 관리자 프레임 및 연결된 미니 필터 드라이버를 나열합니다. |
| **!instance** | 지정된 인스턴스에 대한 자세한 정보를 나열합니다.             |
| **!volume**   | 지정된 볼륨에 대한 자세한 정보를 나열합니다.                 |
| **!volumes**  | 모든 볼륨 및 연결된 미니 필터 드라이버 인스턴스를 나열합니다. |

추가 디버깅 도움말을 보려면 일반적인 오류를 catch하는 수많은 ASSERT 문을 포함하는 Fltmgr.sys의 디버그 버전으로 minifilter 드라이버를 테스트하십시오.

#### 필터 검증기

Filter Verifier는 Driver Verifier의 [I/O Verification](https://msdn.microsoft.com/library/windows/hardware/ff548045) 옵션으로 필터 관리자 기능의 미니 필터 드라이버 사용을 확인합니다. 필터 확인 프로그램은 필터 관리자와 함께 설치됩니다. 개발자는 [Driver Verifier](https://msdn.microsoft.com/library/windows/hardware/ff545448) 및 Filter Verifier가 활성화 된 미니 필터 드라이버를 항상 개발해야합니다.

Filter Verifier를 사용하려면 minifilter 드라이버의 이름을 지정하고 Driver Verifier (Verifier.exe)에서 I / O Verification 옵션을 활성화하십시오. Minifilter 드라이버가 필터 관리자에 등록하면 확인이 시작됩니다.

필터 확인 프로그램은 미니 필터 드라이버에서 다음 사용법의 유효성을 검사합니다.

- 매개 변수 및 호출 컨텍스트의 올바른 사용
- 사전 및 사후 콜백 루틴의 올바른 반환 값
- 콜백 데이터의 매개 변수에 일관되고 일관된 변경

필터 검증기는 다음 필터 관리자 객체를 추적합니다.

- Contexts
- Callback Data structures
- Queued Work Items
- NameInformation structures
- File Objects
- Filter Objects
- Instance Objects
- Volume Objects



### 레거시 필터 드라이버 포팅 지침

개발자는 레거시 필터 드라이버를 필터 관리자 모델로 이식하여 필터 드라이버의 기능을 향상시키고 시스템 안정성을 향상시키는 것이 좋습니다. 숙련 된 개발자는 레거시 필터 드라이버를 미니 필터 드라이버로 이식하는 것이 상대적으로 쉽다는 것을 발견해야합니다. Microsoft의 필터 드라이버 개발자는 다음 방법을 사용하는 것이 좋습니다.

- 레거시 필터 드라이버와 이식 된 미니 필터 드라이버 간의 동작을 확인하기위한 신뢰할 수있는 회귀 테스트 슈트부터 시작하십시오.
- 미니 필터 드라이버 셸을 만들고 레거시 필터 드라이버에서 미니 필터 드라이버로 기능을 체계적으로 이동하십시오. 예를 들어, 첨부 파일을 작동시킨 다음 한 번에 하나의 작업을 포팅하고 각 작업 후에 테스트하십시오.
- 마지막으로 사용자 모드 / 커널 모드 통신을 변경하여 기존 도구를 사용하여 minifilter 드라이버를 테스트 할 수 있습니다.
- PREfast로 컴파일하고 Driver Verifier가 활성화 된 Filter Verifier I / O 확인 옵션으로 테스트하십시오.

포팅 프로세스 중 필터 관리자 기능을 최대한 활용하려면 모든 레거시 필터 드라이버 코드를 검토해야합니다. 특히 다음 사항에 유의하십시오.

- IRP 기반 I / O 및 빠른 I / O 작업은 적절한 경우 동일한 작업을 통해 이루어질 수 있으므로 코드 중복을 줄일 수 있습니다.
- 작업을 등록 할 때 미니 필터 드라이버는 명시 적으로 모든 페이징 I / O 및 캐시 된 I / O를 무시하도록 선택할 수 있으므로 코드를 확인할 필요가 없습니다.
- 인스턴스 알림은 연결 / 분리 논리를 크게 단순화합니다.
- 미니 필터 드라이버가 처리해야하는 작업에만 등록하십시오. 당신은 다른 모든 것을 무시할 수 있습니다.
- 필터 관리자 컨텍스트 및 이름 관리 지원을 활용하십시오.
- 비 재귀 적 I / O를 발행하는 필터 관리자 지원을 활용하십시오.
- 레거시 필터 드라이버와 달리 미니 필터 드라이버는 로컬 변수를 사용하여 사전 작업 처리에서 사후 처리까지 컨텍스트를 유지할 수 없습니다. lookaside 목록을 할당하여 작업 상태를 저장하는 것이 좋습니다.
- 이름이나 문맥이 끝나면 참조를 해제하십시오.
- 사용자 모드의 완료 포트는 대기열을 만드는 강력한 기술을 추가합니다. 이름이 지정된 단일 포트에 대해 단일 연결 만 필요할 것입니다.

다음 표에는 레거시 필터 드라이버의 일반적인 작업과이 필터가 필터 관리자 모델에 매핑되는 방법이 나열되어 있습니다.

| Legacy filter driver model                              | Filter manager model                                         |
| ------------------------------------------------------- | ------------------------------------------------------------ |
| 완료 루틴이없는 통과 (pass-through) 작업                | 미니 파일러 드라이버가이 유형의 I/O 작업에 대해 작동하지 않는 경우이 작업에 대한 사전 작동 또는 사후 콜백 루틴을 등록하지 마십시오.<br/><br/>그렇지 않으면 이 작업에 대해 등록 된 사전 콜백 루틴에서 FLT_PREOP_SUCCESS_NO_CALLBACK을 반환합니다.<br/><br/>See [Returning FLT_PREOP_SUCCESS_NO_CALLBACK](https://docs.microsoft.com/ko-kr/windows-hardware/drivers/ifs/returning-flt-preop-success-no-callback). |
| 완료 루틴을 통한 통과 작업                              | 사전 조작 콜백 루틴에서 FLT_PREOP_SUCCESS_WITH_CALLBACK을 리턴하십시오.<br/><br/>See [Returning FLT_PREOP_SUCCESS_WITH_CALLBACK](https://docs.microsoft.com/ko-kr/windows-hardware/drivers/ifs/returning-flt-preop-success-with-callback). |
| 사전 작업 콜백 루틴에서 작업 보류                       | 필요에 따라 [FltLockUserBuffer](https://msdn.microsoft.com/library/windows/hardware/ff543371)를 호출하여 작업자 스레드에서 액세스 할 수 있도록 모든 사용자 버퍼가 올바르게 잠겨 있는지 확인하십시오.<br/><br/>[FltAllocateDeferredIoWorkItem](https://msdn.microsoft.com/library/windows/hardware/ff541720) 및 [FltQueueDeferredIoWorkItem](https://msdn.microsoft.com/library/windows/hardware/ff543449)과 같은 지원 루틴을 호출하여 작업 스레드에 작업을 대기열에 둡니다.<br/><br/>수술 전 콜백 루틴에서 FLT_PREOP_PENDING을 반환합니다.<br/><br/>I / O 작업을 필터 관리자로 반환 할 준비가되면 [FltCompletePendedPreOperation](https://msdn.microsoft.com/library/windows/hardware/ff541913)을 호출하십시오.<br/><br/>사전 콜백 루틴에서 I / O 작업 보류를 참조하십시오. |
| 사후 콜백 루틴에서 작업 보류                            | Preoperation 콜백 루틴에서 [FltLockUserBuffer](https://msdn.microsoft.com/library/windows/hardware/ff543371)를 호출하여 사용자 버퍼가 제대로 잠겨 작업자 스레드에서 액세스 할 수 있도록합니다.<br/><br/>[FltAllocateGenericWorkItem](https://msdn.microsoft.com/library/windows/hardware/ff541749) 및 [FltQueueGenericWorkItem](https://msdn.microsoft.com/library/windows/hardware/ff543452)과 같은 지원 루틴을 호출하여 작업 스레드에 작업 대기열을 지정하십시오.<br/><br/>사후 콜백 루틴에서 FLT_POSTOP_MORE_PROCESSING_REQUIRED를 반환합니다.<br/><br/>I / O 작업을 필터 관리자로 반환 할 준비가되면 [FltCompletePendedPostOperation](https://msdn.microsoft.com/library/windows/hardware/ff541897)을 호출하십시오.<br/><br/>[사후 콜백 루틴에서 I / O 작업 보류를 참조](https://docs.microsoft.com/ko-kr/windows-hardware/drivers/ifs/pending-an-i-o-operation-in-a-postoperation-callback-routine)하십시오. |
| 작업 동기화                                             | 수술 전 콜백 루틴에서 FLT_PREOP_SYNCHRONIZE를 반환합니다.<br/><br/>See [Returning FLT_PREOP_SYNCHRONIZE](https://docs.microsoft.com/ko-kr/windows-hardware/drivers/ifs/returning-flt-preop-synchronize). |
| 사전 작업 콜백 루틴에서 작업 완료                       | 작업의 [FLT_CALLBACK_DATA](https://msdn.microsoft.com/library/windows/hardware/ff544620) 구조체의 IoStatus 멤버에서 최종 작업 상태 및 정보를 설정합니다.<br/><br/>수술 전 콜백 루틴에서 FLT_PREOP_COMPLETE을 반환합니다.<br/><br/>See [Completing an I/O Operation in a Preoperation Callback Routine](https://docs.microsoft.com/ko-kr/windows-hardware/drivers/ifs/completing-an-i-o-operation-in-a-preoperation-callback-routine). |
| 사전 작업 콜백 루틴에서 보류 된 후 작업 완료            | 작업의 [FLT_CALLBACK_DATA ](https://msdn.microsoft.com/library/windows/hardware/ff544620)구조체의 IoStatus 멤버에서 최종 작업 상태 및 정보를 설정합니다.<br/><br/>I / O 작업을 처리하는 작업자 스레드에서 [FltCompletePendedPreOperation](https://msdn.microsoft.com/library/windows/hardware/ff541913)을 호출하고 FLT_PREOP_COMPLETE를 CallbackStatus 매개 변수로 전달합니다.<br/><br/>See [Completing an I/O Operation in a Preoperation Callback Routine](https://docs.microsoft.com/ko-kr/windows-hardware/drivers/ifs/completing-an-i-o-operation-in-a-preoperation-callback-routine). |
| 완료 루틴에서 모든 완료 작업 수행                       | 후 작업 콜백 루틴에서 FLT_POSTOP_FINISHED_PROCESSING을 반환합니다.<br/><br/>See [Writing Postoperation Callback Routines](https://docs.microsoft.com/ko-kr/windows-hardware/drivers/ifs/writing-postoperation-callback-routines). |
| 안전한 IRQL에서 완성 작업 수행                          | 사후 콜백 루틴에서 [FltDoCompletionProcessingWhenSafe](https://msdn.microsoft.com/library/windows/hardware/ff542047)를 호출하십시오.<br/><br/>See [Ensuring that Completion Processing is Performed at Safe IRQL](https://docs.microsoft.com/ko-kr/windows-hardware/drivers/ifs/ensuring-that-completion-processing-is-performed-at-safe-irql). |
| 완료 루틴에서 이벤트 신호                               | 이 작업의 전처리 콜백 루틴에서 FLT_PREOP_SYNCHRONIZE를 반환합니다.<br/><br/>필터 관리자는 IRQL &lt;= APC_LEVEL에서 사전 작업 콜백 루틴과 동일한 스레드 컨텍스트에서 사후 콜백 루틴을 호출합니다.<br/><br/>See [Returning FLT_PREOP_SYNCHRONIZE](https://docs.microsoft.com/ko-kr/windows-hardware/drivers/ifs/returning-flt-preop-synchronize). |
| 성공적인 작성 조작 실패                                 | 만들기 작업에 대한 사후 콜백 루틴에서 [FltCancelFileOpen](https://msdn.microsoft.com/library/windows/hardware/ff541784)을 호출하십시오.<br/><br/>조작에 대한 [FLT_CALLBACK_DATA](https://msdn.microsoft.com/library/windows/hardware/ff544620) 구조의 IoStatus 구성원에 적절한 오류 NTSTATUS 값을 설정하십시오.<br/><br/>FLT_POSTOP_FINISHED_PROCESSING을 반환합니다.<br/><br/>See [Failing an I/O Operation in a Postoperation Callback Routine](https://docs.microsoft.com/ko-kr/windows-hardware/drivers/ifs/failing-an-i-o-operation-in-a-postoperation-callback-routine). |
| I / O 작업을위한 고속 I / O 경로를 통한 I / O 허용 안함 | 수술 전 콜백 루틴에서 FLT_STATUS_DISALLOW_FAST_IO를 반환합니다.<br/><br/>See [Disallowing a Fast I/O Operation in a Preoperation Callback Routine](https://docs.microsoft.com/ko-kr/windows-hardware/drivers/ifs/disallowing-a-fast-i-o-operation-in-a-preoperation-callback-routine). |
| I / O 작업의 매개 변수 수정                             | 조작에 대한 [FLT_CALLBACK_DATA](https://msdn.microsoft.com/library/windows/hardware/ff544620) 구조의 Iopb 구성원에서 수정 된 매개 변수 값을 설정하십시오.<br/><br/>FLT_CALLBACK_DATA 구조체의 IoStatus 멤버의 내용을 수정 한 경우를 제외하고는 [FltSetCallbackDataDirty](https://msdn.microsoft.com/library/windows/hardware/ff544383)를 호출하여 FLT_CALLBACK_DATA 구조체를 dirty로 표시하십시오.<br/><br/>See [Modifying the Parameters for an I/O Operation](https://docs.microsoft.com/ko-kr/windows-hardware/drivers/ifs/modifying-the-parameters-for-an-i-o-operation). |
| 작업을위한 사용자 버퍼 잠그기                           | [I/O 작업을위한 사용자 버퍼 액세스](https://docs.microsoft.com/ko-kr/windows-hardware/drivers/ifs/accessing-the-user-buffers-for-an-i-o-operation)에 설명 된 기술 및 지침을 사용하십시오. |





## <span style="color:blue">미니 필터 드라이버 설치</span>

Microsoft Windows XP 이상 운영 체제의 경우 INF 파일과 설치 응용 프로그램을 사용하여 minifilter 드라이버를 설치해야합니다. (Windows 2000 및 이전 운영 체제에서 minifilter 드라이버는 Service Control Manager에 의해 일반적으로 설치되었습니다.)

앞으로 minifilter 드라이버에 대한 Windows Hardware Certification Kit 요구 사항을 충족시키기 위해서는 INF 기반 설치가 필요합니다. 'INF 기반 설치'는 파일을 복사하고 레지스트리에 정보를 저장하기 위해 INF 파일을 사용해야한다는 것을 의미합니다. INF 파일 만 사용하여 전체 제품을 설치할 필요가 없으며 드라이버에 '[마우스 오른쪽 버튼 설치 옵션](https://docs.microsoft.com/ko-kr/windows-hardware/drivers/ifs/using-an-inf-file-to-install-a-file-system-filter-driver)'을 제공 할 필요가 없습니다.

 이 섹션에는 다음 내용이 포함됩니다.

[Minifilter 드라이버 용 INF 파일 만들기](https://docs.microsoft.com/ko-kr/windows-hardware/drivers/ifs/creating-an-inf-file-for-a-minifilter-driver)

[Minifilter 드라이버에 대한 주문 그룹 및 고도 로드](https://docs.microsoft.com/ko-kr/windows-hardware/drivers/ifs/load-order-groups-and-altitudes-for-minifilter-drivers)

[할당 된 고도](https://docs.microsoft.com/ko-kr/windows-hardware/drivers/ifs/allocated-altitudes)

[미니 필터 고도 요청](https://docs.microsoft.com/ko-kr/windows-hardware/drivers/ifs/minifilter-altitude-request)

[재분석 포인트 태그 요청](https://docs.microsoft.com/ko-kr/windows-hardware/drivers/ifs/reparse-point-tag-request)



### Minifilter 드라이버 용 INF 파일 만들기

파일 시스템 미니 필터 드라이버 용 INF 파일은 일반적으로 다음 절을 포함합니다.

Version (필수)

DestinationDirs (선택적이지만 권장 됨)

DefaultInstall (필수)

DefaultInstall.Services (필수)

ServiceInstall (필수)

AddRegistry (필수)

DefaultUninstall (선택)

DefaultUninstall.Services (선택)

Strings (필수)

**참고** x64 기반 Windows Vista 시스템부터 파일 시스템 드라이버 (파일 시스템, 레거시 필터 및 미니 필터 드라이버)와 같은 비 PnP (플러그 앤 플레이) 드라이버를 포함한 모든 커널 모드 구성 요소에 서명해야합니다. 로드하고 실행하십시오. 이 시나리오의 경우 다음 목록에는 파일 시스템 드라이버와 관련된 정보가 포함되어 있습니다.

- 파일 시스템 드라이버를 포함한 비 PnP 드라이버의 INF 파일은 [Manufacturer] 또는 [Models] 섹션을 포함 할 필요가 없습니다.
- WDK 설치 디렉토리의 \\bin\\SelfSign 디렉토리에있는 [SignTool](https://msdn.microsoft.com/library/windows/hardware/ff551778) 명령 줄 도구를 사용하여 드라이버 SYS 실행 파일을 직접 '임베드 (embed)'할 수 있습니다. 성능상의 이유로 부팅 시작 드라이버에는 포함 된 서명이 포함되어야합니다.
- INF 파일이 제공되면 [Inf2cat](https://go.microsoft.com/fwlink/p/?linkid=79443) 명령 줄 도구를 사용하여 드라이버 패키지의 카탈로그 (.cat) 파일을 만들 수 있습니다. 카탈로그 파일 만 [WHQL](https://go.microsoft.com/fwlink/p/?linkid=8705) 로고 서명을받을 수 있습니다.
- 관리자 권한을 사용하면 Windows Vista부터 x64 기반 시스템에 서명되지 않은 드라이버를 계속 설치할 수 있습니다. 그러나 드라이버는 서명되지 않아로드하지 못하고 실행됩니다.
- 드라이버 서명에 대한 일반적인 정보는,  [Driver Signing](https://msdn.microsoft.com/library/windows/hardware/ff544865) 을 보세요.
- 운전 서명 절차에 대한 자세한 정보는,  [Kernel-Mode Code Signing Walkthrough](https://go.microsoft.com/fwlink/p/?linkid=79445) 를 보세요.
- 사용자 정의 커널 모드 개발 도구를 포함한 모든 커널 모드 구성 요소에 서명해야합니다. 자세한 내용은, [Signing Drivers during Development and Test (Windows Vista and Later)](https://msdn.microsoft.com/library/windows/hardware/ff552275) 를 보세요.



#### Version Section (필수)

[버전](https://msdn.microsoft.com/library/windows/hardware/ff547502) 섹션은 다음 코드 예제와 같이 미니 필터 드라이버 유형에 의해 결정되는 클래스와 GUID를 지정합니다.

```c
[Version]
Signature   = "$WINDOWS NT$"
Class       = "ActivityMonitor"
ClassGuid   = {b86dff51-a31e-4bac-b3cf-e8cfe75c9fc2}
Provider    = %Msft%
DriverVer   = 10/09/2001,1.0.0.0
CatalogFile =
```

다음 표에서는 파일 시스템 미니 필터 드라이버가 [버전](https://msdn.microsoft.com/library/windows/hardware/ff547502)  섹션에 지정해야하는 값을 보여줍니다.

| Entry           | Value                                                        |
| --------------- | ------------------------------------------------------------ |
| **Signature**   | "$WINDOWS NT$"                                               |
| **Class**       | See [File System Filter Driver Classes and Class GUIDs](https://docs.microsoft.com/ko-kr/windows-hardware/drivers/ifs/file-system-filter-driver-classes-and-class-guids). |
| **ClassGuid**   | See [File System Filter Driver Classes and Class GUIDs](https://docs.microsoft.com/ko-kr/windows-hardware/drivers/ifs/file-system-filter-driver-classes-and-class-guids). |
| **Provider**    | 자신의 INF 파일에서 Microsoft가 아닌 다른 공급자를 지정해야합니다. |
| **DriverVer**   | See [**INF DriverVer directive**](https://msdn.microsoft.com/library/windows/hardware/ff547394). |
| **CatalogFile** | 서명 된 바이러스 백신 미니 필터 드라이버의 경우이 항목에는 WHQL 제공 카탈로그 파일의 이름이 포함됩니다. 다른 모든 미니 필터 드라이버는이 항목을 비워 두어야합니다. 자세한 정보는 [INF 버전 섹션](https://msdn.microsoft.com/library/windows/hardware/ff547502)의 CatalogFile 항목에 대한 설명을 참조하십시오. |



#### DestinationDirs Section (선택적이지만 권장 됨)

[DestinationDirs](https://msdn.microsoft.com/library/windows/hardware/ff547383) 섹션은 minifilter 드라이버 및 응용 프로그램 파일을 복사 할 디렉토리를 지정합니다.

이 섹션과 ServiceInstall 섹션에서 시스템 정의 숫자 값으로 잘 알려진 시스템 디렉토리를 지정할 수 있습니다. 이 값의 목록은 [INF DestinationDirs 섹션](https://msdn.microsoft.com/library/windows/hardware/ff547383)을 참조하십시오. 다음 코드 예에서 값 12는 Drivers 디렉터리 (%windir%\\system32\\drivers)를 나타내며 값 10은 Windows 디렉터리 (%windir%)를 나타냅니다.

```c
[DestinationDirs]
DefaultDestDir = 12
Minispy.DriverFiles = 12
Minispy.UserFiles   = 10,FltMgr
```



#### DefaultInstall Section (필수)

[DefaultInstall](https://msdn.microsoft.com/library/windows/hardware/ff547356) 섹션에서 [CopyFiles](https://msdn.microsoft.com/library/windows/hardware/ff546346) 지시문은 minifilter 드라이버의 드라이버 파일과 사용자 응용 프로그램 파일을 [DestinationDirs](https://msdn.microsoft.com/library/windows/hardware/ff547383) 섹션에 지정된 대상에 복사합니다.

참고 [CopyFiles](https://msdn.microsoft.com/library/windows/hardware/ff546346) 지시문은 카탈로그 파일이나 INF 파일 자체를 참조하면 안됩니다. SetupAPI는 이러한 파일을 자동으로 복사합니다.

여러 버전의 Windows 운영 체제에 드라이버를 설치하기 위해 단일 INF 파일을 만들 수 있습니다. 각 운영 체제 버전에 대해 추가 [DefaultInstall](https://msdn.microsoft.com/library/windows/hardware/ff547356),[DefaultInstall.Services](https://msdn.microsoft.com/library/windows/hardware/ff547360), DefaultUninstall 및 DefaultUninstall.Services 섹션을 만들어이 유형의 INF 파일을 만들 수 있습니다. 각 섹션에는 적용 할 운영 체제 버전을 지정하는 데코 레이팅 (예 : .ntx86, .ntia64 또는 .nt) 레이블이 지정됩니다. 이 유형의 INF 파일을 만드는 방법에 대한 자세한 내용은 다중 플랫폼 및 운영 체제 용 INF 파일 만들기를 참조하십시오.

다음 코드 예제는 일반적인 [DefaultInstall](https://msdn.microsoft.com/library/windows/hardware/ff547356) 섹션을 보여줍니다.

```c
[DefaultInstall]
OptionDesc = %MinispyServiceDesc%
CopyFiles = Minispy.DriverFiles, Minispy.UserFiles
```



#### DefaultInstall.Services Section (필수)

[DefaultInstall.Services](https://msdn.microsoft.com/library/windows/hardware/ff547360) 섹션에는 다음 코드 예제와 같이 특정 드라이버의 서비스가로드되는 방법과시기를 제어하는 [AddService](https://msdn.microsoft.com/library/windows/hardware/ff546326) 지시문이 있습니다.

```c
[DefaultInstall.Services]
AddService = %MinispyServiceName%,,Minispy.Service
```



#### ServiceInstall Section (필수)

ServiceInstall 섹션에는 드라이버 서비스를로드하는 데 사용되는 정보가 들어 있습니다. MiniSpy 샘플 드라이버에서이 섹션의 이름은 'Minispy.Service'이며 다음 코드 예제와 같습니다. ServiceInstall 섹션의 이름은 [DefaultInstall.Services](https://msdn.microsoft.com/library/windows/hardware/ff547360) 섹션의 [AddService](https://msdn.microsoft.com/library/windows/hardware/ff546326) 지시문에 나타나야합니다.

```c
[Minispy.Service]
DisplayName    = %MinispyServiceName%
Description    = %MinispyServiceDesc%
ServiceBinary  = %12%\minispy.sys
ServiceType    = 2 ;    SERVICE_FILE_SYSTEM_DRIVER
StartType      = 3 ;    SERVICE_DEMAND_START
ErrorControl   = 1 ;    SERVICE_ERROR_NORMAL%
LoadOrderGroup = "FSFilter Activity Monitor"
AddReg         = Minispy.AddRegistry
Dependencies   = FltMgr
```

ServiceType 항목은 서비스 유형을 지정합니다. 미니 필터 드라이버는 값 2 (SERVICE_FILE_SYSTEM_DRIVER)를 지정해야합니다. ServiceType 항목에 대한 자세한 내용은 [INF AddService 지시문](https://msdn.microsoft.com/library/windows/hardware/ff546326)을 참조하십시오.

StartType 항목은 서비스 시작시기를 지정합니다. 다음 표에서는 StartType 및 해당 시작 유형에 사용할 수있는 값을 나열합니다.

| Value      | Description          |
| ---------- | -------------------- |
| 0x00000000 | SERVICE_BOOT_START   |
| 0x00000001 | SERVICE_SYSTEM_START |
| 0x00000002 | SERVICE_AUTO_START   |
| 0x00000003 | SERVICE_DEMAND_START |
| 0x00000004 | SERVICE_DISABLED     |

이러한 시작 유형에 대한 자세한 내용은 [드라이버로드시 결정 사항](https://docs.microsoft.com/ko-kr/windows-hardware/drivers/ifs/what-determines-when-a-driver-is-loaded)의 '드라이버 시작 유형'을 참조하십시오.

LoadOrderGroup 항목은 필터 관리자에게 미니 필터 드라이버와 레거시 파일 시스템 필터 드라이버 간의 상호 운용성을 보장하는 데 필요한 정보를 제공합니다. 개발중인 미니 필터 드라이버 유형에 적합한 LoadOrderGroup 값을 지정해야합니다. 로드 순서 그룹을 선택하려면 [Minifilter 드라이버에 대한 주문 그룹 및 고도로드](https://docs.microsoft.com/ko-kr/windows-hardware/drivers/ifs/load-order-groups-and-altitudes-for-minifilter-drivers)를 참조하십시오.

미니 필터 드라이버의 시작 유형이 SERVICE_BOOT_START가 아니더라도 LoadOrderGroup 값을 지정해야합니다. 이러한 방식으로 미니 필터 드라이버는 레거시 파일 시스템 필터 드라이버와 다릅니다.

StartType 및 LoadOrderGroup 항목이 드라이버로드시기를 결정하는 방법에 대한 자세한 내용은 [드라이버로드시 결정 사항](https://docs.microsoft.com/ko-kr/windows-hardware/drivers/ifs/what-determines-when-a-driver-is-loaded)을 참조하십시오.

**참고** Minifilter 드라이버의 경우 레거시 파일 시스템 필터 드라이버와 달리 StartType 및 LoadOrderGroup 값은 minifilter 드라이버가 minifilter 인스턴스 스택에 연결되는 위치를 결정하지 않습니다. 이 위치는 미니 필터 인스턴스에 대해 지정된 고도에 의해 결정됩니다.

StartType 및 LoadOrderGroup 항목이 드라이버로드시기를 결정하는 방법에 대한 자세한 내용은[ 드라이버로드시 결정 사항](https://docs.microsoft.com/ko-kr/windows-hardware/drivers/ifs/what-determines-when-a-driver-is-loaded)을 참조하십시오.

참고 Minifilter 드라이버의 경우 레거시 파일 시스템 필터 드라이버와 달리 StartType 및 LoadOrderGroup 값은 minifilter 드라이버가 minifilter 인스턴스 스택에 연결되는 위치를 결정하지 않습니다. 이 위치는 미니 필터 인스턴스에 대해 지정된 고도에 의해 결정됩니다.

ErrorControl 항목은 시스템 시작 중에 서비스가 시작되지 않을 경우 수행 할 작업을 지정합니다. 미니 필터 드라이버는 1 (SERVICE_ERROR_NORMAL) 값을 지정해야합니다. ErrorControl 항목에 대한 자세한 내용은 [INF AddService 지시문](https://msdn.microsoft.com/library/windows/hardware/ff546326)을 참조하십시오.

[AddReg](https://msdn.microsoft.com/library/windows/hardware/ff546320) 지시문은 새로 설치된 서비스에 대한 레지스트리에 저장 될 정보가 들어있는 하나 이상의 INF 기록기 정의 AddRegistry 섹션을 참조합니다. Minifilter 드라이버는 AddRegistry 섹션을 사용하여 minifilter 드라이버 인스턴스를 정의하고 기본 인스턴스를 지정합니다.

종속성 항목은 드라이버가 종속 된 서비스 또는로드 순서 그룹의 이름을 지정합니다. 모든 미니 필터 드라이버는 필터 관리자의 서비스 이름 인 FltMgr을 지정해야합니다.



#### AddRegistry Section (필수)

AddRegistry 섹션은 키와 값을 레지스트리에 추가합니다. Minifilter 드라이버는 AddRegistry 섹션을 사용하여 minifilter 인스턴스를 정의하고 기본 인스턴스를 지정합니다. 이 정보는 필터 관리자가 minifilter 드라이버에 대한 새 인스턴스를 만들 때마다 사용됩니다.

MiniSpy 샘플 드라이버에서 다음의 AddRegistry 섹션과 [Strings](https://msdn.microsoft.com/library/windows/hardware/ff547485) 섹션의 % strkey % 토큰 정의는 세 개의 인스턴스를 정의하며 그 중 하나는 MiniSpy 샘플 드라이버의 기본 인스턴스로 명명됩니다.

```c
[Minispy.AddRegistry]
HKR,%RegInstancesSubkeyName%,%RegDefaultInstanceValueName%,0x00000000,%DefaultInstance%
HKR,%RegInstancesSubkeyName%"\"%Instance1.Name%,%RegAltitudeValueName%,0x00000000,%Instance1.Altitude%
HKR,%RegInstancesSubkeyName%"\"%Instance1.Name%,%RegFlagsValueName%,0x00010001,%Instance1.Flags%
HKR,%RegInstancesSubkeyName%"\"%Instance2.Name%,%RegAltitudeValueName%,0x00000000,%Instance2.Altitude%
HKR,%RegInstancesSubkeyName%"\"%Instance2.Name%,%RegFlagsValueName%,0x00010001,%Instance2.Flags%
HKR,%RegInstancesSubkeyName%"\"%Instance3.Name%,%RegAltitudeValueName%,0x00000000,%Instance3.Altitude%
HKR,%RegInstancesSubkeyName%"\"%Instance3.Name%,%RegFlagsValueName%,0x00010001,%Instance3.Flags%
```



#### DefaultUninstall Section (선택)

DefaultUninstall 섹션은 선택 사항이지만 드라이버를 제거 할 수있는 경우에 권장됩니다. 여기에는 다음 코드 예제와 같이 파일 및 레지스트리 항목을 제거하는 [DelFiles](https://msdn.microsoft.com/library/windows/hardware/ff547363) 및 [DelReg](https://msdn.microsoft.com/library/windows/hardware/ff547374) 지시문이 포함되어 있습니다.

```c
[DefaultUninstall]
DelFiles   = Minispy.DriverFiles, Minispy.UserFiles
DelReg     = Minispy.DelRegistry
```



#### DefaultUninstall.Services Section (선택)

DefaultUninstall.Services 섹션은 선택 사항이지만 드라이버를 제거 할 수있는 경우에 권장됩니다. MiniSpy 샘플 드라이버에서 다음 코드 예제와 같이 미니 필터 드라이버 서비스를 제거하는 [DelService](https://msdn.microsoft.com/library/windows/hardware/ff547377) 지시문이 포함되어 있습니다.

참고 서비스를 삭제하기 전에 서비스를 중지하려면 [DelService](https://msdn.microsoft.com/library/windows/hardware/ff547377) 지시문에 항상 SPSVCINST_STOPSERVICE 플래그 (0x00000200)를 지정해야합니다.

```c
[DefaultUninstall.Services]
DelService = Minispy,0x200
```



### Strings Section (필수)

Strings 섹션은 INF 파일에서 사용되는 각 %strkey% 토큰을 정의합니다.

INF 파일에 추가 로캘 별 Strings.LanguageID 섹션을 만들어 단일 국제 INF 파일을 만들 수 있습니다. 국제 INF 파일에 대한 자세한 내용은 [국제 INF 파일 만들기](https://msdn.microsoft.com/library/windows/hardware/ff540208)를 참조하십시오.

다음 코드 예제는 일반적인 [Strings](https://msdn.microsoft.com/library/windows/hardware/ff547485) 섹션을 보여줍니다.

```c
[Strings]
Msft               = "Microsoft Corporation"
MinispyServiceDesc = "Minispy mini-filter driver"
MinispyServiceName = "Minispy"
RegInstancesSubkeyName = "Instances"
RegDefaultInstanceValueName  = "DefaultInstance"
RegAltitudeValueName    = "Altitude"
RegFlagsValueName  = "Flags"

DefaultInstance    = "Minispy - Top Instance"
Instance1.Name     = "Minispy - Middle Instance"
Instance1.Altitude = "370000"
Instance1.Flags    = 0x1 ; Suppress automatic attachments
Instance2.Name     = "Minispy - Bottom Instance"
Instance2.Altitude = "365000"
Instance2.Flags    = 0x1 ; Suppress automatic attachments
Instance3.Name     = "Minispy - Top Instance"
Instance3.Altitude = "385000"
Instance3.Flags    = 0x1 ; Suppress automatic attachments
```



### Minifilter 드라이버에 대한 Order 그룹 및 Altitude 로드

Windows는 파일 시스템 필터 드라이버 및 시스템 시작시로드되는 미니 필터 드라이버에 전용로드 순서 그룹 집합을 사용합니다.

레거시 파일 시스템 필터 드라이버는 기존 파일 시스템 드라이버 스택의 맨 위에 만 첨부 할 수 있으며 스택 중간에 연결할 수 없습니다. 결과적으로 드라이버 및로드 순서 그룹의 시작 유형은 레거시 파일 시스템 필터 드라이버에 중요합니다. 필터 드라이버가 더 일찍로드 될수록 파일 시스템 드라이버 스택에 첨부 할 수 있기 때문입니다.

드라이버는 시스템의 부팅 단계를 나타내는 드라이버의 시작 유형에 따라 먼저로드됩니다. 시작 유형에 대한 자세한 내용은 [드라이버로드시 결정 사항](https://docs.microsoft.com/ko-kr/windows-hardware/drivers/ifs/what-determines-when-a-driver-is-loaded)의 '드라이버 시작 유형'을 참조하십시오. 시작 유형이 SERVICE_BOOT_START 인 모든 파일 시스템 필터 드라이버 및 미니 필터 드라이버는 시작 유형이 SERVICE_SYSTEM_START 또는 SERVICE_AUTO_START 인 드라이버보다 먼저로드됩니다. 시작 유형은 Minifilter 드라이버를 설치하는 데 사용되는 INF 파일의 ServiceInstall 섹션에있는 StartType 항목에 의해 지정됩니다. 각 시작 유형 범주 내에서로드 순서 그룹은 파일 시스템 필터 드라이버 및 미니 필터 드라이버가로드 될시기를 결정합니다.

미니 필터 드라이버는 언제든지로드 할 수 있습니다. 로드 순서 그룹의 개념은 레거시 파일 시스템 필터 드라이버와의 상호 운용성을 위해 미니 필터 드라이버에서 여전히 필요합니다. 모든 minifilter 드라이버에는 고도라는 고유 한 식별자가 있어야합니다. 미니 필터 드라이버의 고도(Altitude)는 미니 필터 드라이버가로드 될 때 I / O 스택의 다른 미니 필터 드라이버와 관련된 위치를 정의합니다. 고도(Altitude)는 십진수로 해석되는 무한 정밀도 문자열입니다. 낮은 숫자 고도가있는 미니 필터 드라이버는 더 높은 수치 값을 갖는 미니 필터 드라이버 아래의 I / O 스택에로드됩니다.

각로드 오더 그룹에는 정의 된 고도 범위가 있습니다. 미니 필터 드라이버에 대한 고도 할당은 Microsoft에서 관리합니다. 미니 필터 드라이버의 고도를 요청하려면 fsfcomm@microsoft.com에 전자 메일 메시지를 보내 할당 할 것을 요청하십시오.

미니 필터 드라이버는로드 순서 그룹을 나타내는 고도 범위에서 고도 값을 지정해야합니다. 미니 필터 드라이버의 고도 값은 미니 파일 드라이버를 설치하는 데 사용되는 INF 파일의 문자열 섹션 인스턴스 정의에 지정됩니다. 인스턴스 정의는 [FLT_REGISTRATION](https://msdn.microsoft.com/library/windows/hardware/ff544811) 구조의 [InstanceSetupCallback](https://msdn.microsoft.com/library/windows/hardware/ff551096) 루틴에 대한 호출에서도 지정할 수 있습니다. 미니 필터 드라이버에 대해 여러 개의 인스턴스와 고도를 정의 할 수 있습니다. 이러한 인스턴스 정의는 모든 볼륨에 적용됩니다.

시작 유형 및로드 순서 그룹에 대한 다음 규칙은 미니 필터 드라이버를로드 할시기를 결정합니다.

- 특정 시작 유형 및로드 순서 그룹을 지정하는 minifilter 드라이버는 해당 시작 유형 및로드 순서 그룹의 다른 파일 시스템 필터 드라이버 및 minifilter 드라이버와 동시에로드됩니다.
- 각로드 순서 그룹 내에서 파일 시스템 필터 드라이버 및 미니 필터 드라이버는 일반적으로 임의의 순서로로드됩니다. 일반적으로 드라이버가 설치된 순서에 따라 드라이버가로드됩니다.
- 파일 시스템 필터 드라이버 또는 미니 필터 드라이버가로드 순서 그룹을 지정하지 않으면로드 순서 그룹을 지정하는 동일한 시작 유형의 다른 모든 드라이버 뒤에로드됩니다.

다음 표는 minifilter 드라이버의 시스템 정의로드 순서 그룹과 고도 범위를 나열합니다. 각로드 순서 그룹의 경우로드 순서 그룹 열에는 미니 필터의 INF 파일의 ServiceInstall 섹션에있는 LoadOrderGroup 항목에서 해당 그룹에 대해 지정해야하는 값이 들어 있습니다. 고도 범위 열은 특정로드 오더 그룹에 대한 고도 범위를 포함합니다. 미니 필터 드라이버는 적절한로드 주문 그룹에서 Microsoft에 고도 할당을 요청해야합니다.

로드 순서 그룹과 고도 범위는 스택에 표시된대로 나열됩니다.로드되는 순서의 역순입니다.

| Load order group                   | Altitude range | Description                                                  |
| ---------------------------------- | -------------- | ------------------------------------------------------------ |
| Filter                             | 420000-429999  | 이 그룹은 Windows 2000 및 이전 버전에서 사용 가능한 필터로드 순서 그룹과 동일합니다. 이 그룹은 마지막에로드되므로 파일 시스템에서 가장 멀리 붙습니다. |
| FSFilter Top                       | 400000-409999  | 이 그룹은 다른 모든 FSFilter 유형 위에 첨부해야하는 필터 드라이버에 제공됩니다. |
| FSFilter Activity Monitor          | 360000-389999  | 이 그룹에는 파일 I / O를 관찰하고보고하는 필터 드라이버가 포함됩니다. |
| FSFilter Undelete                  | 340000-349999  | 이 그룹에는 삭제 된 파일을 복구하는 필터가 포함됩니다.       |
| FSFilter Anti-Virus                | 320000-329999  | 이 그룹에는 파일 I / O 중에 바이러스를 탐지하고 치료하는 필터 드라이버가 포함됩니다. |
| FSFilter Replication               | 300000-309999  | 이 그룹에는 원격 서버에 파일 데이터를 복제하는 필터 드라이버가 포함되어 있습니다. |
| FSFilter Continuous Backup         | 280000-289999  | 이 그룹에는 파일 데이터를 백업 미디어에 복제하는 필터 드라이버가 포함되어 있습니다. |
| FSFilter Content Screener          | 260000-269999  | 이 그룹에는 특정 파일이나 파일 내용을 만들지 못하도록하는 필터 드라이버가 포함되어 있습니다. |
| FSFilter Quota Management          | 240000-249999  | 이 그룹에는 향상된 파일 시스템 할당량을 제공하는 필터 드라이버가 포함됩니다. |
| FSFilter System Recovery           | 220000-229999  | 이 그룹에는 시스템 복원 (SR) 필터와 같은 운영 체제 무결성을 유지하기위한 작업을 수행하는 필터 드라이버가 포함되어 있습니다. |
| FSFilter Cluster File System       | 200000-209999  | 이 그룹에는 네트워크에서 파일 서버 메타 데이터를 제공하는 제품에 사용되는 필터 드라이버가 포함되어 있습니다. |
| FSFilter HSM                       | 180000-189999  | 이 그룹에는 계층 적 저장소 관리를 수행하는 필터 드라이버가 포함됩니다. |
| FSFilter Imaging                   | 170000-175000  | 이 그룹에는 가상 이름 공간을 제공하는 ZIP 유사 필터 드라이버가 포함되어 있습니다.<br/><br/>이로드 그룹은 Windows Vista 및 이후 버전의 운영 체제에서 사용할 수 있습니다. |
| FSFilter Compression               | 160000-169999  | 이 그룹에는 파일 데이터 압축을 수행하는 필터 드라이버가 포함됩니다. |
| FSFilter Encryption                | 140000-149999  | 이 그룹에는 파일 I / O 중에 데이터를 암호화하고 해독하는 필터 드라이버가 포함되어 있습니다. |
| FSFilter Virtualization            | 130000- 139999 | 이 그룹에는 Windows Vista에 추가 된 LUA (Least Authorized User) 필터 드라이버와 같이 파일 경로를 가상화하는 필터 드라이버가 포함됩니다.<br/><br/>이로드 그룹은 Windows Vista 및 이후 버전의 운영 체제에서 사용할 수 있습니다. |
| FSFilter Physical Quota Management | 120000-129999  | 이 그룹에는 물리적 블록 수를 사용하여 할당량을 관리하는 필터 드라이버가 포함되어 있습니다. |
| FSFilter Open File                 | 100000-109999  | 이 그룹에는 이미 열려있는 파일의 스냅 샷을 제공하는 필터 드라이버가 포함되어 있습니다. |
| FSFilter Security Enhancer         | 80000-89999    | 이 그룹에는 잠금 및 향상된 액세스 제어 목록 (ACL)을 적용하는 필터 드라이버가 포함되어 있습니다. |
| FSFilter Copy Protection           | 60000-69999    | 이 그룹에는 미디어의 대역 외 데이터를 확인하는 필터 드라이버가 포함되어 있습니다. |
| FSFilter Bottom                    | 40000-49999    | 이 그룹은 다른 모든 FSFilter 유형 아래에 첨부해야하는 필터 드라이버에 제공됩니다. |
| FSFilter System                    | 20000-29999    | 내부 용으로 예약되어 있습니다.                               |
| FSFilter Infrastructure            |                | 내부 용으로 예약되어 있습니다. 이 그룹이 먼저로드되어 파일 시스템에서 가장 가까운 위치에 연결됩니다. |



### Allocated Altitudes

할당된 고도(Altitude)는 별도의 문서 **"할당된 Altitudes.md"** 로 작성 하였음.



### 미니 필터 Altitude 요구사항

미니 필터 Altitude 할당 요청은 전자 메일로 Microsoft에 전송됩니다. 전자 메일의 본문에는 다음 필드와 해당 정보가 포함되어야합니다.

| Field                              | Comment                                                      |
| ---------------------------------- | ------------------------------------------------------------ |
| Company name:                      |                                                              |
| Contact e-mail:                    |                                                              |
| Product name:                      |                                                              |
| Product URL:                       |                                                              |
| Product/Filter description:        | Microsoft에서 필터의 적절한 고도를 결정하는 데 도움이되는 단락 요약. |
| Filter filename:                   |                                                              |
| Filter type:                       | 다음 값 중 하나 : 레지스트리, 파일 시스템, 둘 모두           |
| Filter start-type:                 | 다음 값 중 하나 : 부팅, 시스템, 자동, 요구                   |
| Requested filter load order group: | 사용 가능한로드 순서 그룹에 대해서는 [파일 시스템 미니 필터 할당 된 고도](https://docs.microsoft.com/ko-kr/windows-hardware/drivers/ifs/allocated-altitudes)를 참조하십시오. |
| Requested altitude:                | Microsoft는 고도 가용성 및 필터 드라이버 기능에 따라 요청 된 고도와 다른 고도를 지정할 권한이 있습니다. |
| Additional information:            | 이 필드를 사용하여 고도를이 필터에 할당 할 때 Microsoft가 고려할 정보가 있는지 알려주십시오. |

위 내용을 ASCII 텍스트  로작성 하고, 'Minifilter altitude request'라는 제목 으로 fsfcomm@microsoft.com에 메일을 보냅니다.  그러면 이 필터의 고도(Altitude)를  다시 전자 메일로 회신됩니다.

다음은 할당 요청 전자 메일의 본문 예입니다.

```
Hi,

Below is the request information to assign an altitude for our Contoso DataKleen file system minifilter.

Company name: Contoso Ltd.
Contact e-mail: filterdev@contoso.com
Product name: Contoso DataKleen
Product URL: http://fsfilters.contoso.com
Product/Filter Description:
    The Contoso DataKleen filter removes all occurences of any byte having a value
    between 128 and 255 during file reads. Our minifilter removes this value since
    it is not displayable on TTY devices.
Filter filename: ContosoDK.sys
Filter type: FileSystem
Filter start-type: Demand
Requested filter load order group: FSFilter Content Screener
Requested altitude: 268400
Additional information: None

Thanks,

FilterDev
```

**노트**

- 모든 입력란을 작성해야합니다.
- 처리하고 고도를 지정하는 데 최대 2 주가 소요될 수 있습니다. 정보가 누락되면 과제가 지연 될 수 있습니다.
- 할당 된 고도(Altitude)는 결국 File System Minifilter Allocated Altitudes에 나열된 고도에 반영됩니다. Microsoft는이 목록을 매년 업데이트합니다.



### 재 분석 태그 요청

이것은 필요한 파일 시스템 필터 드라이버에 대해 Reparse Point 태그를 얻기위한 메커니즘입니다.



####  Reparse Point 태그 요청

 Reparse Point 태그를 얻으려면 Microsoft에 다음 정보를 보내십시오.

- Company name
- Company e-mail
- Company URL
- Contact e-mail
- Product name
- Product URL
- Product Description: (1 paragraph summary)
- Driver filename
- Driver device name
- Driver GUID
- High-latency bit enabled (yes/no)
- Name surrogate bit enabled (yes/no)



이 정보를 ASCII 텍스트 전자 메일 메시지로 다음 주소( [rpid@microsoft.com](mailto:rpid@microsoft.com))로 보냅니다 . 이 드라이버의 ReparseID 값은 지정된 전자 메일 주소로 다시 전자 메일로 전송됩니다.

다음 목록은 요청을 제출하기위한 몇 가지 요구 사항을 자세히 설명합니다.

- 모든 입력란을 작성해야합니다.
- 이 공개적으로 볼 수있는 데이터베이스에서 자신의 이름과 전자 메일 주소를 사용하지 않으려는 사용자는이 사용을위한 전자 메일 주소를 만드십시오 (파일 시스템 / 필터 드라이버가 포함 된 상호 운용성이있는 다른 회사의 경우 두 회사의 테스트 / 개발 팀이 서로 통신해야 함). 제안 된 이름은 'ntifskitrnYourCompanyName.com '.
- '높은 대기 시간'비트가 활성화 된 경우 이는 드라이버가 파일에 태그를 지정하고 긴 대기 시간을 가질 것으로 예상된다는 것을 의미합니다. 예를 들어, 이것은 Reparse Points를 사용하여 계층 적 저장소 솔루션을 구현하는 드라이버 등에 의해 설정됩니다.
- '이름 대리'비트가 활성화 된 경우 이는 드라이버가 시스템의 다른 명명 된 엔티티를 나타내는 것입니다. 예를 들어, 볼륨 마운트 포인트 또는 디렉토리 접합점의 이름.
- Reparse Points는 Windows의 강력한 기능이지만 개발자는 파일 당 하나의 재분석 지점 만있을 수 있으며 일부 Windows 메커니즘에서는 재분석 지점 (HSM, 기본 구조 저장)을 사용한다는 점을 알아야합니다. 개발자는 재분석 지점 태그가 이미 파일에 사용중인 경우 대체 전략을 가져야합니다.



## <span style="color:blue">미니 필터 드라이버에 대한 DriverEntry 루틴 작성</span>

모든 파일 시스템 미니 필터 드라이버에는 [DriverEntry](https://msdn.microsoft.com/library/windows/hardware/ff544113) 루틴이 있어야합니다. DriverEntry 루틴은 미니 필터 드라이버가로드 될 때 호출됩니다.

DriverEntry 루틴은 전역 초기화를 수행하고 미니 필터 드라이버를 등록하며 필터링을 시작합니다. 이 루틴은 IRQL PASSIVE_LEVEL의 시스템 스레드 컨텍스트에서 실행됩니다.

DriverEntry 루틴은 다음과 같이 정의됩니다.

```c++
NTSTATUS 
(*PDRIVER_INITIALIZE) ( 
    IN PDRIVER_OBJECT DriverObject, 
    IN PUNICODE_STRING RegistryPath 
    );
```

DriverEntry에는 두 개의 입력 매개 변수가 있습니다. 첫 번째 DriverObject는 미니 필터 드라이버가로드 될 때 생성 된 드라이버 개체입니다. 두 번째, RegistryPath는 minifilter 드라이버의 레지스트리 키에 대한 경로가 포함 된 카운트 된 유니 코드 문자열에 대한 포인터입니다.

미니 필터 드라이버의 DriverEntry 루틴은 다음 단계를 순서대로 수행해야합니다.

1. 미니 필터 드라이버에 필요한 전역 초기화를 수행하십시오.
2. [FltRegisterFilter](https://msdn.microsoft.com/library/windows/hardware/ff544305)를 호출하여 minifilter 드라이버를 등록하십시오.
3. [FltStartFiltering](https://msdn.microsoft.com/library/windows/hardware/ff544569)을 호출하여 필터링을 시작합니다.
4. 적절한 NTSTATUS 값을 리턴하십시오.

이 섹션에는 다음 내용이 포함됩니다.

[미니 필터 드라이버 등록](https://docs.microsoft.com/ko-kr/windows-hardware/drivers/ifs/registering-the-minifilter-driver)

[필터링 시작하기](https://docs.microsoft.com/ko-kr/windows-hardware/drivers/ifs/initiating-filtering)

[Minifilter DriverEntry 루틴에서 상태 반환](https://docs.microsoft.com/ko-kr/windows-hardware/drivers/ifs/returning-status)



### 미니필터 드라이버 등록

모든 minifilter 드라이버는 DriverEntry 루틴에서 [FltRegisterFilter](https://msdn.microsoft.com/library/windows/hardware/ff544305)를 호출하여 등록 된 minifilter 드라이버의 전역 목록에 자신을 추가하고 필터 관리자에게 콜백 루틴 목록 및 드라이버에 대한 기타 정보를 제공해야합니다.

MiniSpy 예제에서 다음 코드 예제와 같이 minifilter 드라이버가 등록됩니다.

```c++
NTSTATUS status;
status = FltRegisterFilter(
           DriverObject,                  //Driver
           &FilterRegistration,           //Registration
           &MiniSpyData.FilterHandle);    //RetFilter
```

FltRegisterFilter에는 두 개의 입력 매개 변수가 있습니다. 첫 번째 드라이버는 미니 필터 드라이버가 DriverEntry 루틴에 대한 DriverObject 입력 매개 변수로받은 드라이버 개체 포인터입니다. 두 번째로, Registration은 minifilter 드라이버의 콜백 루틴에 대한 엔트리 포인트를 포함하는 [FLT_REGISTRATION](https://msdn.microsoft.com/library/windows/hardware/ff544811) 구조체에 대한 포인터입니다.

또한 FltRegisterFilter에는 출력 필터 인 RetFilter가있어 미니 필터 드라이버에 대한 불투명 필터 포인터를 수신합니다. 이 필터 포인터는 [FltStartFiltering](https://msdn.microsoft.com/library/windows/hardware/ff544569) 및 [FltUnregisterFilter](https://msdn.microsoft.com/library/windows/hardware/ff544606) 를 포함하여 많은 FltXxx 지원 루틴에 필요한 입력 매개 변수입니다.



### 필터링 시작하기

[FltRegisterFilter](https://msdn.microsoft.com/library/windows/hardware/ff544305) 를 호출 한 후 Minifilter 드라이버의 [DriverEntry](https://msdn.microsoft.com/library/windows/hardware/ff544113) 루틴은 일반적으로 [FltStartFiltering](https://msdn.microsoft.com/library/windows/hardware/ff544569)을 호출하여 I/O 작업 필터링을 시작합니다.

모든 minifilter 드라이버는 [DriverEntry](https://msdn.microsoft.com/library/windows/hardware/ff544113) 루틴에서 [FltStartFiltering](https://msdn.microsoft.com/library/windows/hardware/ff544569)을 호출하여 minifilter 드라이버가 볼륨에 연결하고 I / O 요청을 필터링 할 준비가되었음을 필터 관리자에 알립니다. 미니 필터 드라이버가 FltStartFiltering을 호출하면 필터 관리자는 minifilter 드라이버를 완전히 활성 인 미니 필터 드라이버로 간주하여 I / O 요청과 연결할 볼륨에 대한 알림을 제공합니다. 미니 필터 드라이버는 FltStartFiltering이 반환되기 전에도 이러한 I / O 요청 및 알림을 받기 시작할 준비가되어 있어야합니다.

MiniSpy 샘플 드라이버에서 다음 코드 예제와 같이 [FltStartFiltering](https://msdn.microsoft.com/library/windows/hardware/ff544569) 이 호출됩니다.

```c++
status = FltStartFiltering( MiniSpyData.FilterHandle );
if( !NT_SUCCESS( status )) {
  FltUnregisterFilter( MiniSpyData.FilterHandle );
}
```

[FltStartFiltering](https://msdn.microsoft.com/library/windows/hardware/ff544569)을 호출해도 STATUS_SUCCESS가 반환되지 않으면 Minifilter 드라이버는 [FltUnregisterFilter](https://msdn.microsoft.com/library/windows/hardware/ff544606)를 호출하여 등록을 취소해야합니다.



### Minifilter DriverEntry 루틴에서 상태 반환

미니 필터 드라이버의 DriverEntry 루틴은 일반적으로 STATUS_SUCCESS를 반환합니다. 그러나 미니 필터 초기화가 실패하면 DriverEntry 루틴은 적절한 오류 NTSTATUS 값을 반환해야합니다.

DriverEntry 루틴이 NTSTATUS 값이 아닌 상태 값을 반환하면 시스템은 minifilter 드라이버를 언로드하여 응답합니다. 미니 필터 드라이버의 [FilterUnloadCallback](https://msdn.microsoft.com/library/windows/hardware/ff551085) 루틴은 호출되지 않습니다. 이러한 이유로 DriverEntry 루틴은 성공 NTSTATUS 값이 아닌 상태 값을 리턴하기 전에 시스템 자원에 할당 된 메모리를 확보해야합니다.



## <span style="color:blue">Minifilter 드라이버에 대한 FilterUnloadCallback 루틴 작성</span>

파일 시스템 미니 필터 드라이버는 선택적으로 [PFLT_FILTER_UNLOAD_CALLBACK](https://msdn.microsoft.com/library/windows/hardware/ff551085) 유형의 루틴을 미니 필터 드라이버의 FilterUnloadCallback 루틴으로 등록 할 수 있습니다. 이 콜백 루틴은 미니 필터 드라이버의 언로드 루틴이라고도합니다.

Minifilter 드라이버는 FilterUnloadCallback 루틴을 등록 할 필요가 없습니다. 그러나 미니 필터 드라이버가 FilterUnloadCallback 루틴을 등록하지 않으면 드라이버를 언로드 할 수 없기 때문에 미니 필터 드라이버가이 콜백 루틴을 등록하는 것이 좋습니다.

이 콜백 루틴을 등록하기 위해 minifilter 드라이버는 Minifilter 드라이버가 DriverEntry 루틴에서 [FltRegisterFilter](https://msdn.microsoft.com/library/windows/hardware/ff544305)에 대한 매개 변수로 전달하는 [FLT_REGISTRATION](https://msdn.microsoft.com/library/windows/hardware/ff544811) 구조체의 FilterUnloadCallback 멤버에 PFLT_FILTER_UNLOAD_CALLBACK 유형의 루틴 주소를 저장합니다.

이 섹션에는 다음 내용이 포함됩니다.

[언제 FilterUnloadCallback 루틴 호출 하는가](https://docs.microsoft.com/ko-kr/windows-hardware/drivers/ifs/when-the-filterunloadcallback-routine-is-called)

[FilterUnloadCallback 루틴 작성하기](https://docs.microsoft.com/ko-kr/windows-hardware/drivers/ifs/writing-a-filterunloadcallback-routine)



### 언제 FilterUnloadCallback 루틴 호출 하는가

필터 관리자는 다음 중 한 가지 방법으로 minifilter 드라이버를 언로드하기 전에 minifilter 드라이버의 FilterUnloadCallback 루틴을 호출합니다.

- 비 필수 언로드. 이러한 유형의 언로드는 사용자 모드 응용 프로그램이 [FilterUnload](https://msdn.microsoft.com/library/windows/hardware/ff541516)를 호출하거나 커널 모드 드라이버가 [FltUnloadFilter](https://msdn.microsoft.com/library/windows/hardware/ff544602)를 호출했을 때 발생합니다. 또한 명령 프롬프트에서 fltmc unload를 입력 할 때도 발생합니다.
- 필수 언로드. 이 유형의 언로드는 명령 프롬프트에서 sc stop 또는 net stop을 입력하여 서비스 중지 요청을 발행 할 때 발생합니다. sc stop 및 net stop 명령에 대한 자세한 내용을 보려면 시작 메뉴에서 도움말 및 지원을 클릭하십시오. 또한 사용자 모드 응용 프로그램이 SERVICE_CONTROL_STOP 제어 코드를 dwControl 매개 변수로 전달하여 Microsoft Win32 ControlService 함수를 호출 할 때 발생합니다. Win32 서비스 함수에 대한 자세한 내용은 Microsoft Windows SDK 설명서를 참조하십시오.

필수가 아닌 언로드의 경우, minifilter 드라이버의 FilterUnloadCallback 루틴이 STATUS_FLT_DO_NOT_DETACH와 같은 오류 또는 경고 NTSTATUS 값을 반환하면 필터 관리자는 미니 필터 드라이버를 언로드하지 않습니다.

필수 언로드의 경우 FilterUnloadCallback 루틴이 STATUS_FLT_DO_NOT_DETACH와 같은 오류 또는 경고 NTSTATUS 값을 반환하더라도 minif 드라이버의 FilterUnloadCallback 루틴 호출 후 필터 관리자가 minifilter 드라이버를 언로드합니다.

미니 필터 드라이버의 필수 언로드를 비활성화하려면 minifilter 드라이버는 Minifilter 드라이버가 DriverEntry 루틴에서 [FltRegisterFilter](https://msdn.microsoft.com/library/windows/hardware/ff544305)에 대한 매개 변수로 전달하는 [FLT_REGISTRATION](https://msdn.microsoft.com/library/windows/hardware/ff544811) 구조체의 Flags 멤버에 FLTFL_REGISTRATION_DO_NOT_SUPPORT_SERVICE_STOP 플래그를 설정합니다. 이 플래그가 설정되면 필터 관리자는 일반적으로 비 필수 언로드 요청을 처리합니다. 그러나 필수 언로드 요청은 실패합니다. 필터 관리자는 실패한 언로드 요청에 대해 minifilter 드라이버의 FilterUnloadCallback 루틴을 호출하지 않습니다.

미니 필터 드라이버의 DriverEntry 루틴이 경고 또는 NTSTATUS 오류 값을 반환하면 FilterUnloadCallback 루틴이 호출되지 않습니다. 필터 관리자는 미니 필터 드라이버를 언로드합니다.

시스템 종료시 FilterUnloadCallback 루틴이 호출되지 않습니다. 종료 처리를 수행해야하는 minifilter 드라이버는 IRP_MJ_SHUTDOWN 작업을위한 사전 콜백 루틴을 등록해야합니다.



### FilterUnloadCallback 루틴 작성하기

FilterUnloadCallback 루틴은 다음과 같이 정의됩니다.

```c++
typedef NTSTATUS
(*PFLT_FILTER_UNLOAD_CALLBACK) (
    FLT_FILTER_UNLOAD_FLAGS Flags
    );
```

FilterUnloadCallback 루틴에는 NULL 또는 FLTFL_FILTER_UNLOAD_MANDATORY 일 수있는 플래그 인 하나의 입력 매개 변수가 있습니다. 필터 관리자는이 매개 변수를 FLTFL_FILTER_UNLOAD_MANDATORY로 설정하여 언로드 작업이 필수임을 나타냅니다. 이 매개 변수에 대한 자세한 내용은 [PFLT_FILTER_UNLOAD_CALLBACK](https://msdn.microsoft.com/library/windows/hardware/ff551085)을 참조하십시오.

미니 필터 드라이버의 FilterUnloadCallback 루틴은 다음 단계를 수행해야합니다.

- 열려있는 모든 커널 모드 통신 서버 포트 핸들을 닫으십시오.
- FlifUnregisterFilter를 호출하여 minifilter 드라이버를 등록 취소하십시오.
- 필요한 전역 정리를 수행하십시오.
- 적절한 NTSTATUS 값을 리턴하십시오.

이 섹션에는 다음 내용이 포함됩니다.

[통신 서버 포트 닫기](https://docs.microsoft.com/ko-kr/windows-hardware/drivers/ifs/closing-the-communication-server-port)

[미니 필터 등록 취소](https://docs.microsoft.com/ko-kr/windows-hardware/drivers/ifs/unregistering-the-minifilter)

[글로벌 정리 수행](https://docs.microsoft.com/ko-kr/windows-hardware/drivers/ifs/performing-global-cleanup)

[FilterUnloadCallback 루틴에서 상태 반환](https://docs.microsoft.com/ko-kr/windows-hardware/drivers/ifs/returning-status-from-a-filterunloadcallback-routine)



#### 통신 서버 포트 닫기

미니 필터 드라이버가 이전에 [FltCreateCommunicationPort](https://msdn.microsoft.com/library/windows/hardware/ff541931)를 호출하여 커널 모드 통신 서버 포트를 열었 으면 [FltCloseCommunicationPort](https://msdn.microsoft.com/library/windows/hardware/ff541871)를 호출하여 포트를 닫아야합니다. 언로드 프로세스 중에 시스템이 중단되지 않게하려면 Minifilter 드라이버의 [FilterUnloadCallback](https://msdn.microsoft.com/library/windows/hardware/ff551085) 루틴이 [FltUnregisterFilter](https://msdn.microsoft.com/library/windows/hardware/ff544606)를 호출하기 전에이 포트를 닫아야합니다.

사용자 모드 응용 프로그램이 통신 서버 포트에 대한 연결이 열려 있으면 [FltCloseCommunicationPort](https://msdn.microsoft.com/library/windows/hardware/ff541871)가 반환 된 후 해당 연결에 대한 클라이언트 포트가 열려 있습니다. 그러나 필터 관리자는 미니 필터 드라이버가 언로드 될 때 모든 클라이언트 포트를 닫습니다.



#### 미니 필터 등록 취소

미니 필터 드라이버의 [FilterUnloadCallback](https://msdn.microsoft.com/library/windows/hardware/ff551085) 루틴은 Minifilter 드라이버의 등록을 취소하기 위해 FltUnregisterFilter를 호출해야합니다. [FltUnregisterFilter](https://msdn.microsoft.com/library/windows/hardware/ff544606)를 호출하면 다음과 같은 일이 발생합니다.

- 미니 필터 드라이버의 콜백 루틴은 등록이 해제되어 있습니다.
- 미니 필터 드라이버의 인스턴스가 찢어지고 minifilter 드라이버 인스턴스의 InstanceTeardownStartCallback 및 [InstanceTeardownCompleteCallback](https://msdn.microsoft.com/library/windows/hardware/ff551098) 루틴이 각 minifilter 드라이버 인스턴스에 대해 호출됩니다.
- 미니 필터 드라이버가 볼륨, 인스턴스, 스트림 또는 스트림 핸들에 컨텍스트를 설정하면 이러한 컨텍스트가 삭제됩니다. 미니 필터 드라이버가 지정된 컨텍스트 유형에 대한 CleanupContext 콜백 루틴을 등록한 경우 필터 관리자는 컨텍스트를 삭제하기 전에 [CleanupContext](https://msdn.microsoft.com/library/windows/hardware/ff551078) 루틴을 호출합니다.

미니 필터 드라이버의 불투명 필터 포인터에 미해결 런 다운 참조가있는 경우 FltUnregisterFilter는 제거 될 때까지 대기 상태가됩니다. 미해결의 런 다운 참조는 대개 Minifilter 드라이버가 [FltQueueGenericWorkItem](https://msdn.microsoft.com/library/windows/hardware/ff543452)을 호출하여 작업 항목을 시스템 작업 대기열에 삽입하고 작업 항목이 아직 대기열에서 제외되고 처리되지 않았기 때문에 발생합니다. (필터 관리자는 minifilter 드라이버가 FltQueueGenericWorkItem을 호출 할 때 마침표 참조를 추가하고 minifilter 드라이버의 작업 루틴이 반환 될 때 필터 관리자를 제거합니다.)

Minifilter 드라이버가 Minifilter 드라이버의 불투명 필터 포인터 (예 : [FltObjectReference](https://msdn.microsoft.com/library/windows/hardware/ff543382) 또는 [FltGetFilterFromInstance](https://msdn.microsoft.com/library/windows/hardware/ff543049))에 런 다운 참조를 추가하지만 나중에 [FltObjectDereference](https://msdn.microsoft.com/library/windows/hardware/ff543378)를 호출하지 않은 루틴을 호출하면 뛰어난 런 다운 참조가 발생할 수도 있습니다.



#### 글로벌 정리 수행

미니 필터 드라이버의 [FilterUnloadCallback](https://msdn.microsoft.com/library/windows/hardware/ff551085) 루틴은 필요한 전역 정리를 수행해야합니다. 다음 목록에는 미니 필터 드라이버가 수행 할 수있는 전역 정리 작업의 예가 포함되어 있습니다.

- [ExDeleteResourceLite](https://msdn.microsoft.com/library/windows/hardware/ff544578)를 호출하여 이전에 [ExInitializeResourceLite](https://msdn.microsoft.com/library/windows/hardware/ff545317)를 호출하여 초기화 된 전역 리소스 변수를 삭제합니다.
- [ExFreePool](https://msdn.microsoft.com/library/windows/hardware/ff544590) 또는 [ExFreePoolWithTag](https://msdn.microsoft.com/library/windows/hardware/ff544593)를 호출하여 [ExAllocatePoolWithTag](https://msdn.microsoft.com/library/windows/hardware/ff544520)와 같은 루틴 호출에 의해 할당 된 전역 메모리를 해제합니다.
- [ExDeleteNPagedLookasideList](https://msdn.microsoft.com/library/windows/hardware/ff544566) 또는 [ExDeletePagedLookasideList](https://msdn.microsoft.com/library/windows/hardware/ff544570)를 호출하여 [ExInitializeNPagedLookasideList](https://msdn.microsoft.com/library/windows/hardware/ff545301) 또는 [ExInitializePagedLookasideList](https://msdn.microsoft.com/library/windows/hardware/ff545309)에 대한 이전 호출에 의해 할당 된 lookaside 목록을 각각 삭제합니다.
- [PsRemoveCreateThreadNotifyRoutine](https://msdn.microsoft.com/library/windows/hardware/ff559947) 또는 [PsRemoveLoadImageNotifyRoutine](https://msdn.microsoft.com/library/windows/hardware/ff559949)을 호출하여 [PsSetCreateThreadNotifyRoutine](https://msdn.microsoft.com/library/windows/hardware/ff559954) 또는 [PsSetLoadImageNotifyRoutine](https://msdn.microsoft.com/library/windows/hardware/ff559957)에 대한 이전 호출에 의해 등록 된 전역 콜백 루틴을 등록 취소하십시오.



#### FilterUnloadCallback 루틴에서 상태 반환

미니 필터 드라이버의 [FilterUnloadCallback](https://msdn.microsoft.com/library/windows/hardware/ff551085) 루틴은 일반적으로 STATUS_SUCCESS를 반환합니다.

필수가 아닌 언로드 작업을 거부하려면 minifilter 드라이버가 적절한 경고를 반환하거나 STATUS_FLT_DO_NOT_DETACH와 같은 NTSTATUS 값을 반환해야합니다. 필수 언로드 작업에 대한 자세한 내용은 [FilterUnloadCallback 루틴 작성](https://docs.microsoft.com/ko-kr/windows-hardware/drivers/ifs/writing-a-filterunloadcallback-routine) 및 [PFLT_FILTER_UNLOAD_CALLBACK](https://msdn.microsoft.com/library/windows/hardware/ff551085)을 참조하십시오.

FilterUnloadCallback 루틴이 경고 또는 오류 NTSTATUS 값을 리턴하고 언로드 조작이 필수가 아닌 경우, 미니 필터 드라이버는 언로드되지 않습니다.



## <span style="color:blue">사전 및 사후 콜백 루틴 작성</span>

DriverEntry 루틴에서 minifilter 드라이버는 필터링해야하는 각 I / O 작업 유형에 대해 하나의 [사전 콜백 루틴](https://msdn.microsoft.com/library/windows/hardware/ff551109)과 최대 하나의 [사후 콜백 루틴](https://msdn.microsoft.com/library/windows/hardware/ff551107)을 등록 할 수 있습니다.

레거시 파일 시스템 필터 드라이버와 달리 미니 필터 드라이버는 필터링 할 I / O 작업 유형을 선택할 수 있습니다. 미니 필터 드라이버는 작업 후 콜백을 등록하지 않고 주어진 유형의 I / O 작업에 대한 사전 콜백 루틴을 등록 할 수 있으며 그 반대로도 가능합니다. 미니 필터 드라이버는 사전 작동 또는 사후 작동 콜백 루틴을 등록한 I / O 조작 만 수신합니다.

사전 콜백 루틴은 레거시 필터 드라이버 모델의 디스패치 루틴과 유사합니다. 필터 관리자는 I / O 작업을 처리 할 때이 유형의 I / O 작업에 등록 된 미니 필터 드라이버 인스턴스 스택에서 각 미니 필터 드라이버의 사전 작업 콜백 루틴을 호출합니다. 스택의 최상위 미니 필터 드라이버 (즉, 가장 높은 고도를 가진 인스턴스)가 먼저 작업을 수신합니다. 해당 미니 필터 드라이버가 작업 처리를 완료하면 필터 관리자로 작업을 반환하고 필터 관리자는 그 작업을 다음 최상위 미니 필터 드라이버로 전달합니다. minifilter 드라이버가 I / O 작업을 완료하지 않은 경우 minifilter 드라이버 인스턴스 스택의 모든 minifilter 드라이버가 I / O 작업을 처리하면 필터 관리자가 레거시 필터와 파일 시스템에 작업을 보냅니다.

사후 콜백 루틴은 레거시 필터 드라이버 모델의 완료 루틴과 유사합니다. I / O 관리자가 파일 시스템에 작업을 전달하고 작업의 완료 루틴을 등록한 레거시 필터를 통과하면 I / O 작업의 완료 처리가 시작됩니다. 이러한 완료 루틴이 완료되면 필터 관리자는 작업의 완료 처리를 수행합니다. 그런 다음 필터 관리자는 이러한 유형의 I / O 작업에 등록 된 미니 필터 드라이버 인스턴스 스택에서 각 미니 필터 드라이버의 사후 콜백 루틴을 호출합니다. 스택의 하단 minifilter 드라이버 - 즉 인스턴스가 가장 낮은 고도를 가진 드라이버 -가 먼저 작업을 수신합니다. 해당 미니 필터 드라이버가 작업 처리를 완료하면이를 필터 관리자로 반환하고 필터 관리자는 그 작업을 다음 최저 minifilter 드라이버로 전달합니다.

이 섹션에는 다음 내용이 포함됩니다.

[사전 및 사후 콜백 루틴 등록](https://docs.microsoft.com/ko-kr/windows-hardware/drivers/ifs/registering-preoperation-and-postoperation-callback-routines)

[미니 필터 드라이버에서 I/O 작업 필터링](https://docs.microsoft.com/ko-kr/windows-hardware/drivers/ifs/filtering-i-o-operations-in-a-minifilter-driver)

[사전 콜백 루틴 작성하기](https://docs.microsoft.com/ko-kr/windows-hardware/drivers/ifs/writing-preoperation-callback-routines)

[사후 콜백 루틴 작성하기](https://docs.microsoft.com/ko-kr/windows-hardware/drivers/ifs/writing-postoperation-callback-routines)

[I/O 작업의 매개 변수 수정](https://docs.microsoft.com/ko-kr/windows-hardware/drivers/ifs/modifying-the-parameters-for-an-i-o-operation)

[I/O 작업을위한 버퍼링 방법 결정](https://docs.microsoft.com/ko-kr/windows-hardware/drivers/ifs/determining-the-buffering-method-for-an-i-o-operation)

[I/O 작업을위한 사용자 버퍼 액세스](https://docs.microsoft.com/ko-kr/windows-hardware/drivers/ifs/accessing-the-user-buffers-for-an-i-o-operation)





### 사전 및 사후 콜백 루틴 등록

[preoperation 콜백 루틴](https://msdn.microsoft.com/library/windows/hardware/ff551109)과[ postoperation 콜백 루틴](https://msdn.microsoft.com/library/windows/hardware/ff551107)을 등록하기 위해 minifilter 드라이버는 DriverEntry 루틴에서 FltRegisterFilter를 한 번 호출합니다. [FltRegisterFilter](https://msdn.microsoft.com/library/windows/hardware/ff544305)의 Registration 매개 변수의 경우, minifilter 드라이버는 [FLT_REGISTRATION](https://msdn.microsoft.com/library/windows/hardware/ff544811) 구조체에 대한 포인터를 전달합니다. 이 구조체의 OperationRegistration 멤버는 미니 필터 드라이버가 필터링해야하는 각 유형의 I / O 작업에 대한 [FLT_OPERATION_REGISTRATION](https://msdn.microsoft.com/library/windows/hardware/ff544668) 구조체의 배열에 대한 포인터를 포함합니다.

배열의 각 FLT_OPERATION_REGISTRATION 구조는 마지막 정보를 제외하고 다음 정보를 포함합니다.

- 작업의 주요 기능 코드입니다. 입출력 조작 및 그 요청 유형 특정 매개 변수에 대한 정보는 [FLT_PARAMETERS](https://docs.microsoft.com/windows-hardware/drivers/ddi/content/fltkernel/ns-fltkernel-_flt_parameters)를 참조하십시오.
- 읽기 및 쓰기 작업 (IRP_MJ_READ 및 IRP_MJ_WRITE)에는 IRP 기반 I / O 작업에 대해 캐시 된 I / O 또는 페이징 I / O 또는 둘 다를 무시할지 여부를 지정하는 플래그 집합
- 최대 1 개의 전처리 콜백 루틴 및 1 개의 사후 콜백 루틴에 대한 진입 점

배열의 마지막 요소는 {IRP_MJ_OPERATION_END}이어야합니다.

Scanner 샘플 미니 필터 드라이버에서 가져온 다음 코드 예제는 FLT_OPERATION_REGISTRATION 구조체의 배열을 보여줍니다. 스캐너 샘플 minifilter 드라이버는 IRP_MJ_CREATE에 대한 사전 작동 및 사후 작업 콜백 루틴과 IRP_MJ_CLEANUP 및 IRP_MJ_WRITE 작업에 대한 사전 콜백 루틴을 등록합니다.

```c++
const FLT_OPERATION_REGISTRATION Callbacks[] = {
    {IRP_MJ_CREATE,
     0,
     ScannerPreCreate,
     ScannerPostCreate},
    {IRP_MJ_CLEANUP,
     0, 
     ScannerPreCleanup,
     NULL},
    {IRP_MJ_WRITE,
     0, 
     ScannerPreWrite,
     NULL},
    {IRP_MJ_OPERATION_END}
};
```





### 미니 필터 드라이버에서 I/O 작업 필터링

다음 목록은 파일 시스템 미니 필터 드라이버에서 특정 유형의 I / O 작업을 필터링하기위한 몇 가지 지침을 설명합니다.

- IRP_MJ_CREATE에 대한 사전 작업 콜백 루틴은 파일, 스트림 또는 스트림 핸들에 대한 컨텍스트를 쿼리하거나 설정할 수 없습니다. 왜냐하면 미리 생성 될 때 생성 될 파일이나 스트림 (있는 경우)이 아직 결정되지 않았기 때문입니다.
- IRP_MJ_CREATE에 대한 사전 작업 콜백 루틴은 파일, 스트림 또는 스트림 핸들에 대한 컨텍스트를 쿼리하거나 설정할 수 없습니다. 왜냐하면 미리 생성 될 때 생성 될 파일이나 스트림 (있는 경우)이 아직 결정되지 않았기 때문입니다.
- Minifilter 드라이버는 IRP_MJ_CLEANUP 또는 IRP_MJ_CLOSE 작업을 절대로 실패하면 안됩니다. 이러한 작업은 지연되거나 필터 관리자에게 반환되거나 STATUS_SUCCESS로 완료 될 수 있습니다. 그러나 사전 작업 콜백 루틴은 이러한 작업을 절대로 실패해서는 안됩니다.
- Minifilter 드라이버는 IRP_MJ_SHUTDOWN에 대한 작업 콜백 루틴을 등록 할 수 없습니다.



### 사전 콜백 루틴 작성하기

파일 시스템 미니 필터 드라이버는 하나 이상의 사전 콜백 루틴을 사용하여 I / O 작업을 필터링합니다. 이전 작업 콜백 루틴은 레거시 파일 시스템 필터 드라이버에서 사용되는 디스패치 루틴과 유사합니다.

미니 필터 드라이버는 콜백 루틴의 진입 점을 [FLT_REGISTRATION](https://msdn.microsoft.com/library/windows/hardware/ff544811) 구조의 OperationRegistration 멤버에 저장하여 특정 유형의 I / O 작업에 대한 사전 콜백 루틴을 등록합니다. minifilter 드라이버는이 멤버를 DriverEntry 루틴의 [FltRegisterFilter](https://msdn.microsoft.com/library/windows/hardware/ff544305)에 대한 매개 변수로 전달합니다.

Minifilter 드라이버는 preoperation 또는 postoperation 콜백 루틴을 등록한 I / O 작업 유형 만받습니다. 미니 필터 드라이버는 사후 콜백 루틴을 등록하지 않고 주어진 유형의 I / O 작업에 대한 사전 콜백 루틴을 등록 할 수 있으며 그 반대로도 가능합니다.

다음 표에서는 특정 사용 시나리오와 반환 값에 대한 사전 콜백 루틴 구현을 보여줍니다.

| Usage Scenario                                               | Implementation                                               | Value Returned                  |
| ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------- |
| 루틴은 작업과 관련이 없으며 작업의 최종 상태가 필요하지 않거나 작업 후 콜백이 없습니다. | 완료시 미니 필터의 사후 콜백을 호출하지 않고 I / O 작업을 통과시킵니다. | FLT_PREOP_SUCCESS_NO_CALLBACK   |
| 루틴에는 작업의 최종 상태가 필요합니다.                      | 작업을 통과하면 미니 필터가 사후 콜백 루틴을 호출해야합니다. | FLT_PREOP_SUCCESS_WITH_CALLBACK |
| 미니 필터는 장래에이 작업을 완료하거나 처리를 계속해야합니다. | 조작을 보류 상태로 놓으십시오. 나중에 FltCompletePendedPreOperation을 사용하여 작업을 완료하십시오. FLT_PREOP_PENDING을 반환하는 사전 작업 루틴과 호출되는 FltCompletePendingOperation 사이에는 허용되는 경쟁이있을 수 있습니다. 필터 관리자는 드라이버에서 입력하지 않고이 시나리오를 처리합니다. | FLT_PREOP_PENDING               |
| 사후 처리는 디스패치 루틴이 호출 된 동일한 스레드 컨텍스트에서 발생해야합니다. 이렇게하면 일관된 IRQL이 보장되고 지역 변수 상태가 유지됩니다. | 작업을 작업 후 작업과 동기화하십시오.                        | FLT_PREOP_SYNCHRONIZE           |
| 사전 작업 콜백 루틴은 작업을 완료해야합니다.                 | 조작에 대한 처리를 중지하고 최종 NTSTATUS 값을 지정하십시오. | FLT_PREOP_COMPLETE              |

모든 전 콜백 루틴은 다음과 같이 정의됩니다.

```c++
typedef FLT_PREOP_CALLBACK_STATUS 
(*PFLT_PRE_OPERATION_CALLBACK) ( 
    IN OUT PFLT_CALLBACK_DATA Data, 
    IN PCFLT_RELATED_OBJECTS FltObjects, 
    OUT PVOID *CompletionContext 
    );
```

디스패치 루틴과 마찬가지로 사전 작업 콜백 루틴은 IRQL = PASSIVE_LEVEL 또는 IRQL = APC_LEVEL에서 호출 할 수 있습니다. 일반적으로 I / O 요청을 시작한 스레드의 컨텍스트에서 IRQL = PASSIVE_LEVEL에서 호출됩니다. 빠른 I / O 및 파일 시스템 필터 (FsFilter) 작업의 경우 사전 작업 콜백 루틴은 항상 IRQL = PASSIVE_LEVEL에서 호출됩니다. 그러나 IRP 기반 작업의 경우 상위 필터 또는 미니 필터 드라이버가 작업 스레드에서 처리하기 위해 작업을 보류하는 경우 시스템 작업자 스레드의 컨텍스트에서 미니 필터 드라이버의 사전 작업 콜백 루틴을 호출 할 수 있습니다.

IRQL > APC_LEVEL에서 작업 후 작업 루틴에서 컨텍스트 개체를 검색 할 수 없습니다. 대신 사전 작업 루틴 중에 컨텍스트 개체를 가져 와서이를 작업 후 루틴으로 전달하거나 IRQL <= APC_LEVEL에서 작업 후 처리를 수행하십시오. 컨텍스트에 대한 자세한 내용은 [컨텍스트 관리](https://docs.microsoft.com/ko-kr/windows-hardware/drivers/ifs/managing-contexts)를 참조하십시오.

필터 관리자가 주어진 I / O 작업에 대한 미니 필터 드라이버의 사전 콜백 루틴을 호출하면 미니 필터 드라이버가 일시적으로 I / O 작업을 제어합니다. 미니 필터 드라이버는 다음 중 하나가 될 때까지이 컨트롤을 유지합니다.

- 수술 전 콜백 루틴에서 FLT_PREOP_PENDING 이외의 상태 값을 반환합니다.
- Preoperation 콜백 루틴에서 보류 된 작업을 처리 한 작업 루틴에서 FltCompletePendedPreOperation을 호출합니다.

이 섹션에는 다음 내용이 포함됩니다.

[I/O 작업을 Minifilter 인스턴스 스택으로 전달](https://docs.microsoft.com/ko-kr/windows-hardware/drivers/ifs/passing-an-i-o-operation-down-the-minifilter-driver-instance-stack)

[사전 작업 콜백 루틴에서 I/O 작업 완료](https://docs.microsoft.com/ko-kr/windows-hardware/drivers/ifs/completing-an-i-o-operation-in-a-preoperation-callback-routine)

[사전 콜백 루틴에서 고속 I/O 작업을 허용하지 않습니다.](https://docs.microsoft.com/ko-kr/windows-hardware/drivers/ifs/disallowing-a-fast-i-o-operation-in-a-preoperation-callback-routine)

[사전 작업 콜백 루틴에서 I/O 작업 보류 중](https://docs.microsoft.com/ko-kr/windows-hardware/drivers/ifs/pending-an-i-o-operation-in-a-preoperation-callback-routine)



#### <span style="color:blue">I/O 작업을 Minifilter 인스턴스 스택으로 전달</span>

미니 필터 드라이버의 사전 작업 콜백 루틴 또는 작업 루틴이 I / O 작업을 필터 관리자에게 반환하면 필터 관리자는 작업을 미니 필터 드라이버 인스턴스 스택의 현재 minifilter 드라이버 아래의 미니 필터 드라이버 및 레거시 필터 및 추가 처리.

미니 필터 드라이버의 사전 작업 콜백 루틴은 다음 상태 값 중 하나를 반환하여 추가 처리를 위해 필터 관리자에 I / O 작업을 반환합니다.

- FLT_PREOP_SUCCESS_NO_CALLBACK (모든 작업 유형)
- FLT_PREOP_SUCCESS_WITH_CALLBACK (모든 작업 유형)
- FLT_PREOP_SYNCHRONIZE (IRP-based I/O operations only)

참고 FLT_PREOP_SYNCHRONIZE는 IRP 기반 I / O 작업에 대해서만 반환되어야하지만 다른 작업 유형에 대해서는이 상태 값을 반환 할 수 있습니다. IRP 기반 I / O 작업이 아닌 I / O 작업에 대해 반환 된 경우 필터 관리자는이 반환 값을 FLT_PREOP_SUCCESS_WITH_CALLBACK 인 것처럼 처리합니다.

또는 사전 콜백 루틴에서 보류 된 작업에 대한 작업 루틴은 FltCompletePendedPreOperation을 호출 할 때 CallbackStatus 매개 변수에 앞의 상태 값 중 하나를 전달하여 I / O 작업을 보류 된 I / O 작동.

이 섹션에는 다음 내용이 포함됩니다.

[FLT_PREOP_SUCCESS_WITH_CALLBACK 반환](https://docs.microsoft.com/ko-kr/windows-hardware/drivers/ifs/returning-flt-preop-success-with-callback)

[FLT_PREOP_SUCCESS_NO_CALLBACK 반환](https://docs.microsoft.com/ko-kr/windows-hardware/drivers/ifs/returning-flt-preop-success-no-callback)

[FLT_PREOP_SYNCHRONIZE 반환](https://docs.microsoft.com/ko-kr/windows-hardware/drivers/ifs/returning-flt-preop-synchronize)



##### <span style="color:green">FLT_PREOP_SUCCESS_WITH_CALLBACK 반환</span>

미니 필터 드라이버의 사전 콜백 루틴이 FLT_PREOP_SUCCESS_WITH_CALLBACK을 반환하면 필터 관리자는 I / O 완료 중에 미니 필터 드라이버의 사후 콜백 루틴을 호출합니다.

참고 minifilter 드라이버의 preoperation 콜백 루틴이 FLT_PREOP_SUCCESS_WITH_CALLBACK을 반환하지만 minifilter 드라이버가 작업에 대한 사후 콜백 루틴을 등록하지 않은 경우 시스템은 확인 된 빌드에 대해 assert됩니다.

미니 필터 드라이버의 사전 작업 콜백 루틴이 FLT_PREOP_SUCCESS_WITH_CALLBACK을 반환하면 CompletionContext 출력 매개 변수에서 NULL이 아닌 값을 반환 할 수 있습니다. 이 매개 변수는 해당 사후 콜백 루틴에 전달되는 선택적 컨텍스트 포인터입니다. 사후 콜백 루틴은 CompletionContext 입력 매개 변수에서이 포인터를받습니다.

FLT_PREOP_SUCCESS_WITH_CALLBACK 상태 값은 모든 유형의 입출력 조작에 대해 리턴 될 수 있습니다.



##### <span style="color:green">FLT_PREOP_SUCCESS_NO_CALLBACK 반환</span>

미니 필터 드라이버의 사전 콜백 루틴이 FLT_PREOP_SUCCESS_NO_CALLBACK을 반환하면 I / O 완료 중 필터 관리자가 미니 필터 드라이버의 사후 콜백 루틴을 호출하지 않습니다 (있는 경우).

미니 필터 드라이버의 사전 작업 콜백 루틴이 FLT_PREOP_SUCCESS_NO_CALLBACK을 반환하면 CompletionContext 출력 매개 변수에 NULL을 반환해야합니다.

FLT_PREOP_SUCCESS_NO_CALLBACK 상태 값은 모든 유형의 입출력 조작에 대해 리턴 될 수 있습니다.



##### <span style="color:green">FLT_PREOP_SYNCHRONIZE 반환</span>

미니 필터 드라이버의 사전 콜백 루틴이 FLT_PREOP_SYNCHRONIZE를 반환하여 I / O 작업을 동기화하면 I / O 완료 중에 필터 관리자가 미니 필터 드라이버의 사후 콜백 루틴을 호출합니다.

필터 관리자는 IRQL <= APC_LEVEL에서 preoperation 콜백과 동일한 스레드 컨텍스트에서 minifilter 드라이버의 사후 콜백 루틴을 호출합니다. 이 스레드 컨텍스트는 원래 스레드의 컨텍스트 일 필요는 없습니다.

참고 minifilter 드라이버의 preoperation 콜백 루틴이 FLT_PREOP_SYNCHRONIZE를 반환하지만 minifilter 드라이버가 작업에 대한 사후 콜백 루틴을 등록하지 않은 경우 시스템은 확인 된 빌드에 대해 assert됩니다.

미니 필터 드라이버의 사전 콜백 루틴이 FLT_PREOP_SYNCHRONIZE를 반환하면 CompletionContext 출력 매개 변수에 NULL이 아닌 값을 반환 할 수 있습니다. 이 매개 변수는 해당 사후 콜백 루틴에 전달되는 선택적 컨텍스트 포인터입니다. 사후 콜백 루틴은 CompletionContext 입력 매개 변수에서이 포인터를받습니다.

미니 필터 드라이버의 사전 작업 콜백 루틴은 IRP 기반 I / O 작업에 대해서만 FLT_PREOP_SYNCHRONIZE를 반환해야합니다. 그러나이 상태 값은 다른 조작 유형에 대해 리턴 될 수 있습니다. IRP 기반 I / O 작업이 아닌 I / O 작업에 대해 반환 된 경우 필터 관리자는이 반환 값을 FLT_PREOP_SUCCESS_WITH_CALLBACK 인 것처럼 처리합니다. 작업이 IRP 기반 I / O 작업인지 확인하려면 [FLT_IS_IRP_OPERATION](https://msdn.microsoft.com/library/windows/hardware/ff544654) 매크로를 사용하십시오.

Minifilter 드라이버는 필터 관리자에 의해 이미 동기화 된 작업이므로 FLT_PREOP_SYNCHRONIZE를 반환해서는 안됩니다. 미니 필터 드라이버가 IRP_MJ_CREATE 작업에 대한 운영 전 및 후 작업 콜백 루틴을 등록한 경우 작성 전 콜백 루틴과 동일한 스레드 컨텍스트에서 IRQL = PASSIVE_LEVEL에서 사후 작성 콜백 루틴이 호출됩니다.

Minifilter 드라이버는 비동기 읽기 또는 쓰기 작업을 위해 FLT_PREOP_SYNCHRONIZE를 반환해서는 안됩니다. 이렇게하면 미니 필터 드라이버와 시스템 성능이 크게 저하 될 수 있으며, 예를 들어 수정 된 페이지 작성기 스레드가 차단 된 경우에도 교착 상태가 발생할 수 있습니다. IRP 기반 읽기 또는 쓰기 작업에 대해 FLT_PREOP_SYNCHRONIZE를 반환하기 전에 Minifilter 드라이버는 [FltIsOperationSynchronous](https://msdn.microsoft.com/library/windows/hardware/ff543351)를 호출하여 작업이 동기인지 확인해야합니다.

다음과 같은 유형의 I / O 작업은 동기화 할 수 없습니다.

- oplock 파일 시스템 제어 (FSCTL) 작업 (MajorFunction은 IRP_MJ_FILE_SYSTEM_CONTROL이고 FsControlCode는 [FSCTL_REQUEST_FILTER_OPLOCK](https://msdn.microsoft.com/library/windows/hardware/ff545518), [FSCTL_REQUEST_BATCH_OPLOCK](https://msdn.microsoft.com/library/windows/hardware/ff545510), [FSCTL_REQUEST_OPLOCK_LEVEL_1](https://msdn.microsoft.com/library/windows/hardware/ff545538)또는 [FSCTL_REQUEST_OPLOCK_LEVEL_2](https://msdn.microsoft.com/library/windows/hardware/ff545546)입니다.)
- 디렉터리 변경 작업을 알립니다 (MajorFunction은 IRP_MJ_DIRECTORY_CONTROL이고 MinorFunction은 IRP_MN_NOTIFY_CHANGE_DIRECTORY입니다).
- 바이트 범위 잠금 요청 (MajorFunction은 IRP_MJ_LOCK_CONTROL이고 MinorFunction은 IRP_MN_LOCK입니다.)

이러한 작업에 대해서는 FLT_PREOP_SYNCHRONIZE를 반환 할 수 없습니다.



#### <span style="color:blue">사전 작업 콜백 루틴에서 I/O 작업 완료</span>

I / O 조작을 완료하려면 조작 처리를 중지하고 마지막 NTSTATUS 값을 지정하여 필터 관리자로 리턴하십시오.

미니 필터 드라이버가 I / O 작업을 완료하면 필터 관리자는 다음을 수행합니다.

- 현재 미니 필터 드라이버 아래의 미니 필터 드라이버, 레거시 필터 또는 파일 시스템으로 작업을 보내지 않습니다.
- minifilter 드라이버 인스턴스 스택의 현재 minifilter 드라이버 위의 minifilter 드라이버의 사후 콜백 루틴을 호출합니다.
- 작업에 대한 현재 미니 필터 드라이버의 사후 콜백 루틴을 호출하지 않습니다 (존재하는 경우).

미니 필터 드라이버의 사전 작업 콜백 루틴은 다음 단계를 수행하여 I / O 작업을 완료합니다.

1. 콜백 데이터 구조의 IoStatus.Status 필드를 작업의 최종 NTSTATUS 값으로 설정합니다.
2. FLT_PREOP_COMPLETE을 반환합니다.

I / O 조작을 완료하는 사전 조작 콜백 루틴은 CompletionContext 출력 매개 변수에서 NULL이 아닌 완료 컨텍스트를 설정할 수 없습니다.

미니 필터 드라이버는 다음 단계를 수행하여 이전에 보류 된 I / O 작업에 대한 작업 루틴에서 작업을 완료 할 수도 있습니다.

1. 콜백 데이터 구조의 IoStatus.Status 필드를 작업의 최종 NTSTATUS 값으로 설정합니다.
2. 작업 루틴이 FltCompletePendedPreOperation을 호출 할 때 CallbackStatus 매개 변수에 FLT_PREOP_COMPLETE을 전달합니다.

I / O 작업을 완료 할 때 미니 필터 드라이버는 콜백 데이터 구조의 IoStatus.Status 필드를 작업의 최종 NTSTATUS 값으로 설정해야하지만이 NTSTATUS 값은 STATUS_PENDING 또는 STATUS_FLT_DISALLOW_FAST_IO가 될 수 없습니다. 정리 또는 닫기 조작의 경우 필드는 STATUS_SUCCESS 여야합니다. 이러한 작업은 다른 NTSTATUS 값으로 완료 할 수 없습니다.

I / O 작업을 완료하는 것은 NTSTATUS 값에 따라 작업 성공 또는 실패라고도합니다.

- 성공하려면 I / O 조작은 성공 또는 정보 NTSTATUS 값 (예 : STATUS_SUCCESS)으로 완료하는 것을 의미합니다.
- I / O 조작이 실패하면 STATUS_INVALID_DEVICE_REQUEST 또는 STATUS_BUFFER_OVERFLOW와 같은 오류 또는 경고 NTSTATUS 값으로 완료하는 것을 의미합니다.

NTSTATUS 값은 ntstatus.h에 정의되어 있습니다. 이 값은 성공, 정보, 경고 및 오류의 네 가지 범주로 나뉩니다. 이 값에 대한 자세한 내용은[ NTSTATUS 값 사용](https://msdn.microsoft.com/library/windows/hardware/ff565436)을 참조하십시오.



#### <span style="color:blue">사전 콜백 루틴에서 고속 I/O 작업을 허용하지 않기.</span>

경우에 따라 미니 필터 드라이버는 완료하는 대신 고속 I / O 작업을 허용하지 않을 수도 있습니다. 고속 I / O 조작을 허용하지 않으면 빠른 I / O 경로가 조작에 사용되지 않습니다.

I / O 연산을 완료하는 것과 마찬가지로 고속 I / O 연산을 허용하지 않으면 처리를 중지하고 필터 관리자로 반환합니다. 그러나 빠른 I / O 작업을 허용하지 않는 것은 완료와 다릅니다. 미니 필터 드라이버가 I / O 관리자가 발행 한 빠른 I / O 작업을 허용하지 않는 경우 I / O 관리자는 동일한 작업을 동일한 IRP 기반 작업으로 다시 실행할 수 있습니다.

미니 필터 드라이버의 사전 작업 콜백 루틴이 빠른 I / O 작업을 허용하지 않으면 필터 관리자는 다음을 수행합니다.

- 현재 미니 필터 드라이버 아래의 미니 필터 드라이버, 레거시 필터 또는 파일 시스템으로 작업을 보내지 않습니다.
- minifilter 드라이버 인스턴스 스택의 현재 minifilter 드라이버 위의 minifilter 드라이버의 사후 콜백 루틴을 호출합니다.
- 작업에 대한 현재 미니 필터 드라이버의 사후 콜백 루틴을 호출하지 않습니다 (존재하는 경우).

미니 필터 드라이버는 작업 전 작업 콜백 루틴에서 FLT_PREOP_DISALLOW_FASTIO를 반환하여 빠른 I / O 작업을 허용하지 않습니다.

필터 관리자가 자동으로이 필드를 STATUS_FLT_DISALLOW_FAST_IO로 설정하기 때문에 사전 콜백 루틴은 콜백 데이터 구조의 IoStatus.Status 필드를 설정하면 안됩니다.

FLT_PREOP_DISALLOW_FASTIO는 빠른 입출력 조작을 위해서만 리턴 될 수 있습니다. 작업이 빠른 I / O 작업인지 확인하려면 FLT_IS_FASTIO_OPERATION을 참조하십시오.

Minifilter 드라이버는 IRP_MJ_SHUTDOWN, IRP_MJ_VOLUME_MOUNT 또는 IRP_MJ_VOLUME_DISMOUNT 작업에 대해 FLT_PREOP_DISALLOW_FASTIO을 반환 할 수 없습니다.



#### <span style="color:blue">사전 작업 콜백 루틴에서 I/O 작업 보류</span>

미니 필터 드라이버의 사전 작업 콜백 루틴은 작업을 시스템 작업 대기열에 게시하고 FLT_PREOP_PENDING을 반환하여 I / O 작업을 보류 할 수 있습니다. 이 상태 값을 반환하면 Minifilter 드라이버가 I / O 작업에 대한 처리를 다시 시작하기 위해 FltCompletePendedPreOperation을 호출 할 때까지 I / O 작업의 제어를 유지하고 있음을 나타냅니다.

미니 필터 드라이버의 사전 콜백 루틴은 다음 단계를 수행하여 I / O 작업을 보류합니다.

1. [FltQueueDeferredIoWorkItem](https://msdn.microsoft.com/library/windows/hardware/ff543449)과 같은 루틴을 호출하여 시스템 작업 큐에 I / O 작업을 게시합니다.
2. FLT_PREOP_PENDING 반환.

들어오는 입출력 조작을 보류해야하는 미니 필터 드라이버는 FltQueueDeferredIoWorkItem과 같은 루틴을 사용하여 작업을 보류해서는 안되며,이 루틴을 호출하면 시스템 작업 대기열이 넘칠 수 있기 때문입니다. 대신 이러한 미니 필터 드라이버는 취소 안전 큐를 사용해야합니다. 취소 안전 큐 사용에 대한 자세한 내용은 [FltCbdqInitialize](https://msdn.microsoft.com/library/windows/hardware/ff541802)를 참조하십시오.

다음 조건 중 하나라도 해당되면 FltQueueDeferredIoWorkItem에 대한 호출이 실패합니다.

- 이 작업은 IRP 기반 I / O 작업이 아닙니다.
- 작업은 페이징 I / O 작업입니다.
- 현재 스레드의 TopLevelIrp 필드가 NULL이 아닙니다. 이 필드의 값을 찾는 방법에 대한 자세한 내용은 [IoGetTopLevelIrp](https://msdn.microsoft.com/library/windows/hardware/ff548405)를 참조하십시오.
- I / O 작업의 대상 인스턴스가 제거 중입니다.

미니 필터 드라이버의 사전 작업 콜백 루틴이 FLT_PREOP_PENDING을 반환하면 CompletionContext 출력 매개 변수에 NULL을 반환해야합니다.

미니 필터 드라이버는 IRP 기반 I / O 작업에 대해서만 FLT_PREOP_PENDING을 반환 할 수 있습니다. 작업이 IRP 기반 I / O 작업인지 확인하려면 FLT_IS_IRP_OPERATION 매크로를 사용하십시오.

I / O 작업을 큐에서 처리하는 작업 루틴은 FltCompletePendedPreOperation을 호출하여 작업 처리를 다시 시작해야합니다.



### 사후 콜백 루틴 작성하기

파일 시스템 미니 필터 드라이버는 하나 이상의 사후 콜백 루틴을 사용하여 I / O 작업을 필터링합니다.

사후 콜백 루틴은 다음 작업 중 하나를 수행 할 수 있습니다.

- 수술 직후에 완성 작업을 직접 수행하십시오. 모든 완료 작업은 IRQL <= DISPATCH_LEVEL에서 수행 할 수 있습니다.
- 안전한 IRQL에서 완성 작업을 수행하십시오. FLT_STATUS_MORE_PROCESSING_REQUIRED를 반환하고 안전한 IRQL에서 처리 할 수 있도록 작업자 스레드를 대기시킵니다. 처리가 완료되면 작업자 스레드는 [FltCompletePendedPostOperation](https://msdn.microsoft.com/library/windows/hardware/ff541897)을 호출하여 작업 후 처리를 계속합니다.
- 성공적인 CREATE 조작을 취소하십시오.

사후 콜백 루틴은 레거시 파일 시스템 필터 드라이버에서 사용되는 완료 루틴과 유사합니다.

미니 필터 드라이버는 preoperation 콜백 루틴을 등록하는 것과 동일한 방식으로, 즉 콜백 루틴의 진입 점을 [FLT_REGISTRATION](https://msdn.microsoft.com/library/windows/hardware/ff544811) 구조체의 OperationRegistration 멤버에 저장하여 특정 유형의 I / O 작업에 대한 사후 콜백 루틴을 등록합니다 DriverEntry 루틴에서 [FltRegisterFilter](https://msdn.microsoft.com/library/windows/hardware/ff544305)에 대한 매개 변수로 전달됩니다.

Minifilter 드라이버는 preoperation 또는 postoperation 콜백 루틴을 등록한 I / O 작업 유형 만받습니다. 미니 필터 드라이버는 작업 후 콜백을 등록하지 않고 주어진 유형의 I / O 작업에 대한 사전 콜백 루틴을 등록 할 수 있으며 그 반대로도 가능합니다.

모든 사후 콜백 루틴은 다음과 같이 정의됩니다.

```c++
typedef FLT_POSTOP_CALLBACK_STATUS 
(*PFLT_POST_OPERATION_CALLBACK) ( 
    IN OUT PFLT_CALLBACK_DATA Data, 
    IN PCFLT_RELATED_OBJECTS FltObjects, 
    IN PVOID CompletionContext, 
    IN FLT_POST_OPERATION_FLAGS Flags 
    );
```

완료 루틴과 마찬가지로 임의의 스레드 컨텍스트에서 IRQL u003c= DISPATCH_LEVEL에서 후 작업 콜백 루틴이 호출됩니다.

IRQL = DISPATCH_LEVEL에서 호출 할 수 있으므로 사후 콜백 루틴은 FltLockUserBuffer 또는 RtlCompareUnicodeString과 같이 더 낮은 IRQL에서 호출해야하는 커널 모드 루틴을 호출 할 수 없습니다. 동일한 이유로 postoperation 콜백 루틴에 사용되는 모든 데이터 구조는 비 페이징 풀에서 할당되어야합니다.

앞의 규칙에 대한 몇 가지 예외는 다음과 같습니다.

- 미니 필터 드라이버의 사전 작업 콜백 루틴이 IRP 기반 I / O 작업에 대해 FLT_PREOP_SYNCHRONIZE를 반환하면 해당 사후 콜백 루틴은 사전 작업 콜백 루틴과 동일한 스레드 컨텍스트에서 IRQL <= APC_LEVEL에서 호출됩니다.
- 빠른 I / O 작업을위한 사후 콜백 루틴은 IRQL = PASSIVE_LEVEL에서 호출됩니다.이 작업은 사전 콜백 루틴과 동일한 스레드 컨텍스트에서 수행됩니다.
- 작성 후 콜백 루틴은 IRP_MJ_CREATE 작업을 시작한 스레드 컨텍스트에서 IRQL = PASSIVE_LEVEL에서 호출됩니다.

필터 관리자가 주어진 I / O 작업에 대한 미니 필터 드라이버의 사후 콜백 루틴을 호출하면 미니 필터 드라이버가 일시적으로 I / O 작업을 제어합니다. 미니 필터 드라이버는 다음 중 하나가 될 때까지이 컨트롤을 유지합니다.

- 사후 콜백 루틴에서 FLT_POSTOP_FINISHED_PROCESSING을 반환합니다.
- 사후 콜백 루틴에서 보류 된 IRP 기반 I / O 작업을 처리 한 작업 루틴에서 [FltCompletePendedPostOperation](https://msdn.microsoft.com/library/windows/hardware/ff541897)을 호출합니다.

이 섹션에는 다음 내용이 포함됩니다.

[I/O 작업을 위한 완료 처리 수행](https://docs.microsoft.com/ko-kr/windows-hardware/drivers/ifs/performing-completion-processing-for-an-i-o-operation)

[사후 콜백 루틴에서 I/O 작업 보류하기](https://docs.microsoft.com/ko-kr/windows-hardware/drivers/ifs/pending-an-i-o-operation-in-a-postoperation-callback-routine)

[사후 콜백 루틴에서 I/O 작업 실패](https://docs.microsoft.com/ko-kr/windows-hardware/drivers/ifs/failing-an-i-o-operation-in-a-postoperation-callback-routine)



#### <span style="color:blue">I/O 작업을 위한 완료 처리 수행</span>

미니 파일 드라이버의 사후 콜백 루틴은 기본 파일 시스템, 레거시 필터 또는 minifilter 드라이버 인스턴스 스택의 더 낮은 고도에있는 다른 미니 필터 드라이버에 의해 I / O 작업이 완료되면 호출됩니다.

또한 미니 필터 드라이버 인스턴스가 해체 될 때 필터 관리자는 인스턴스가 사전 작동 콜백을 수신하고 작동 후 콜백을 기다리는 모든 I / O 작업을 '소모합니다'. 이 상황에서 I / O 작업이 완료되지 않은 경우에도 필터 관리자가 미니 필터 드라이버의 사후 콜백 루틴을 호출하고 Flags 입력 매개 변수에 FLTFL_POST_OPERATION_DRAINING 플래그를 설정합니다.

FLTFL_POST_OPERATION_DRAINING 플래그가 설정되면, 미니 필터 드라이버는 정상적인 완료 처리를 수행해서는 안됩니다. 대신 사전 콜백 루틴에서 Minifilter 드라이버가 CompletionContext 매개 변수에 할당 한 메모리를 해제하고 FLT_POSTOP_FINISHED_PROCESSING을 반환하는 등 필요한 정리 만 수행해야합니다.

이 절에는 다음 항목이 포함되어 있습니다.

[안전한 IRQL에서 완성 처리가 수행되는지 확인](https://docs.microsoft.com/ko-kr/windows-hardware/drivers/ifs/ensuring-that-completion-processing-is-performed-at-safe-irql)

##### <span style="color:green">안전한 IRQL에서 완성 처리가 수행되는지 확인</span>

IRP 기반 I / O 작업에 대한 사후 콜백 루틴은 IRQL = DISPATCH_LEVEL에서 호출 할 수 있습니다. 단, minifilter 드라이버의 사전 작업 콜백 루틴이 FLT_PREOP_SYNCHRONIZE를 반환하여 작업을 동기화하지 않거나 작업이 생성 작업이면, 본질적으로 동기식이다. 이 반환 값에 대한 자세한 내용은 FLT_PREOP_SYNCHRONIZE 반환을 참조하십시오.

그러나 아직 동기화되지 않은 IRP 기반 I / O 작업의 경우 미니 필터 드라이버는 두 가지 기술을 사용하여 IRQL <= APC_LEVEL에서 완료 처리가 수행되도록합니다.

첫 번째 기법은 IRQL <= APC_LEVEL에서 완료 처리가 수행 될 때까지 I / O 작업을 보류하는 사후 콜백 루틴입니다. 이 기법은 작업 콜백 루틴에서 I / O 작업 대기 중에 설명되어 있습니다.

두 번째 방법은 Minifilter 드라이버의 사후 콜백 루틴이 FltDoCompletionProcessingWhenSafe를 호출하는 것입니다. FltDoCompletionProcessingWhenSafe는 현재 IRQL >= DISPATCH_LEVEL 인 경우에만 I / O 작업을 보류합니다. 그렇지 않으면이 루틴은 minifilter 드라이버의 SafePostCallback 루틴을 즉시 실행합니다. 이 기술은 FltDoCompletionProcessingWhenSafe에 설명되어 있습니다.



#### <span style="color:blue">사후 콜백 루틴에서 I/O 작업 보류하기</span>

미니 필터 드라이버의 사후 콜백 루틴은 다음 단계를 수행하여 I / O 작업을 보류 할 수 있습니다.

- FltAllocateDeferredIoWorkItem을 호출하여 I / O 작업에 대한 작업 항목을 할당합니다.
- FltQueueDeferredIoWorkItem을 호출하여 I / O 작업을 시스템 작업 큐에 게시합니다.
- FLT_POSTOP_MORE_PROCESSING_REQUIRED를 반환합니다.

다음 조건 중 하나라도 해당되면 FltQueueDeferredIoWorkItem에 대한 호출이 실패합니다.

- 이 작업은 IRP 기반 I / O 작업이 아닙니다.
- 작업은 페이징 I / O 작업입니다.
- 현재 스레드의 TopLevelIrp 필드가 NULL이 아닙니다. 이 필드의 값을 찾는 방법에 대한 자세한 내용은 IoGetTopLevelIrp를 참조하십시오.
- I / O 작업의 대상 인스턴스가 제거 중입니다. 필터 관리자는 Flags 입력 매개 변수에 FLTFL_POST_OPERATION_DRAINING 플래그를 사후 콜백 루틴으로 설정하여이 상황을 나타냅니다.

I / O 작업의 대상 인스턴스가 제거 중입니다. 필터 관리자는 Flags 입력 매개 변수에 FLTFL_POST_OPERATION_DRAINING 플래그를 사후 콜백 루틴으로 설정하여이 상황을 나타냅니다.

미니 필터 드라이버의 사후 콜백 루틴이 FLT_POSTOP_MORE_PROCESSING_REQUIRED를 반환하면 필터 관리자는 미니 필터 드라이버의 작업 루틴이 FltCompletePendedPostOperation을 호출하여 필터 관리자에게 작업 제어를 반환 할 때까지 I / O 작업에 대한 추가 완료 처리를 수행하지 않습니다. 작업 루틴이 작업의 콜백 데이터 구조의 IoStatus.Status 필드에 실패 NTSTATUS 값을 설정하더라도 필터 관리자는이 상황에서 더 이상의 처리를 수행하지 않습니다.

I / O 작업에 대한 완료 처리를 대기열에서 제외하고 완료하는 작업 루틴은 FltCompletePendedPostOperation을 호출하여 작업 제어를 필터 관리자로 반환해야합니다.



#### <span style="color:blue">사후 콜백 루틴에서 I/O 작업 실패</span>

미니 필터 드라이버의 사후 콜백 루틴은 성공적인 I / O 작업을 실패 할 수 있지만 단순히 I / O 작업을 실패해도 작업의 결과가 취소되지 않습니다. 미니 필터 드라이버는 작업을 실행 취소하는 데 필요한 모든 처리를 수행합니다.

예를 들어, 미니 필터 드라이버의 사후 작성 콜백 루틴은 다음 단계를 수행하여 IRP_MJ_CREATE 조작을 실패 할 수 있습니다.

1. FltCancelFileOpen을 호출하여 작성 작업으로 작성되었거나 열린 파일을 닫습니다. FltCancelFileOpen은 파일 수정을 취소하지 않습니다. 예를 들어, FltCancelFileOpen은 새로 생성 된 파일을 삭제하거나 잘린 파일을 이전 크기로 복원하지 않습니다.
2. 콜백 데이터 구조의 IoStatus.Status 필드를 작업의 최종 NTSTATUS 값으로 설정합니다. 이 값은 유효한 오류 NTSTATUS 값 (예 : STATUS_ACCESS_DENIED)이어야합니다.
3. 콜백 데이터 구조의 IoStatus.Information 필드를 0으로 설정.
4. FLT_POSTOP_FINISHED_PROCESSING 반환

콜백 데이터 구조의 IoStatus.Status 필드를 작업의 최종 NTSTATUS 값으로 설정할 때 minifilter 드라이버는 유효한 오류 NTSTATUS 값을 지정해야합니다. 미니 필터 드라이버는 STATUS_FLT_DISALLOW_FAST_IO를 지정할 수 없습니다. 필터 관리자 만이 NTSTATUS 값을 사용할 수 있습니다.

FltCancelFileOpen 호출자는 IRQL <= APC_LEVEL에서 실행되어야합니다. 그러나 IRFP_MJ_CREATE 작업의 경우 생성 작업을 시작한 스레드의 컨텍스트에서 IRQL = PASSIVE_LEVEL에서 후 작업 콜백 루틴이 호출되므로 미니 필터 드라이버는 사후 작성 콜백 루틴에서이 루틴을 안전하게 호출 할 수 있습니다.



### I/O 작업의 매개 변수 수정

미니 필터 드라이버는 I / O 작업의 매개 변수를 수정할 수 있습니다. 예를 들어 미니 필터 드라이버의 사전 작업 콜백 루틴은 작업의 대상 인스턴스를 변경하여 I / O 작업을 다른 볼륨으로 리디렉션 할 수 있습니다. 새 대상 인스턴스는 다른 볼륨의 동일한 고도에서 동일한 미니 필터 드라이버의 인스턴스 여야합니다.

I / O 연산의 매개 변수는 콜백 데이터 (FLT_CALLBACK_DATA) 구조와 I / O 매개 변수 블록 (FLT_IO_PARAMETER_BLOCK) 구조에서 찾을 수 있습니다. minifilter 드라이버의 사전 작업 콜백 루틴 및 사후 콜백 루틴은 데이터 입력 매개 변수의 작업에 대한 콜백 데이터 구조에 대한 포인터를받습니다. 콜백 데이터 구조의 Iopb 멤버는 작업 매개 변수가 들어있는 I / O 매개 변수 블록 구조에 대한 포인터입니다.

미니 필터 드라이버의 사전 작업 콜백 루틴이 I / O 작업의 매개 변수를 수정하면 미니 필터 드라이버 인스턴스 스택에있는 해당 미니 필터 드라이버 아래의 모든 미니 필터 드라이버가 수정 전 매개 변수를 해당 작업 전 및 후 작업 콜백 루틴에서 수신합니다.

수정 된 매개 변수는 현재 minifilter 드라이버의 사후 콜백 루틴이나 minifilter 드라이버 인스턴스 스택의 해당 minifilter 드라이버 위에있는 모든 minifilter 드라이버에서 수신하지 않습니다. 모든 상황에서 미니 필터 드라이버의 사전 작동 및 사후 작동 콜백 루틴은 주어진 I / O 작업에 대해 동일한 입력 매개 변수 값을받습니다.

I / O 조작에 대한 매개 변수를 수정 한 후, 콜백 데이터 구조의 IoStatus 필드 내용을 변경하지 않는 한, Pretion 또는 Postoperation 콜백 루틴은 FltSetCallbackDataDirty를 호출하여이를 수행했음을 나타내야합니다. 그렇지 않으면 필터 관리자는 매개 변수 값의 변경 사항을 무시합니다. FltSetCallbackDataDirty는 I / O 작업에 대한 콜백 데이터 구조에 FLTFL_CALLBACK_DATA_DIRTY 플래그를 설정합니다. Minifilter 드라이버는 FltIsCallbackDataDirty를 호출하여이 플래그를 테스트하거나 FltClearCallbackDataDirty를 호출하여이 플래그를 테스트 할 수 있습니다.

minifilter 드라이버의 preoperation 콜백 루틴이 I / O 작업의 매개 변수를 수정하면 minifilter 드라이버 인스턴스 스택의 해당 minifilter 드라이버 아래에있는 모든 minifilter 드라이버는 Data 및 FltObjects 입력 매개 변수의 수정 된 매개 변수를 해당 작업 전 및 후 작업 콜백 루틴에 전달합니다. (Minifilter 드라이버는 FltObjects 매개 변수가 가리키는 FLT_RELATED_OBJECTS 구조체의 내용을 직접 수정할 수 없지만 미니 파일러 드라이버가 I / O 작업의 대상 인스턴스 또는 대상 파일 객체를 수정하면 필터 관리자는 lower minifilter 드라이버에 전달 된 FLT_RELATED_OBJECTS 구조체의 해당 Instance 또는 FileObject 멤버입니다.

minifilter 드라이버의 preoperation 콜백 루틴이 만드는 매개 변수 변경 사항은 minifilter 드라이버의 자체 작업 콜백 루틴에 의해 수신되지 않지만 preoperation 콜백 루틴은 변경된 매개 변수에 대한 정보를 minifilter 드라이버의 자체 작업 콜백 루틴으로 전달할 수 있습니다. 전처리 콜백 루틴이 FLT_PREOP_SUCCESS_WITH_CALLBACK 또는 FLT_PREOP_SYNCHRONIZE를 반환하여 스택 아래로 I / O 작업을 전달하면 변경된 매개 변수 값에 대한 정보를 CompletionContext 출력 매개 변수가 가리키는 미니 필터 드라이버 정의 구조에 저장할 수 있습니다. 필터 관리자는 CompletionContext 입력 매개 변수에서이 구조 포인터를 사후 콜백 루틴으로 전달합니다.

I / O 연산의 매개 변수에 대한 자세한 내용은 FLT_CALLBACK_DATA 및 FLT_IO_PARAMETER_BLOCK을 참조하십시오.



### I/O 작업을위한 버퍼링 방법 결정

장치 드라이버와 마찬가지로 파일 시스템은 사용자 모드 응용 프로그램과 시스템 장치간에 데이터를 전송합니다. 운영 체제는 데이터 버퍼에 액세스하기 위해 다음 세 가지 방법을 제공합니다.

- 버퍼링 된 I / O에서 I / O 관리자는 비 페이징 풀에서 작업을위한 시스템 버퍼를 할당합니다. I / O 관리자는 I / O 작업을 시작한 스레드의 컨텍스트에서이 시스템 버퍼의 데이터를 응용 프로그램의 사용자 버퍼로 또는 그 반대로 복사합니다.

- 직접 I / O에서 I / O 관리자는 사용자 버퍼를 검색하고 잠급니다. 그런 다음 잠긴 버퍼를 매핑 할 메모리 설명자 목록 (MDL)을 만듭니다. I / O 관리자는 I / O 작업을 시작한 스레드 컨텍스트에서 버퍼에 액세스합니다.

- 버퍼링되거나 직접 I / O가 아닌 경우 I / O 관리자는 시스템 버퍼를 할당하지 않고 사용자 버퍼를 잠 그거나 매핑하지 않습니다. 대신, 그것은 단순히 버퍼의 원래 사용자 공간 가상 주소를 파일 시스템 스택에 전달합니다. 드라이버는 시작 스레드의 컨텍스트에서 실행 중인지와 버퍼 주소가 유효한지 확인해야합니다.

  Minifilter 드라이버는 사용하기 전에 사용자 공간의 주소를 확인해야합니다. I / O 관리자 및 필터 관리자는 이러한 주소의 유효성을 검사하지 않으며 미니 필터 드라이버에 전달되는 버퍼에 포함 된 포인터의 유효성을 검사하지 않습니다.

모든 표준 Microsoft 파일 시스템은 대부분의 I / O 처리에 대해 버퍼링되거나 직접 I / O를 사용하지 않습니다.

버퍼링 메서드에 대한 자세한 내용은 [데이터 버퍼 액세스 메서드](https://msdn.microsoft.com/library/windows/hardware/ff554436)를 참조하십시오.

IRP 기반 I / O 작업의 경우 사용되는 버퍼링 방법은 작업에 따라 다르며 다음 요인에 의해 결정됩니다.

- 수행중인 I / O 작업의 유형
- 파일 시스템 볼륨에 대한 DEVICE_OBJECT 구조체의 Flags 멤버 값
- I / O 제어 (IOCTL) 및 파일 시스템 제어 (FSCTL) 작업의 경우 IOCTL 또는 FSCTL이 정의 될 때 CTL_CODE 매크로에 전달 된 TransferType 매개 변수의 값

버퍼가있는 고속 I / O 작업은 항상 버퍼링되거나 직접 I / O를 사용하지 않습니다.

파일 시스템 콜백 작업에는 버퍼가 없습니다.

이 섹션에는 다음 내용이 포함됩니다.

[IRP 기반 또는 고속 I/O 일 수 있는 작업](https://docs.microsoft.com/ko-kr/windows-hardware/drivers/ifs/operations-that-can-be-irp-based-or-fast-i-o)

[장치 개체 플래그를 따르는 IRP 기반 I / O 작업](https://docs.microsoft.com/ko-kr/windows-hardware/drivers/ifs/irp-based-i-o-operations-that-obey-device-object-flags)

[버퍼 된 I / O를 항상 사용하는 IRP 기반 I / O 작업](https://docs.microsoft.com/ko-kr/windows-hardware/drivers/ifs/irp-based-i-o-operations-that-always-use-buffered-i-o)

[항상 사용되는 IRP 기반 I / O 작업 버퍼 된 직접 I / O](https://docs.microsoft.com/ko-kr/windows-hardware/drivers/ifs/irp-based-i-o-operations-that-always-use-neither-buffered-nor-direct-i)

[IRP 기반 IOCTL 및 FSCTL 작업](https://docs.microsoft.com/ko-kr/windows-hardware/drivers/ifs/irp-based-ioctl-and-fsctl-operations)

[버퍼가없는 IRP 기반 I / O 작업](https://docs.microsoft.com/ko-kr/windows-hardware/drivers/ifs/irp-based-i-o-operations-that-have-no-buffers)



#### <span style="color:blue">IRP 기반 또는 고속 I/O 일 수 있는 작업</span>

다음 유형의 작업은 IRP 기반 또는 고속 I / O 작업 일 수 있습니다.

- IRP_MJ_DEVICE_CONTROL. IRP_MJ_INTERNAL_DEVICE_CONTROL은 항상 IRP 기반입니다.
- IRP_MJ_QUERY_INFORMATION. FileInformationClass 매개 변수가 FileBasicInformation, FileStandardInformation 또는 FileNetworkOpenInformation 인 경우이 작업은 빠른 I / O 일 수 있습니다.
- IRP_MJ_READ. Minifilter 드라이버는 FLT_OPERATION_REGISTRATION 구조체에 FLTFL_OPERATION_REGISTRATION_SKIP_CACHED_IO 플래그를 설정하여 고속 I / O IRP_MJ_READ 연산과 캐시 된 IRP 기반 읽기를 피할 수 있습니다.
- IRP_MJ_WRITE. Minifilter 드라이버는 FLT_OPERATION_REGISTRATION 구조체에 FLTFL_OPERATION_REGISTRATION_SKIP_CACHED_IO 플래그를 설정하여 고속 I / O IRP_MJ_WRITE 작업 및 캐시 된 IRP 기반 쓰기를받지 않도록 할 수 있습니다.

이러한 작업 중 하나가 빠른 I / O 작업 인 경우 해당 IRP 기반 작업이 다른 버퍼링 방법을 사용하는 경우에도 항상 버퍼링 된 I / O 또는 직접 I / O를 사용하지 않습니다.

IRP_MJ_DEVICE_CONTROL이 빠른 I / O 작업 일 때 IOCTL의 전송 유형에 관계없이 항상 버퍼링되거나 직접 I / O를 사용하지 않습니다.

IRP_MJ_LOCK_CONTROL은 IRP 기반 또는 고속 I / O 작업 일 수 있지만 버퍼가 없습니다.



#### <span style="color:blue">장치 개체 플래그를 따르는 IRP 기반 I / O 작업</span>

다음 IRP 기반 I / O 작업에 대한 버퍼링 방법은 파일 시스템 볼륨에 대한 DEVICE_OBJECT 구조의 Flags 멤버 값에 의해 결정됩니다.

- IRP_MJ_DIRECTORY_CONTROL
- IRP_MJ_QUERY_EA
- IRP_MJ_QUERY_QUOTA
- IRP_MJ_READ
- IRP_MJ_SET_EA
- IRP_MJ_SET_QUOTA
- IRP_MJ_WRITE

Flags 멤버의 DO_BUFFERED_IO 및 DO_DIRECT_IO 플래그는 다음과 같이 사용됩니다.

- DO_BUFFERED_IO 플래그가 설정되면 버퍼링 된 I / O가 사용됩니다.
- DO_DIRECT_IO 플래그가 설정되고 DO_BUFFERED_IO 플래그가 설정되지 않은 경우 조작은 직접 입출력을 사용합니다.
- 어느 플래그도 설정되어 있지 않은 경우, 조작은 버퍼링 또는 직접 입출력을 사용하지 않습니다.

장치 개체 플래그에 대한 자세한 내용은 [DEVICE_OBJECT](https://msdn.microsoft.com/library/windows/hardware/ff543147) 및 [장치 개체 초기화](https://msdn.microsoft.com/library/windows/hardware/ff547807)를 참조하십시오.

IRP_MJ_READ 및 IRP_MJ_WRITE는 IRP 기반 또는 빠른 I / O 작업이 될 수 있습니다. IRP 기반 인 경우 버퍼링 방법은 위에서 설명한대로 장치 개체 플래그에 의해 결정됩니다. 이러한 작업이 고속 I / O 일 때 항상 버퍼링되거나 직접 I / O를 사용하지 않습니다. IRP 기반 또는 고속 I / O 작업이 될 수있는 I / O 작업에 대한 자세한 내용은 IRP 기반 또는 고속 I / O 일 수있는 작업을 참조하십시오.



#### <span style="color:blue">버퍼 된 I / O를 항상 사용하는 IRP 기반 I / O 작업</span>

다음 IRP 기반 I / O 작업은 파일 시스템 볼륨에 대한 DEVICE_OBJECT 구조체의 Flags 멤버 값에 관계없이 항상 버퍼링 된 I / O를 사용합니다.

- IRP_MJ_CREATE ([**EaBuffer parameter**](https://msdn.microsoft.com/library/windows/hardware/ff544687))
- IRP_MJ_QUERY_INFORMATION
- IRP_MJ_QUERY_VOLUME_INFORMATION
- IRP_MJ_SET_INFORMATION
- IRP_MJ_SET_VOLUME_INFORMATION

IRP_MJ_QUERY_INFORMATION은 빠른 I / O 작업 일 수도 있습니다. 빠른 I / O 작업 인 경우 버퍼링되거나 직접 I / O를 사용하지 않습니다. IRP 기반 또는 고속 I / O 작업이 될 수있는 I / O 작업에 대한 자세한 내용은 IRP 기반 또는 고속 I / O 일 수있는 작업을 참조하십시오.



#### <span style="color:blue">항상 사용되는 IRP 기반 I / O 작업 버퍼 된 직접 I / O</span>

다음 IRP 기반 I / O 작업은 파일 시스템 볼륨에 대한 DEVICE_OBJECT 구조체의 Flags 멤버 값에 관계없이 항상 버퍼링되거나 직접 I / O를 사용하지 않습니다.

- IRP_MJ_PNP
- IRP_MJ_QUERY_SECURITY
- IRP_MJ_SET_SECURITY
- IRP_MJ_SYSTEM_CONTROL



#### <span style="color:blue">IRP 기반 IOCTL 및 FSCTL 작업</span>

다음 IRP 기반 I / O 작업은 I / O 제어 코드 (IOCTL) 또는 파일 시스템 제어 코드 (FSCTL)의 정의에 지정된 전송 유형과 일치하는 버퍼링 방법을 사용합니다.

- IRP_MJ_DEVICE_CONTROL
- IRP_MJ_FILE_SYSTEM_CONTROL
- IRP_MJ_INTERNAL_DEVICE_CONTROL

전송 유형은 CTL_CODE 매크로의 TransferType 매개 변수에 지정됩니다. 주어진 IOCTL 또는 FSCTL에 대한 전송 유형을 얻으려면 다음 매크로를 사용하십시오.

```c++
#define METHOD_FROM_CTL_CODE(ctrlCode)         ((ULONG)(ctrlCode & 3))
```

이 매크로는 다음 값 중 하나를 반환합니다.

```c++
#define METHOD_BUFFERED                 0
#define METHOD_IN_DIRECT                1
#define METHOD_OUT_DIRECT               2
#define METHOD_NEITHER                  3
```

CTL_CODE 매크로에 대한 자세한 내용은 I / O 제어 코드 정의를 참조하십시오.

IRP_MJ_DEVICE_CONTROL은 빠른 I / O 작업 일 수도 있습니다. 빠른 I / O 작업 인 경우 IOCTL의 전송 유형에 관계없이 항상 버퍼링되거나 직접 I / O를 사용하지 않습니다. IRP_MJ_DEVICE_CONTROL이 빠른 I / O 작업 일 수있는시기에 대한 자세한 내용은 IRP 기반 또는 고속 I / O 일 수있는 작업을 참조하십시오.



#### <span style="color:blue">버퍼가없는 IRP 기반 I / O 작업</span>

다음 IRP 기반 I / O 작업에는 버퍼가 없으므로 버퍼링 방법이 없습니다.

- IRP_MJ_CREATE_MAILSLOT
- IRP_MJ_CREATE_NAMED_PIPE
- IRP_MJ_LOCK_CONTROL





### I/O 작업을위한 사용자 버퍼 액세스

I / O 조작에 대한 [FLT_PARAMETERS](https://msdn.microsoft.com/library/windows/hardware/ff544673) 구조에는 조작에 사용되는 모든 버퍼의 버퍼 주소 메모리 설명자리스트 (MDL)를 포함하여 조작에 대한 조작 특정 매개 변수가 들어 있습니다.

IRP 기반 I / O 작업의 경우 다음을 사용하여 작업 버퍼를 지정할 수 있습니다.

- MDL only (typically for paging I/O)
- Buffer address only
- Buffer address and MDL

고속 I / O 조작의 경우, 사용자 공간 버퍼 주소 만 지정됩니다. 버퍼가있는 고속 I / O 작업은 항상 버퍼링되거나 직접 I / O를 사용하지 않으므로 MDL 매개 변수가 없습니다.

다음 항목에서는 minifilter 드라이버 사전 콜백 루틴 및 사후 콜백 루틴에서 IRP 기반 및 빠른 I / O 작업을위한 버퍼 주소 및 MDL을 처리하기위한 지침을 제공합니다.

[사전 콜백 루틴에서 사용자 버퍼 액세스](https://docs.microsoft.com/ko-kr/windows-hardware/drivers/ifs/accessing-user-buffers-in-a-preoperation-callback-routine)

[사후 콜백 루틴에서 사용자 버퍼 액세스](https://docs.microsoft.com/ko-kr/windows-hardware/drivers/ifs/accessing-user-buffers-in-a-postoperation-callback-routine)



#### <span style="color:blue">사전 콜백 루틴에서 사용자 버퍼 액세스</span>

미니 필터 드라이버의 사전 작업 콜백 루틴은 다음과 같이 IRP 기반 I / O 작업의 버퍼를 처리해야합니다.

- 버퍼에 MDL이 있는지 확인하십시오. MDL 포인터는 작업에 대한 [FLT_PARAMETERS](https://msdn.microsoft.com/library/windows/hardware/ff544673)의 MdlAddress 또는 OutputMdlAddress 매개 변수에서 찾을 수 있습니다. Minifilter 드라이버는 [FltDecodeParameters](https://msdn.microsoft.com/library/windows/hardware/ff541956)를 호출하여 MDL 포인터를 쿼리 할 수 있습니다.

  유효한 MDL을 얻는 한 가지 방법은 콜백 데이터에서 I / O 매개 변수 블록 인 FLT_IO_PARAMETER_BLOCK의 MinorFunction 멤버에있는 IRP_MN_MDL 플래그를 찾는 것입니다. 다음 예제에서는 IRP_MN_MDL 플래그를 확인하는 방법을 보여줍니다.

  ```c++
  NTSTATUS status;
  PMDL *ReadMdl = NULL;
  PVOID ReadAddress = NULL;
  
  if (FlagOn(CallbackData->Iopb->MinorFunction, IRP_MN_MDL))
  {
      ReadMdl = &CallbackData->Iopb->Parameters.Read.MdlAddress;
  }
  ```

  그러나 IRP_MN_MDL 플래그는 읽기 및 쓰기 작업에만 설정할 수 있습니다. 루틴에서는 모든 작업에 대해 유효한 MDL을 확인하기 때문에 FltDecodeParameters를 사용하여 MDL을 검색하는 것이 가장 좋습니다. 다음 예제에서는 유효한 경우 MDL 매개 변수 만 반환됩니다.

  ```c++
  NTSTATUS status;
  PMDL *ReadMdl = NULL;
  PVOID ReadAddress = NULL;
  
  status = FltDecodeParameters(CallbackData, &ReadMdl, NULL, NULL, NULL);
  ```

  

- MDL이 버퍼에 존재하면 MmGetSystemAddressForMdlSafe를 호출하여 버퍼의 시스템 주소를 얻은 다음이 주소를 사용하여 버퍼에 액세스하십시오.

  이전 예제에서 계속 진행하면 다음 코드가 시스템 주소를 가져옵니다.

  ```c++
  if (*ReadMdl != NULL)
  {
      ReadAddress = MmGetSystemAddressForMdlSafe(*ReadMdl, NormalPagePriority);
      if (ReadAddress == NULL)
      {
          CallbackData->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
          CallbackData->IoStatus.Information = 0;
      }
  }
  ```

  

- 버퍼에 MDL이 없으면 버퍼 주소를 사용하여 버퍼에 액세스합니다. 사용자 공간 버퍼 주소가 유효한지 확인하기 위해, 미니 필터 드라이버는 블록을 제외 / 시도의 모든 버퍼 참조를 둘러싸, ProbeForRead 또는 ProbeForWrite와 같은 루틴 등을 사용해야합니다.

사전 작업 콜백 루틴은 다음과 같이 고속 I / O 작업의 버퍼를 처리해야합니다.

- 버퍼 주소를 사용하여 버퍼에 액세스하십시오 (빠른 I / O 작업에는 MDL이 없어서).
- 사용자 공간 버퍼 주소가 유효한지 확인하기 위해, 미니 필터 드라이버는 블록을 제외 / 시도의 모든 버퍼 참조를 둘러싸, ProbeForRead 또는 ProbeForWrite와 같은 루틴 등을 사용해야합니다.

고속 I / O 또는 IRP 기반 일 수있는 작업의 경우 모든 버퍼 참조는 try / except 블록으로 묶어야합니다. 버퍼링 된 I / O를 사용하는 IRP 기반 작업에 대해 이러한 참조를 묶을 필요는 없지만 try / except 블록은 안전한 예방 조치입니다.



#### <span style="color:blue">사후 콜백 루틴에서 사용자 버퍼 액세스</span>

미니 필터 드라이버 사후 콜백 루틴은 다음과 같이 IRP 기반 I / O 작업에서 버퍼를 처리해야합니다.

- 버퍼에 MDL이 있는지 확인하십시오. MDL 포인터는 작업에 대한 FLT_PARAMETERS의 MdlAddress 또는 OutputMdlAddress 매개 변수에서 찾을 수 있습니다. Minifilter 드라이버는 FltDecodeParameters를 호출하여 MDL 포인터를 쿼리 할 수 있습니다.

  유효한 MDL을 얻는 한 가지 방법은 콜백 데이터에서 I / O 매개 변수 블록 인 FLT_IO_PARAMETER_BLOCK의 MinorFunction 멤버에있는 IRP_MN_MDL 플래그를 찾는 것입니다. 다음 예제에서는 IRP_MN_MDL 플래그를 확인하는 방법을 보여줍니다.

  ```c++
  NTSTATUS status;
  PMDL *ReadMdl = NULL;
  PVOID ReadAddress = NULL;
  
  if (FlagOn(CallbackData->Iopb->MinorFunction, IRP_MN_MDL))
  {
      ReadMdl = &CallbackData->Iopb->Parameters.Read.MdlAddress;
  }
  ```

  그러나 IRP_MN_MDL 플래그는 읽기 및 쓰기 작업에만 설정할 수 있습니다. 루틴에서는 모든 작업에 대해 유효한 MDL을 확인하기 때문에 FltDecodeParameters를 사용하여 MDL을 검색하는 것이 가장 좋습니다. 다음 예제에서는 유효한 경우 MDL 매개 변수 만 반환됩니다.

  ```c++
  NTSTATUS status;
  PMDL *ReadMdl = NULL;
  PVOID ReadAddress = NULL;
  
  status = FltDecodeParameters(CallbackData, &ReadMdl, NULL, NULL, NULL);
  ```

  

- MDL이 버퍼에 존재하면 MmGetSystemAddressForMdlSafe를 호출하여 버퍼의 시스템 주소를 얻은 다음이 주소를 사용하여 버퍼에 액세스하십시오. (MmGetSystemAddressForMdlSafe는 IRQL &lt;= DISPATCH_LEVEL에서 호출 할 수 있습니다.)

  이전 예제에서 계속 진행하면 다음 코드가 시스템 주소를 가져옵니다.

  ```c++
  if (*ReadMdl != NULL)
  {
      ReadAddress = MmGetSystemAddressForMdlSafe(*ReadMdl, NormalPagePriority);
      if (ReadAddress == NULL)
      {
          CallbackData->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
          CallbackData->IoStatus.Information = 0;
      }
  }
  ```

  

- 버퍼에 MDL이 없으면 [FLT_IS_SYSTEM_BUFFER](https://msdn.microsoft.com/library/windows/hardware/ff544663) 매크로를 사용하여 작업에 시스템 버퍼 플래그가 설정되어 있는지 확인하십시오.

  - FLT_IS_SYSTEM_BUFFER 매크로가 TRUE를 반환하면 버퍼링 된 I / O가 연산에 사용되며 버퍼는 IRQL = DISPATCH_LEVEL에서 안전하게 액세스 할 수 있습니다.
  - FLT_IS_SYSTEM_BUFFER 매크로가 FALSE를 반환하면 IRQL = DISPATCH_LEVEL에서 버퍼에 안전하게 액세스 할 수 없습니다. 후 작업 콜백 루틴을 DISPATCH_LEVEL에서 호출 할 수 있으면 FltDoCompletionProcessingWhenSafe를 호출하여 IRQL &lt;= APC_LEVEL에서 처리 할 수있을 때까지 작업을 보류해야합니다. FltDoCompletionProcessingWhenSafe의 SafePostCallback 매개 변수가 가리키는 콜백 루틴은 먼저 FltLockUserBuffer를 호출하여 버퍼를 잠그고 MmGetSystemAddressForMdlSafe를 호출하여 버퍼의 시스템 주소를 가져와야합니다.

사후 콜백 루틴은 다음과 같이 빠른 I / O 작업에서 버퍼를 처리해야합니다.

- 버퍼 주소를 사용하여 버퍼에 액세스하십시오 (빠른 I / O 작업에는 MDL이 없어서).
- 사용자 공간 버퍼 주소가 유효한지 확인하기 위해, 미니 필터 드라이버는 블록을 제외 / 시도의 모든 버퍼 참조를 둘러싸, ProbeForRead 또는 ProbeForWrite와 같은 루틴 등을 사용해야합니다.
- 빠른 I / O 작업을위한 사후 콜백 루틴은 올바른 스레드 컨텍스트에서 호출되도록 보장됩니다.
- 빠른 I / O 작업을위한 작업 콜백 루틴은 IRQL &lt;= APC_LEVEL에서 호출되도록 보장되므로 FltLockUserBuffer와 같은 루틴을 안전하게 호출 할 수 있습니다.

다음 예제 코드 단편은 디렉토리 제어 조작에 대한 시스템 버퍼 또는 고속 입출력 플래그를 점검하고 필요한 경우 완료 처리를 지연시킵니다.

```c++
if (*DirectoryControlMdl == NULL)
{
    if (FLT_IS_SYSTEM_BUFFER(CallbackData) || FLT_IS_FASTIO_OPERATION(CallbackData))
    {
        dirBuffer = CallbackData->Iopb->Parameters.DirectoryControl.QueryDirectory.DirectoryBuffer;
    }
    else
    {
        // Defer processing until safe.
        if (!FltDoCompletionProcessingWhenSafe(CallbackData, FltObjects, CompletionContext, Flags, ProcessPostDirCtrlWhenSafe, &retValue))
        {
            CallbackData->IoStatus.Status = STATUS_UNSUCCESSFUL;
            CallbackData->IoStatus.Information = 0;
        }
    }
}
```

고속 I / O 또는 IRP 기반 일 수있는 작업의 경우 모든 버퍼 참조는 try / except 블록으로 묶어야합니다. 버퍼링 된 I / O를 사용하는 IRP 기반 작업에 대해 이러한 참조를 묶을 필요는 없지만 try / except 블록은 안전한 예방 조치입니다.



## <span style="color:blue">미니 필터 드라이버에서 컨텍스트 관리</span>

컨텍스트는 minifilter 드라이버에 의해 정의되고 필터 관리자 객체와 연관 될 수있는 구조입니다. Minifilter 드라이버는 다음 개체에 대한 컨텍스트를 만들고 설정할 수 있습니다.

- Files (Windows Vista and later only.)
- Instances
- Volumes
- Streams
- Stream handles (file objects)
- Transactions (Windows Vista and later only.)

비 페이징 풀에서 할당해야하는 볼륨 컨텍스트를 제외하고 컨텍스트는 페이징되거나 비 페이징 된 풀에서 할당 될 수 있습니다.

필터 관리자는 첨부 된 객체가 삭제되거나, minifilter 드라이버 인스턴스가 볼륨에서 분리되거나, minifilter 드라이버가 언로드 될 때 컨텍스트를 자동으로 삭제합니다.

이 섹션에는 다음 내용이 포함됩니다.

[Context Types 등록](https://docs.microsoft.com/ko-kr/windows-hardware/drivers/ifs/registering-context-types)

[Contexts 생성](https://docs.microsoft.com/ko-kr/windows-hardware/drivers/ifs/creating-contexts)

[Contexts 설정](https://docs.microsoft.com/ko-kr/windows-hardware/drivers/ifs/setting-contexts)

[Contexts 취득](https://docs.microsoft.com/ko-kr/windows-hardware/drivers/ifs/getting-contexts)

[Contexts 참조](https://docs.microsoft.com/ko-kr/windows-hardware/drivers/ifs/referencing-contexts)

[Contexts 해제](https://docs.microsoft.com/ko-kr/windows-hardware/drivers/ifs/releasing-contexts)

[Contexts 삭제](https://docs.microsoft.com/ko-kr/windows-hardware/drivers/ifs/deleting-contexts)

[Freeing Contexts](https://docs.microsoft.com/ko-kr/windows-hardware/drivers/ifs/freeing-contexts)

[컨텍스트에 대한 파일 시스템 지원](https://docs.microsoft.com/ko-kr/windows-hardware/drivers/ifs/file-system-support-for-contexts)

[모범 사례](https://docs.microsoft.com/ko-kr/windows-hardware/drivers/ifs/best-practices)



### Context Types 등록

미니 필터 드라이버가 [DriverEntry](https://msdn.microsoft.com/library/windows/hardware/ff544113) 루틴에서 [FltRegisterFilter](https://msdn.microsoft.com/library/windows/hardware/ff544305)를 호출하면 사용하는 각 컨텍스트 유형을 등록해야합니다.

컨텍스트 유형을 등록하기 위해 minifilter 드라이버는 [FLT_CONTEXT_REGISTRATION](https://msdn.microsoft.com/library/windows/hardware/ff544629) 구조체의 가변 길이 배열을 만들고 Minifilter 드라이버가 [FltRegisterFilter](https://msdn.microsoft.com/library/windows/hardware/ff544305) 의 Registration 매개 변수에 전달하는 [FLT_REGISTRATION](https://msdn.microsoft.com/library/windows/hardware/ff544811) 구조체의 ContextRegistration 멤버에 배열에 대한 포인터를 저장합니다. 이 배열의 요소 순서는 중요하지 않습니다. 그러나 배열의 마지막 요소는 {FLT_CONTEXT_END} 여야합니다.

미니 필터 드라이버가 사용하는 각 컨텍스트 유형에 대해 적어도 하나의 컨텍스트 정의를 FLT_CONTEXT_REGISTRATION 구조 형식으로 제공해야합니다. 각 FLT_CONTEXT_REGISTRATION 구조체는 컨텍스트의 유형, 크기 및 기타 정보를 정의합니다.

미니 필터 드라이버가 FltAllocateContext를 호출하여 새 컨텍스트를 만들면 필터 관리자는 [FltAllocateContext](https://msdn.microsoft.com/library/windows/hardware/ff541710) 루틴의 Size 매개 변수와 FLT_CONTEXT_REGISTRATION 구조의 Size 및 Flags 멤버를 사용하여 사용할 컨텍스트 정의를 선택합니다.

고정 크기 컨텍스트의 경우 FLT_CONTEXT_REGISTRATION 구조체의 Size 멤버는 minifilter 드라이버가 정의한 컨텍스트 구조 부분의 크기를 바이트 단위로 지정합니다. 컨텍스트의 최대 크기는 MAXUSHORT (64KB)입니다. 0은 유효한 크기 값입니다. 필터 관리자는 lookaside 목록을 사용하여 고정 된 크기의 컨텍스트를 구현합니다. 필터 관리자는 각 크기 값에 대해 두 개의 lookaside 목록을 만듭니다. 하나는 페이지 된 페이지이고 다른 하나는 페이지가 아닌 페이지입니다.

가변 크기 컨텍스트의 경우 Size 멤버를 FLT_VARIABLE_SIZED_CONTEXTS로 설정해야합니다. 필터 관리자는 페이징되거나 비 페이징 된 풀에서 직접 가변 크기 컨텍스트를 할당합니다.

FLT_CONTEXT_REGISTRATION 구조체의 Flags 멤버에서 FLTFL_CONTEXT_REGISTRATION_NO_EXACT_SIZE_MATCH 플래그를 지정할 수 있습니다. 미니 필터 드라이버가 고정 크기 컨텍스트를 사용하고이 플래그가 지정되면 필터 관리자는 컨텍스트의 크기가 요청한 크기보다 크거나 같으면 lookaside 목록의 컨텍스트를 할당합니다. 그렇지 않은 경우 컨텍스트의 크기는 요청한 크기와 같아야합니다.

주어진 컨텍스트 유형에 대해 minifilter 드라이버는 크기가 다른 고정 크기 컨텍스트 정의를 3 개까지 제공 할 수 있으며 하나의 가변 크기 정의를 제공 할 수 있습니다. 자세한 내용은 [FLT_CONTEXT_REGISTRATION](https://msdn.microsoft.com/library/windows/hardware/ff544629)을 참조하십시오.

minifilter 드라이버는 선택적으로 컨텍스트가 해제되기 전에 호출 될 컨텍스트 정리 콜백 루틴을 제공 할 수 있습니다. 자세한 내용은 [PFLT_CONTEXT_CLEANUP_CALLBACK](https://msdn.microsoft.com/library/windows/hardware/ff551078)을 참조하십시오.

미니 필터 드라이버는 이러한 작업을 수행하기 위해 필터 관리자를 사용하는 대신 컨텍스트 할당 및 해제를 위해 자체 콜백 루틴을 선택적으로 정의 할 수 있습니다. 그러나 이것은 거의 필요하지 않습니다. 자세한 내용은 [PFLT_CONTEXT_ALLOCATE_CALLBACK](https://msdn.microsoft.com/library/windows/hardware/ff551075) 및 [PFLT_CONTEXT_FREE_CALLBACK](https://msdn.microsoft.com/library/windows/hardware/ff551082) 을 참조하십시오.

CTX 샘플 미니 필터 드라이버에서 가져온 다음 코드 예제는 인스턴스, 파일, 스트림 및 파일 객체 (스트림 핸들) 컨텍스트를 등록하는 데 사용되는 FLT_CONTEXT_REGISTRATION 구조의 배열을 보여줍니다.

```c++
const FLT_CONTEXT_REGISTRATION contextRegistration[] =
{
    { FLT_INSTANCE_CONTEXT,              //ContextType
      0,                                 //Flags
      CtxContextCleanup,                 //ContextCleanupCallback
      CTX_INSTANCE_CONTEXT_SIZE,         //Size
      CTX_INSTANCE_CONTEXT_TAG           //PoolTag
    },
    { FLT_FILE_CONTEXT,                  //ContextType
      0,                                 //Flags
      CtxContextCleanup,                 //ContextCleanupCallback
      CTX_FILE_CONTEXT_SIZE,             //Size
      CTX_FILE_CONTEXT_TAG               //PoolTag
    },
    { FLT_STREAM_CONTEXT,                //ContextType
      0,                                 //Flags
      CtxContextCleanup,                 //ContextCleanupCallback
      CTX_STREAM_CONTEXT_SIZE,           //Size
      CTX_STREAM_CONTEXT_TAG             //PoolTag
    },
    { FLT_STREAMHANDLE_CONTEXT,          //ContextType
      0,                                 //Flags
      CtxContextCleanup,                 //ContextCleanupCallback
      CTX_STREAMHANDLE_CONTEXT_SIZE,     //Size
      CTX_STREAMHANDLE_CONTEXT_TAG       //PoolTag
    },
    { FLT_CONTEXT_END }
};
```



### Contexts 생성

미니 필터 드라이버가 사용하는 컨텍스트 유형을 등록하면 [FltAllocateContext](https://msdn.microsoft.com/library/windows/hardware/ff541710)를 호출하여 컨텍스트를 만들 수 있습니다. 이 루틴은 [컨텍스트 유형 등록](https://docs.microsoft.com/ko-kr/windows-hardware/drivers/ifs/registering-context-types)에 설명 된 기준에 따라 사용할 적절한 컨텍스트 정의를 선택합니다.

CTX 샘플 미니 필터 드라이버에서 가져온 다음 코드 예제에서 CtxInstanceSetup 루틴은 [FltAllocateContext](https://msdn.microsoft.com/library/windows/hardware/ff541710)를 호출하여 인스턴스 컨텍스트를 만듭니다.

```c++
status = FltAllocateContext(
 FltObjects->Filter,           //Filter
           FLT_INSTANCE_CONTEXT,         //ContextType
           CTX_INSTANCE_CONTEXT_SIZE,    //ContextSize
 NonPagedPool,                 //PoolType
           &instanceContext);            //ReturnedContext
```

CTX 샘플에서 인스턴스 컨텍스트에 대해 다음 컨텍스트 정의가 등록됩니다.

```c++
{ FLT_INSTANCE_CONTEXT,              //ContextType
  0,                                 //Flags
 CtxContextCleanup,                 //ContextCleanupCallback
  CTX_INSTANCE_CONTEXT_SIZE,         //Size
  CTX_INSTANCE_CONTEXT_TAG },        //PoolTag
```

Size 멤버가 상수이므로 고정 크기 컨텍스트 정의입니다. Size 멤버가 FLT_VARIABLE_SIZED_CONTEXTS 인 경우 가변 크기 컨텍스트 정의입니다. FLTFL_CONTEXT_REGISTRATION_NO_EXACT_SIZE_MATCH 플래그가 Flags 멤버에 설정되어 있지 않습니다. 이 경우, [FltAllocateContext](https://msdn.microsoft.com/library/windows/hardware/ff541710)의 Size 매개 변수의 값이 컨텍스트 정의의 Size 멤버의 값과 일치하면 FltAllocateContext는 해당 비 페이징 된 lookaside 목록의 인스턴스 컨텍스트를 할당합니다. 값이 일치하지 않으면 FltAllocateContext가 실패하고 반환 값은 STATUS_FLT_CONTEXT_ALLOCATION_NOT_FOUND입니다.

[FltAllocateContext](https://msdn.microsoft.com/library/windows/hardware/ff541710)는 새 컨텍스트의 참조 카운트를 1로 초기화합니다. 컨텍스트가 더 이상 필요하지 않으면 minifilter 드라이버는이 참조를 해제해야합니다. 따라서, FltAllocateContext에 대한 모든 호출은 [FltReleaseContext](https://msdn.microsoft.com/library/windows/hardware/ff544314)에 대한 후속 호출과 일치해야합니다.



### Contexts 설정

새 컨텍스트를 만든 후 미니 필터 드라이버는 FltSetXxxContext를 호출하여 개체에 연결할 수 있습니다. 여기서 Xxx는 컨텍스트 유형입니다.

FltSetXxxContext 루틴의 Operation 매개 변수가 FLT_SET_CONTEXT_KEEP_IF_EXISTS로 설정되면 FltSetXxxContext는 minifilter 드라이버가 개체에 대한 컨텍스트를 아직 설정하지 않은 경우에만 새로 할당 된 컨텍스트를 개체에 연결합니다. 미니 필터 드라이버가 이미 컨텍스트를 설정 한 경우 FltSetXxxContext는 NTSTATUS 오류 코드 인 STATUS_FLT_CONTEXT_ALREADY_DEFINED를 반환하고 기존 컨텍스트를 대체하지 않습니다. FltSetXxxContext 루틴의 OldContext 매개 변수가 NULL이 아닌 경우 기존 컨텍스트에 대한 포인터를 수신합니다. 이 포인터가 더 이상 필요하지 않으면 minifilter 드라이버는 [FltReleaseContext](https://msdn.microsoft.com/library/windows/hardware/ff544314)를 호출하여 포인터를 놓아야합니다.

Operation 매개 변수가 FLT_SET_CONTEXT_REPLACE_IF_EXISTS로 설정된 경우 FltSetXxxContext는 항상 새 컨텍스트를 개체에 연결합니다. 미니 필터 드라이버가 컨텍스트를 이미 설정 한 경우 FltSetXxxContext는 기존 컨텍스트를 삭제하고 새 컨텍스트를 설정하며 새 컨텍스트에 대한 참조 카운트를 증가시킵니다. OldContext 매개 변수가 NULL이 아닌 경우 삭제 된 컨텍스트에 대한 포인터를받습니다. 이 포인터가 더 이상 필요하지 않으면 minifilter 드라이버는 FltReleaseContext를 호출하여 포인터를 놓아야합니다.

CTx 샘플 미니 필터 드라이버에서 가져온 다음 코드 예제에서 CtxInstanceSetup 루틴은 인스턴스 컨텍스트를 만들고 설정합니다.

```c++
status = FltAllocateContext(
           FltObjects->Filter,           //Filter
           FLT_INSTANCE_CONTEXT,         //ContextType
           CTX_INSTANCE_CONTEXT_SIZE,    //ContextSize
           NonPagedPool,                 //PoolType
           &instanceContext);            //ReturnedContext
...
status = FltSetInstanceContext(
           FltObjects->Instance,              //Instance
           FLT_SET_CONTEXT_KEEP_IF_EXISTS,    //Operation
           instanceContext,                   //NewContext
           NULL);                             //OldContext

if (instanceContext != NULL) {
  FltReleaseContext(instanceContext);
}
return status;
```

[FltSetInstanceContext](https://msdn.microsoft.com/library/windows/hardware/ff544521) 호출 후 FltReleaseContext를 호출하여 [FltAllocateContext ](https://msdn.microsoft.com/library/windows/hardware/ff541710)(FltSetInstanceContext 아님)에 의해 설정된 참조 횟수를 해제합니다. 이에 대해서는 [컨텍스트 해제](https://docs.microsoft.com/ko-kr/windows-hardware/drivers/ifs/releasing-contexts)에서 설명합니다.



### Contexts 취득

미니 필터 드라이버가 객체에 대한 컨텍스트를 설정하면 FltGetXxxContext를 호출하여 컨텍스트를 가져올 수 있습니다. 여기서 Xxx는 컨텍스트 유형입니다.

다음 코드 예제에서는 SwapBuffers 샘플 미니 필터 드라이버에서 가져온 minifilter 드라이버가 [FltGetVolumeContext](https://msdn.microsoft.com/library/windows/hardware/ff543189)를 호출하여 볼륨 컨텍스트를 가져옵니다.

```c++
status = FltGetVolumeContext(
 FltObjects->Filter,    //Filter
 FltObjects->Volume,    //Volume
                &volCtx);              //Context
...
if (volCtx != NULL) {
 FltReleaseContext(volCtx);
}
```

[FltGetVolumeContext](https://msdn.microsoft.com/library/windows/hardware/ff543189)에 대한 호출이 성공하면 Context 매개 변수는 호출자의 볼륨 컨텍스트의 주소를받습니다. FltGetVolumeContext는 컨텍스트 포인터의 참조 카운트를 증가시킵니다. 따라서이 포인터가 더 이상 필요하지 않으면 minifilter 드라이버는 [FltReleaseContext](https://msdn.microsoft.com/library/windows/hardware/ff544314)를 호출하여 포인터를 해제해야합니다.



### Contexts 참조

필터 관리자는 참조 카운팅을 사용하여 미니 필터 드라이버 컨텍스트의 수명을 관리합니다. 참조 횟수는 컨텍스트의 상태를 나타내는 숫자입니다. 컨텍스트가 생성 될 때마다 컨텍스트의 참조 카운트가 1로 초기화됩니다 (컨텍스트에 대한 초기 참조라고 함). 컨텍스트가 시스템 구성 요소에 의해 참조 될 때마다 컨텍스트의 참조 카운트가 1 씩 증가합니다. 컨텍스트가 더 이상 필요하지 않으면 참조 카운트가 감소합니다. 양의 참조 카운트는 컨텍스트를 사용할 수 있음을 의미합니다. 참조 횟수가 0이되면 컨텍스트를 사용할 수 없으므로 결국 필터 관리자가이를 해제합니다.

컨텍스트에 대한 초기 참조는 일반적으로 객체가 해체 될 때 해제됩니다. 그러나 미니 필터 드라이버가 개체에서 컨텍스트를 제거해야하는 경우 minifilter 드라이버는 어쨌든 컨텍스트에 대한 초기 참조를 해제해야합니다. 문맥에 대한 초기 참조를 안전하게 릴리스하기 위해 minifilter 드라이버는 [FltDeleteContext](https://msdn.microsoft.com/library/windows/hardware/ff541960)를 호출합니다.

미니 필터 드라이버는 [FltReferenceContext](https://msdn.microsoft.com/library/windows/hardware/ff544291)를 호출하여 컨텍스트에 참조를 추가하여 컨텍스트의 참조 카운트를 증가시킬 수 있습니다. 이 추가 된 참조는 결국 [FltReleaseContext](https://msdn.microsoft.com/library/windows/hardware/ff544314)를 호출하여 제거해야합니다.



### Release Contexts

미니 필터 드라이버는 FltReleaseContext를 호출하여 컨텍스트를 해제합니다. 다음 루틴 중 하나에 대한 모든 성공적인 호출은 결국 FltReleaseContext에 대한 호출과 일치해야합니다.

[**FltAllocateContext**](https://msdn.microsoft.com/library/windows/hardware/ff541710)

[**FltGetInstanceContext**](https://msdn.microsoft.com/library/windows/hardware/ff543058)

[**FltGetFileContext**](https://msdn.microsoft.com/library/windows/hardware/ff543025)

[**FltGetStreamContext**](https://msdn.microsoft.com/library/windows/hardware/ff543144)

[**FltGetStreamHandleContext**](https://msdn.microsoft.com/library/windows/hardware/ff543155)

[**FltGetTransactionContext**](https://msdn.microsoft.com/library/windows/hardware/ff543175)

[**FltGetVolumeContext**](https://msdn.microsoft.com/library/windows/hardware/ff543189)

[**FltReferenceContext**](https://msdn.microsoft.com/library/windows/hardware/ff544291)

FltSetXxxContext에 의해 반환 된 OldContext 포인터와 [FltDeleteContext](https://msdn.microsoft.com/library/windows/hardware/ff544314)에 의해 반환 된 Context 포인터는 더 이상 필요하지 않을 때 해제되어야합니다.

```c++
status = FltAllocateContext(
           FltObjects->Filter,           //Filter
           FLT_INSTANCE_CONTEXT,         //ContextType
           CTX_INSTANCE_CONTEXT_SIZE,    //ContextSize
           NonPagedPool,                 //PoolType
           &instanceContext);            //ReturnedContext
...
status = FltSetInstanceContext(
           FltObjects->Instance,              //Instance
           FLT_SET_CONTEXT_KEEP_IF_EXISTS,    //Operation
           instanceContext,                   //NewContext
           NULL);                             //OldContext

if (instanceContext != NULL) {
  FltReleaseContext(instanceContext);
}
return status;
```

[FltReleaseContext](https://msdn.microsoft.com/library/windows/hardware/ff544314)는 FltSetInstanceContext에 대한 호출 성공 여부와 상관없이 호출됩니다. 두 경우 모두 호출자는 [FltReleaseContext](https://msdn.microsoft.com/library/windows/hardware/ff544521)를 호출하여 [FltAllocateContext](https://msdn.microsoft.com/library/windows/hardware/ff541710) (FltSetInstanceContext 아님)에 의해 설정된 참조를 해제해야합니다.

컨텍스트가 인스턴스에 대해 성공적으로 설정되면 [FltSetInstanceContext](https://msdn.microsoft.com/library/windows/hardware/ff544521)는 인스턴스 컨텍스트에 대한 자체 참조를 추가합니다. 따라서 [FltAllocateContext](https://msdn.microsoft.com/library/windows/hardware/ff541710)로 설정된 참조는 더 이상 필요하지 않으며 [FltReleaseContext](https://msdn.microsoft.com/library/windows/hardware/ff544314)를 호출하면 제거됩니다.

[FltSetInstanceContext](https://msdn.microsoft.com/library/windows/hardware/ff544521)에 대한 호출이 실패하면 인스턴스 컨텍스트에는 참조 (즉, [FltAllocateContext](https://msdn.microsoft.com/library/windows/hardware/ff541710)에 의해 설정된 참조)가 하나만 있습니다. [FltReleaseContext](https://msdn.microsoft.com/library/windows/hardware/ff544314)가 반환되면 인스턴스 컨텍스트는 참조 카운트가 0이고 필터 관리자에 의해 해제됩니다.



### Contexts 삭제

FltSetXxxContext를 성공적으로 호출하여 설정된 모든 컨텍스트는 결국 삭제되어야합니다. 그러나 필터 관리자는 첨부 된 개체가 삭제 될 때, 미니 필터 드라이버 인스턴스가 볼륨에서 분리 될 때 또는 미니 필터 드라이버가 언로드 될 때 컨텍스트를 자동으로 삭제합니다. 따라서 미니 필터 드라이버가 컨텍스트를 명시 적으로 삭제할 필요는 거의 없습니다.

미니 필터 드라이버는 FltDeleteXxxContext를 호출하여 컨텍스트를 삭제할 수 있습니다. 여기서 Xxx는 컨텍스트 유형이거나 [FltDeleteContext](https://msdn.microsoft.com/library/windows/hardware/ff541960)를 호출하여 컨텍스트를 삭제할 수 있습니다.

컨텍스트는 현재 개체에 대해 설정된 경우에만 삭제할 수 있습니다. 컨텍스트는 아직 설정되지 않았거나 이미 FltSetXxxContext에 대한 호출로 대체 된 경우 삭제할 수 없습니다.

FltDeleteXxxContext에 대한 호출에서 이전 컨텍스트는 NULL이 아닌 경우 OldContext 매개 변수에 반환됩니다. OldContext 매개 변수가 NULL이면 필터 관리자는 컨텍스트에서 참조 카운트를 감소시키고 minif 드라이버에 미해결 참조가없는 한 해제합니다.

다음 코드 예제에서는 스트림 컨텍스트를 삭제하는 방법을 보여줍니다.

```c++
status = FltDeleteStreamContext(
 FltObjects->Instance,      //Instance
 FltObjects->FileObject,    //FileObject
           &oldContext);              //OldContext
...
if (oldContext != NULL) {
 FltReleaseContext(oldContext);
}
```

이 예에서는 [FltDeleteStreamContext](https://msdn.microsoft.com/library/windows/hardware/ff541997)가 스트림 컨텍스트를 스트림에서 제거하지만 OldContext 매개 변수가 NULL이 아니기 때문에 컨텍스트의 참조 횟수를 감소시키지 않습니다. FltDeleteStreamContext는 OldContext 매개 변수에서 삭제 된 컨텍스트의 주소를 반환합니다. 필요한 처리를 실행 한 후에는 호출자가 FltReleaseContext를 호출하여 삭제 된 컨텍스트를 릴리스해야합니다.



### Freeing Contexts

컨텍스트는 삭제되고 컨텍스트에 대한 모든 미결 참조가 해제 된 후에 해제됩니다.

이 규칙에는 한 가지 예외가 있습니다. 콘텍스트가 생성되었지만 FltSetXxxContext를 호출하여 설정되지 않은 경우에는 삭제할 필요가 없습니다. 참조 횟수가 0에 도달하면 해제됩니다. 자세한 내용은 [컨텍스트 해제](https://docs.microsoft.com/ko-kr/windows-hardware/drivers/ifs/releasing-contexts)의 코드 예제를 참조하십시오.

미니 필터 드라이버가 컨텍스트 유형을 등록 할 때 각 컨텍스트 정의에는 선택적으로 컨텍스트를 해제하기 전에 호출 할 컨텍스트 정리 콜백 루틴이 포함될 수 있습니다. 자세한 내용은 [PFLT_CONTEXT_CLEANUP_CALLBACK](https://msdn.microsoft.com/library/windows/hardware/ff551078)을 참조하십시오.



### 컨텍스트에 대한 파일 시스템 지원

파일 컨텍스트 (적용 가능한 경우), 스트림 컨텍스트 및 파일 개체 (스트림 핸들) 컨텍스트를 지원하려면 파일 시스템이 [FSRTL_ADVANCED_FCB_HEADER](https://msdn.microsoft.com/library/windows/hardware/ff547334) 구조를 사용해야합니다. 모든 Microsoft Windows 파일 시스템은이 구조를 사용하며 모든 타사 파일 시스템 개발자도이 구조를 사용하는 것이 좋습니다. 자세한 내용은 [FsRtlSetupAdvancedHeader](https://msdn.microsoft.com/library/windows/hardware/ff547257) 및 FSRTL_ADVANCED_FCB_HEADER를 참조하십시오.

NTFS 및 FAT 파일 시스템은 페이징 파일, 미리 만들기 또는 닫힌 경로 또는 [IRP_MJ_NETWORK_QUERY_OPEN](https://msdn.microsoft.com/library/windows/hardware/ff544731) 작업의 파일, 스트림 또는 파일 개체 컨텍스트를 지원하지 않습니다.

미니 필터 드라이버는 파일 시스템이 각각 [FltSupportsStreamContexts](https://msdn.microsoft.com/library/windows/hardware/ff544581) 및 [FltSupportsStreamHandleContexts](https://msdn.microsoft.com/library/windows/hardware/ff544586)를 호출하여 지정된 파일 객체 스트림 컨텍스트 및 파일 객체의 컨텍스트를 지원하는지 여부를 확인할 수 있습니다.

파일 컨텍스트는 Windows Vista 이상에서 사용할 수 있습니다.

파일 당 단일 데이터 스트림 만 지원하는 파일 시스템 (예 : FAT)의 경우 파일 컨텍스트는 스트림 컨텍스트와 같습니다. 이러한 파일 시스템은 일반적으로 스트림 컨텍스트를 지원하지만 파일 컨텍스트를 지원하지 않습니다. 대신 필터 관리자는 스트림 컨텍스트에 대한 파일 시스템의 기존 지원을 사용하여이 지원을 제공합니다. 이러한 파일 시스템에 연결된 minifilter 드라이버 인스턴스의 경우 [FltSupportsFileContexts](https://msdn.microsoft.com/library/windows/hardware/ff544574)는 FALSE를 반환하고 [FltSupportsFileContextsEx](https://msdn.microsoft.com/library/windows/hardware/ff544576)는 TRUE를 반환합니다 (유효한 NULL이 아닌 값이 Instance 매개 변수에 전달되는 경우).

파일 컨텍스트를 지원하려면 파일 시스템이 다음을 수행해야합니다.

- 파일 컨텍스트 구조 (일반적으로 파일 컨텍스트 블록 (FCB))에 PVOID 형식의 FileContextSupportPointer 멤버를 포함합니다. 파일 시스템은이 멤버를 NULL로 초기화해야합니다.
- FsRtlSetupAdvancedHeaderEx ([FsRtlSetupAdvancedHeader](https://msdn.microsoft.com/library/windows/hardware/ff547257) 대신)를 사용하여 스트림 컨텍스트 구조를 초기화하고 FileContextSupportPointer 매개 변수에 대한 유효한 파일 컨텍스트 구조에 포함 된 FileContextSupportPointer 멤버에 유효한 포인터를 전달합니다. 자세한 내용은 FsRtlSetupAdvancedHeaderEx 및 [FSRTL_ADVANCED_FCB_HEADER](https://msdn.microsoft.com/library/windows/hardware/ff547334)를 참조하십시오.
- FsRtlTeardownPerFileContexts를 호출하여 파일 시스템이 파일의 파일 컨텍스트 구조를 삭제할 때 파일과 관련된 필터 및 미니 필터 드라이버의 모든 파일 컨텍스트 구조를 해제합니다.



### 모범 사례

미니 필터 드라이버가 볼륨 당 minifilter 드라이버 인스턴스를 하나만 만들면 더 나은 성능을 위해 <span style="color:red">**볼륨 컨텍스트가 아닌 인스턴스 컨텍스트**</span>를 사용해야합니다.

<span style="color:red">**미니 필터 드라이버는 스트림 또는 스트림 핸들 컨텍스트 내에 미니 필터 드라이버 인스턴스 컨텍스트에 대한 포인터를 저장**</span>하여 성능을 향상시킬 수도 있습니다.



## <span style="color:blue">기타 정보</span>

**Microsoft SIte 에는 Link 정보가 잘못되어 있어 바꿈**

이 섹션에는 미니 필터 개발과 관련된 추가 정보가 포함되어 있습니다.

이 섹션에는 다음 내용이 포함됩니다.

[Windows 컨테이너 용 안티 바이러스 최적화](https://docs.microsoft.com/ko-kr/windows-hardware/drivers/ifs/anti-virus-optimization-for-windows-containers)

[오프로드 된 데이터 전송](https://docs.microsoft.com/ko-kr/windows-hardware/drivers/ifs/offloaded-data-transfers)

[디스크 이미지를 올바르게 찾기](https://docs.microsoft.com/ko-kr/windows-hardware/drivers/ifs/locating-disk-images-correctly)

[볼륨 이름이 중복 된 볼륨 열거 형 이해](https://docs.microsoft.com/ko-kr/windows-hardware/drivers/ifs/understanding-volume-enumerations-with-duplicate-volume-names)



### Windows 컨테이너 용 안티 바이러스 최적화

적용 대상 :

- Windows 10, version 1607
- Windows Server 2016
- AV products running on the Host

이 항목에서는 바이러스 백신 제품이 Windows 컨테이너 파일의 중복 검색을 방지하고 컨테이너 시작 시간을 향상시키는 데 사용할 수있는 최적화에 대해 설명합니다.

#### <span style="color:blue">컨테이너 개요</span>

Windows 컨테이너 기능은 응용 프로그램의 배포 및 배포를 단순화하도록 설계되었습니다. 자세한 내용은 [Windows 컨테이너](https://msdn.microsoft.com/virtualization/windowscontainers/about/about_overview) 소개를 참조하십시오.

컨테이너는 여러 패키지 레이어로 구성됩니다. Windows 기반 OS 패키지는 첫 번째 계층을 형성합니다.

각 컨테이너에는 해당 컨테이너에 대한 시스템 볼륨을 나타내는 격리 볼륨이 있습니다. 컨테이너 격리 필터 (wcifs.sys)는이 컨테이너 볼륨에 패키지 계층의 가상 오버레이를 제공합니다. 오버레이는 자리 표시 자 (재분석 지점)를 사용하여 수행됩니다. 컨테이너가 먼저 오버레이 경로에 액세스하기 전에 볼륨에 플레이스 홀더가 포함됩니다. 자리 표시 자 파일의 읽기는 백업 패키지 파일로 전달됩니다. 이 방법으로 여러 컨테이너 볼륨은 동일한 기본 패키지 파일 데이터 스트림에 액세스 할 수 있습니다.

컨테이너가 파일을 수정하면 격리 필터는 copy-on-write를 수행하고 자리 표시자를 패키지 파일의 내용으로 바꿉니다. 이렇게하면 특정 컨테이너에 대한 패키지 파일의 '연결'이 중단됩니다.



#### <span style="color:blue">읽기 리디렉션</span>

자리 표시 자 파일에서 읽기는 격리 필터에 의해 해당 패키지 계층으로 리디렉션됩니다. 리디렉션은 필터 수준에서 수행됩니다. 필터가 AV 범위보다 낮기 때문에 AV 필터는 읽기 리다이렉션을 보지 못합니다. AV는 리디렉션을 설정하기 위해 수행 된 패키지 파일의 열기도 보지 않습니다.

AV 필터는 컨테이너 시스템 볼륨의 모든 작업을 전체적으로 볼 수 있습니다. 자리 표시 자 파일뿐만 아니라 파일 수정 또는 새 파일 추가 작업도 볼 수 있습니다.



#### <span style="color:blue">중복 스캔 문제</span>

동일한 패키지 계층에 따라 많은 컨테이너가있을 수 있습니다. 주어진 패키지 파일의 동일한 데이터 스트림은 여러 컨테이너 시스템 볼륨의 자리 표시 자에 대한 데이터를 제공합니다. 결과적으로 모든 컨테이너에서 동일한 데이터의 중복 AV 검사가 발생할 수 있습니다. 이는 컨테이너의 성능에 불필요한 부정적인 영향을 미칩니다. 이것은 용기가 빨리 시작되고 수명이 짧을 것으로 예상되므로 표기 비용입니다.



#### <span style="color:blue">권장 접근 방식</span>

컨테이너에서 중복 스캔을 피하려면 AV 제품이 아래 설명 된대로 동작을 수정하는 것이 좋습니다. 이 접근법에 대해 고객에게 위험 / 보상 혜택을 결정하는 것은 AV 제품에 달려 있습니다. 자세한 내용은 이익 및 위험을 참조하십시오.



##### <span style="color:green">1. 패키지 설치</span>

패키지를 설치하는 동안 관리 도구는 패키지의 계층 루트 아래에 파일을 배치합니다. AV 필터는 파일을 패키지 루트에 배치 할 때 파일을 계속 스캔해야하며 일반적으로 파일을 검사해야합니다. 이렇게하면 레이어의 모든 파일이 초기에 맬웨어와 관련하여 깨끗하게 유지됩니다.



##### <span style="color:green">2. 컨테이너 시작과 실행</span>

컨테이너 볼륨의 실시간 검색을 위해 AV는 중복을 피하는 방식으로 스캔해야합니다. 자리 표시 자 파일은 특별히 고려해야합니다. 컨테이너에 의해 수정 된 파일이나 컨테이너에 생성 된 새 파일은 리디렉션되지 않으므로 중복 스캔은 중요하지 않습니다.

중복 검색을 피하기 위해 먼저 AV 필터는 해당 볼륨에 컨테이너 볼륨과 자리 표시자를 식별해야합니다. 다양한 이유 때문에 볼륨이 컨테이너 볼륨이거나 주어진 파일이 자리 표시 자 파일 인 경우 AV 필터가 쿼리 할 수있는 직접적인 방법이 없습니다. 격리 필터는 응용 프로그램 호환성 이유로 인해 자리 표시 자 재분석 지점을 숨 깁니다 (일부 응용 프로그램은 재분석 지점에 액세스하고 있다는 것을 알고있는 경우 올바르게 작동하지 않습니다). 또한 볼륨은 컨테이너가 실행 중일 때만 컨테이너 볼륨입니다. 컨테이너가 중지되고 볼륨이 다시 마운트 된 채로 남아있을 수 있습니다. 대신, 사전 생성에서 AV 필터는 파일 객체를 쿼리하여 컨테이너의 컨텍스트에서 열리는 지 확인해야합니다. 그런 다음 작성 및 ECP를 작성하여 작성 완료시 자리 표시 자 상태를 수신 할 수 있습니다.

AV 제품에는 다음과 같은 변경 사항이 필요합니다.

- 컨테이너 볼륨에서 사전 작성하는 동안 자리 표시 자 정보를받을 Create CallbackData에 ECP를 연결하십시오. 이러한 생성은 IoGetSiloParameters를 사용하여 파일 객체에서 SILO 매개 변수를 쿼리하여 식별 할 수 있습니다. 필터는 WCIFS_REDIRECTION_ECP_CONTEXT 구조체의 크기를 지정해야합니다. 다른 모든 필드는 ECP가 확인되면 필드가 설정됩니다.

- 사후 작성시 ECP가 승인되면 ECP 재 지정 플래그를 검사하십시오. 플래그는 패키지 계층 또는 스크래치 루트 (신규 또는 수정 된 파일)에서 열린 서비스가 제공되었는지 여부를 나타냅니다. 또한 플래그는 패키지 계층이 등록되었는지 여부와 원격인지 여부를 나타냅니다.

  - 원격 레이어에서 서비스되는 열기의 경우 AV는 파일 검색을 건너 뜁니다. 이것은 리디렉션 플래그에 의해 표시됩니다.

    ```
    WCIFS_REDIRECTION_FLAGS_CREATE_SERVICED_FROM_LAYER && WCIFS_REDIRECTION_FLAGS_CREATE_SERVICED_FROM_REMOTE_LAYER
    ```

    원격 레이어는 원격 호스트에서 검색 한 것으로 간주 할 수 있습니다. Hyper-V 컨테이너 패키지는 컨테이너를 호스팅하는 유틸리티 VM에 대해 원격입니다. 이러한 패키지는 SMB 루프백을 통해 유틸리티 VM에서 액세스 할 때 Hyper-V 호스트에서 정상적으로 검색됩니다.

    VolumeGUID 및 FileId는 원격지에 적용되지 않으므로이 필드는 설정되지 않습니다.

  - 등록 된 레이어에서 서비스되는 열기의 경우 AV는 파일 검색을 건너 뜁니다. 이것은 리디렉션 플래그에 의해 표시됩니다.

    ```
    WCIFS_REDIRECTION_FLAGS_CREATE_SERVICED_FROM_LAYER && WCIFS_REDIRECTION_FLAGS_CREATE_SERVICED_FROM_REGISTERED_LAYER
    ```

    등록 된 레이어는 패키지 설치 및 서명 업데이트 후 비동기 적으로 검사해야합니다.

    참고 등록 된 레이어는 나중에 시스템에서 식별되지 않을 수 있습니다. 이 경우 로컬 레이어 파일은 마지막 글 머리표에서 설명한대로 개별적으로 식별해야합니다.

  - 로컬 패키지 계층에서 서비스되는 열기의 경우 AV는 계층 파일의 제공된 VolumeGUID 및 FileId를 사용하여 파일을 검사해야하는지 결정해야합니다. 이렇게하면 AV가 볼륨 GUID 및 FileId로 인덱싱 된 검색 한 파일의 캐시를 구축해야 할 가능성이 높습니다. 이것은 리디렉션 플래그로 나타냅니다.

    ```
    WCIFS_REDIRECTION_FLAGS_CREATE_SERVICED_FROM_LAYER
    ```

  - 스크래치 위치에있는 새 파일 / 수정 된 파일의 경우 AV 제품은 파일을 스캔하고 정상적인 재조정을 수행해야합니다. 이것은 리디렉션 플래그로 나타냅니다.

    ```
    WCIFS_REDIRECTION_FLAGS_CREATE_SERVICED_FROM_SCRATCH
    ```

    이 경우 계층 파일이 없으므로 VolumeGUID 및 FileId는 설정되지 않습니다.

- 스트림 컨텍스트에서 '이 파일은 계층에서 서비스되었습니다'를 영구 마커로 저장하지 마십시오. 레이어 루트에서 처음 서비스 된 파일은 만들기 후에 수정할 수 있습니다. 이 경우, 동일한 파일에 대한 후속 작성은 작성이 컨테이너 볼륨에서 제공되고 있음을 나타낼 수 있습니다. AV 필터는 이러한 일이 발생할 수 있음을 이해해야합니다.



#### <span style="color:blue">LayerRootLocations 레지스트리 키를 사용하지 마십시오.</span>

과거에는 LayerRootLocations 레지스트리 키를 사용하여 기본 이미지의 위치를 가져 오는 것이 좋습니다. AV 제품은 더 이상이 레지스트리 키를 사용하지 않아야합니다. 대신 중복 검색을 피하려면이 항목에서 권장하는 방법을 사용하십시오.

패키지 계층을 등록하는 데 사용 된 레지스트리 위치 :

```
HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\WindowsNT\CurrentVersion\Virtualization\LayerRootLocations
```



#### <span style="color:blue">이점과 위험</span>

AV 제품에 대한 이러한 새로운 최적화를 사용할 때 다음과 같은 이점과 위험을 고려하십시오.



##### <span style="color:green">이점</span>

- 컨테이너 시작 또는 실행 시간에는 영향을주지 않습니다 (첫 번째 컨테이너의 경우에도 마찬가지 임).
- 여러 컨테이너에서 동일한 내용을 검색하지 않습니다.
- Windows Server Containers에서 작동합니다. Hyper-V 컨테이너의 경우 패키지에서 작동하지만 컨테이너를 실행하려면 추가 작업이 필요합니다.

##### <span style="color:green">위험</span>

서명 업데이트와 다음 예정된 사전 맬웨어 방지 검사 사이에 컨테이너가 실행되면 컨테이너에서 실행 된 파일은 최신 맬웨어 방지 서명과 관련하여 검사되지 않습니다. 이러한 위험을 줄이기 위해 AV 제품은 마지막 사전 검사 이후 서명 업데이트가없는 경우에만 리디렉션 된 파일 검사를 건너 뛸 수 있습니다. 이는 최신 서명으로 사전 검색이 완료 될 때까지 컨테이너 성능 저하를 제한합니다. 선택적으로, AV 제품은이 상황에서 사전 검색을 트리거하여 후속 컨테이너 실행이보다 효율적으로 수행 할 수 있습니다.



### 오프로드 된 데이터 전송

이 문서의 내용

[일반적인 데이터 전송](https://docs.microsoft.com/ko-kr/windows-hardware/drivers/ifs/offloaded-data-transfers#typical-data-transfers)

[오프로드 데이터 전송 (ODX)](https://docs.microsoft.com/ko-kr/windows-hardware/drivers/ifs/offloaded-data-transfers#offloaded-data-transfers-odx)

[파일 시스템 필터 옵트 인 모델 및 응용 프로그램에 미치는 영향](https://docs.microsoft.com/ko-kr/windows-hardware/drivers/ifs/offloaded-data-transfers#file-system-filter-opt-in-model-and-impact-to-applications)

[토큰 복사](https://docs.microsoft.com/ko-kr/windows-hardware/drivers/ifs/offloaded-data-transfers#copy-tokens)

[잘림](https://docs.microsoft.com/ko-kr/windows-hardware/drivers/ifs/offloaded-data-transfers#truncation)

[한계](https://docs.microsoft.com/ko-kr/windows-hardware/drivers/ifs/offloaded-data-transfers#limitations)

컴퓨터 간 또는 동일한 컴퓨터 내에서 데이터를 전송하는 것은 파일 시스템 활동이 빈번한 경우입니다. 표준 **ReadFile** 및 **WriteFile** 함수를 사용하면 기능적인 관점에서 잘 작동하지만 시스템의 모든 수준과 잠재적으로 네트워크를 통해 무거운 데이터 이동이 발생합니다. 이는 전송 및 시스템 연결 네트워크와 관련된 시스템의 가용성에 영향을 미칠 수 있습니다. 많은 스토리지 서브 시스템에서 사용할 수있는 고급 기능을 사용하면 데이터 이동의 '무거 운'작업을보다 효율적으로 수행 할 수 있습니다.

Windows 8부터 응용 프로그램은 이러한 기능을 활용하여 스토리지 서브 시스템으로의 데이터 이동 프로세스를 오프로드하는 데 도움이됩니다. 파일 시스템 필터는 일반적으로 볼륨에 대한 읽기 및 쓰기 요청을 가로 채서 이러한 작업을 모니터링합니다. 필터가 오프로드 된 데이터 전송을 인식하려면 추가 작업이 필요합니다.



#### <span style="color:blue">일반적인 데이터 전송</span>

오늘날 애플리케이션 시나리오에서 데이터를 이동하는 것은 매우 간단합니다. 데이터를 로컬 메모리로 읽은 다음 다시 새 위치에 씁니다. 다음 다이어그램은이 시나리오를 설명합니다.

이 시나리오에서는 지능형 스토리지 어레이 (ISA)를 통해 자체 가상 디스크가 노출 된 두 개의 서로 다른 파일 서버에있는 두 위치간에 파일을 복사합니다. 시작 시스템은 먼저 소스 가상 디스크의 데이터를 로컬 버퍼로 읽어야합니다. 그런 다음 전송 및 프로토콜 (예 : 1GbE 이상의 SMB)을 통해 데이터를 패키징하고 두 번째 시스템으로 전송 한 다음 두 번째 시스템은 데이터를 받아 로컬 버퍼로 출력합니다. 그런 다음 대상 시스템이 대상 가상 디스크에 데이터를 씁니다. 이 시나리오는 매일 여러 가지 응용 프로그램에서 여러 번 수행되는 데이터 전송의 매우 일반적인 읽기 / 쓰기 방법을 설명합니다.

![](.\Images\odx-scenario-1.png)

대부분의 시나리오에서 표준 읽기 및 쓰기가 원활하게 작동하지만 복사하려는 데이터는 동일한 지능형 스토리지 배열로 관리되는 가상 디스크에있을 수 있습니다. 즉, 데이터가 배열에서 서버로, 네트워크 전송을 통해 다른 서버로 이동 한 다음 다시 동일한 배열로 다시 이동합니다. 서버 내 및 네트워크 전송을 통해 데이터를 이동시키는 작업은 해당 시스템의 가용성에 큰 영향을 줄 수 있습니다. 데이터 이동의 처리량이 네트워크의 처리량과 가용성에 의해 제한된다는 사실은 말할 것도 없습니다.



#### <span style="color:blue">오프로드 데이터 전송 (ODX)</span>

##### <span style="color:green">데이터 전송 오프로드</span>

Windows 8에는 데이터 전송 오프로드 방법을 용이하게하는 두 가지 새로운 FSCTL이 도입되었습니다. 이는 비트 이동의 부담을 서버에서 멀리 이동시켜 스토리지 하위 시스템에서 지능적으로 발생하는 비트 이동으로 바꿉니다. 명령 의미를 시각화하는 가장 좋은 방법은 버퍼링되지 않은 읽기 및 버퍼되지 않은 쓰기와 유사하다고 생각하는 것입니다.

[**FSCTL_OFFLOAD_READ**](https://msdn.microsoft.com/library/windows/hardware/hh451101)

이 제어 요청은 읽을 파일 내의 오프셋과 [FSCTL_OFFLOAD_READ_INPUT](https://msdn.microsoft.com/library/windows/hardware/hh451104) 구조의 원하는 길이를 사용합니다. 지원되는 경우, 파일을 호스트하는 스토리지 서브 시스템은 연관된 오프로드 읽기 저장 명령을 수신하고 오프로드 읽기 명령의 시점에 읽으려는 데이터의 논리적 표현 인 토큰을 생성합니다. 이 토큰 문자열은 호출자에게 [FSCTL_OFFLOAD_READ_OUTPUT](https://msdn.microsoft.com/library/windows/hardware/hh451109) 구조체로 반환됩니다.



[**FSCTL_OFFLOAD_WRITE**](https://msdn.microsoft.com/library/windows/hardware/hh451122)

이 제어 요구는 기록 될 파일 내에서 오프셋, 기록의 원하는 길이 및 기록 될 데이터의 논리적 표현 인 토큰을 취합니다. 지원되는 경우, 기록 될 파일을 호스트하는 스토리지 서브 시스템은 연관된 오프로드 쓰기 저장 명령을 수신합니다. 먼저 주어진 토큰을 인식하고 가능한 경우 쓰기 작업을 수행합니다. 쓰기 작업은 Windows 아래에서 완료되므로 파일 시스템 및 저장소 스택의 구성 요소는 데이터 이동을 볼 수 없습니다. 데이터 이동이 완료되면 기록 된 바이트 수가 호출자에게 반환됩니다.

![](.\Images\odx-scenario-2.png)

첫 번째 다이어그램과 마찬가지로 두 개의 서로 다른 서버에있는 두 가상 디스크 간의 간단한 파일 복사가 표시됩니다. 정상적인 읽기 및 쓰기 작업을 수행하는 대신 비트 움직임이 무거워서 스토리지 배열로 옮깁니다. 첫 번째 시스템은 오프로드 읽기 작업을 실행하여 어레이가 첫 번째 가상 디스크 영역 내에서 읽을 데이터의 특정 시점보기를 나타내는 토큰을 생성하도록 요청합니다. 그런 다음 첫 번째 시스템은 토큰을 두 번째 시스템으로 전송하고 두 번째 시스템은 토큰을 사용하여 두 번째 가상 디스크로 오프로드 쓰기 작업을 실행합니다. 그런 다음 어레이는 토큰을 해석하고 가상 디스크간에 데이터 이동을 시도합니다. 실제 데이터 전송은 지능형 스토리지 배열 내에서 발생하며 두 호스트 간에는 발생하지 않습니다. 이렇게하면 두 시스템의 가용성이 크게 향상되는 동시에 시스템 간의 네트워크 트래픽이 거의 제거됩니다.



##### <span style="color:green">복사 엔진과의 통합</span>

Windows의 핵심 복사 엔진은 CopyFile 및 관련 기능에 사용됩니다. Windows 8부터는 복사 엔진이 전통적인 복사 파일 코드 경로보다 먼저 오프로드 된 데이터 전송을 사용하려고 시도합니다. 복사 API는 대부분의 응용 프로그램, 유틸리티 및 셸에서 사용되므로 이러한 호출자는 코드 수정 또는 사용자 개입이 거의없는 경우 기본적으로 오프로드 된 데이터 전송 기능을 사용할 수 있습니다.

다음 단계는 복사 엔진이 오프로드 된 데이터 전송을 시도하는 방법을 요약합니다.

1. 복사 엔진은 소스 토큰에 [FSCTL_OFFLOAD_READ](https://msdn.microsoft.com/library/windows/hardware/hh451101)를 실행하여 읽기 토큰을 가져옵니다.
2. 읽기 토큰을 검색하는 데 실패하면 복사 엔진이 기존의 읽기 및 쓰기 (일반적인 복사 파일 코드 경로)로 되돌아갑니다. 오류로 인해 원본 볼륨이 오프로드를 지원하지 않는다고 표시되면 복사 엔진은 볼륨을 프로세스 별 캐시로 표시합니다. 복사 엔진은 프로세스 당 캐시의 볼륨에 대해 더 이상 오프로드를 시도하지 않습니다.
3. 토큰이 성공적으로 검색되면 사본 엔진은 논리적으로 토큰이 나타내는 모든 데이터가 기록 될 때까지 큰 청크로 대상 파일에서 [FSCTL_OFFLOAD_WRITE](https://msdn.microsoft.com/library/windows/hardware/hh451122) 명령을 실행하려고 시도합니다.
4. 오프로드 읽기 또는 쓰기 수행시 오류는 복사 엔진이 오프로드 코드 경로가 종료 된 곳 (읽기 또는 쓰기가 잘린 부분)부터 시작하여 읽기 및 쓰기의 일반적인 코드 경로로 되돌아갑니다. 오류로 인해 대상 볼륨이 오프로드를 지원하지 않거나 소스 볼륨이 대상 볼륨에 도달 할 수없는 경우 복사본 엔진이 동일한 프로세스 별 캐시를 업데이트하므로 이러한 볼륨에서 오프로드를 시도하지 않습니다. 이 프로세스 별 캐시는 주기적으로 재설정됩니다.

다음 기능은 오프로드 된 데이터 전송을 지원합니다.

- **CopyFile**
- **CopyFileEx**
- **MoveFile**
- **MoveFileEx**
- **CopyFile2**

다음 기능은 오프로드 된 데이터 전송을 지원하지 않습니다.

- **CopyFileTransacted**
- **MoveFileTransacted**



##### <span style="color:green">지원되는 오프로드 데이터 전송 시나리오</span>

오프로드 작업에 대한 지원은 Hyper-V 저장소 스택과 Windows SMB 파일 서버에서 제공됩니다. 백업 실제 저장소가 ODX 작업을 지원하는 경우 호출자는 가상 컴퓨터 또는 실제 하드웨어 내에서든 VHD 또는 원격 파일 공유에있는 파일에 [FSCTL_OFFLOAD_READ](https://msdn.microsoft.com/library/windows/hardware/hh451101) 및 [FSCTL_OFFLOAD_WRITE](https://msdn.microsoft.com/library/windows/hardware/hh451122) 를 보낼 수 있습니다. 다음 다이어그램은 오프로드 된 데이터 전송에 대한 가장 기본적인 지원되는 소스 및 대상을 보여줍니다.

![](.\Images\odx-scenario-3.png)



#### <span style="color:blue">파일 시스템 필터 옵트 인 모델 및 응용 프로그램에 미치는 영향</span>

Windows 8부터 시작하는 필터 관리자를 사용하면 필터가 지원되는 기능으로 오프로드 기능을 지정할 수 있습니다. 볼륨에 연결된 파일 시스템 필터는 특정 오프로드 된 작업이 지원되는지 여부를 집합 적으로 결정할 수 있습니다. 그렇지 않은 경우 작업은 적절한 오류 코드와 함께 실패합니다.

필터는 HKEY_LOCAL_MACHINE\\System\\CurrentControlSet\\Services\\&lt;필터 드라이버 이름&gt; \에있는 레지스트리의 드라이버 서비스 정의에있는 SupportedFeatures라는 레지스트리 **DWORD** 값을 통해 [FSCTL_OFFLOAD_READ](https://msdn.microsoft.com/library/windows/hardware/hh451101) 및 [FSCTL_OFFLOAD_WRITE](https://msdn.microsoft.com/library/windows/hardware/hh451122)를 지원해야 함을 나타내야합니다. 이 값에는 비트가 선택되는 기능을 결정하는 비트 필드가 들어 있으며 필터 설치 중에 설정해야합니다.

현재 정의 된 비트는 다음과 같습니다.

| Flag                                           | Meaning                             |
| ---------------------------------------------- | ----------------------------------- |
| SUPPORTED_FS_FEATURES_OFFLOAD_READ 0x00000001  | Filter supports FSCTL_OFFLOAD_READ  |
| SUPPORTED_FS_FEATURES_OFFLOAD_WRITE 0x00000002 | Filter supports FSCTL_OFFLOAD_WRITE |

필터 옵트 인 모델은 다음 값을 가진 HKEY_LOCAL_MACHINE\\System\\CurrentControlSet\\Control\\FileSystem\\FilterSupportedFeaturesMode 레지스트리 키에있는 값에 따라 사용하거나 사용하지 않을 수 있습니다.

| FilterSupportedFeaturesMode Value | Meaning                                                      |
| --------------------------------- | ------------------------------------------------------------ |
| 0 (Default)                       | Do normal opt-in processing.                                 |
| 1                                 | Never opt-in (equivalent to setting SupportedFeatures to 0 on all filters attached) |



##### <span style="color:green">테스팅</span>

스택의 지원되는 기능을 확인하기 위해 fltmc 유틸리티 내에 업데이트 된 명령이 있습니다. 상승 된 사용자로 **fltmc instances –v [volume]:**을 실행하고 SprtFtrs 열을 확인하십시오. 필터의 SprtFtrs 값이 0으로 설정되면 필터가이 볼륨에서 오프로드를 차단하고 있음을 의미합니다. SprtFtrs 필드가 3으로 설정된 경우 두 오프로드 작업이 지원됩니다.



##### <span style="color:green">IRP 처리에서 기능 지원 확인</span>

IRP 처리의 일부로 FsRtlGetSupportedFeatures 루틴은 주어진 볼륨 스택에 연결된 모든 필터에 대해 집계 된 SupportedFeatures 상태를 검색합니다. I / O Manager 및 SRV (SMB)와 같은 구성 요소는이 루틴을 호출하여 스택의 모든 필터에 대해 SupportedFeatures 상태를 확인합니다. 자체 오프로드 IRP를 롤백하는 구성 요소는이 기능을 호출하여 해당 작업에 대한 옵트 인 지원의 유효성을 검사해야합니다.



##### <span style="color:green">필터 드라이버 고려 사항</span>

오프로드 된 데이터 전송은 데이터 센터에서 데이터를 이동시키는 새로운 방법입니다. 핵심 복사 엔진에 오프로드 논리가 통합되어 있으므로 기본적으로 많은 응용 프로그램에서 명시 적으로 옵트 인 (opt in)하지 않고 오프로드 된 데이터 이동을 수행 할 수 있습니다. 따라서 필터 개발자는 이러한 새로운 작업이 필터에 미치는 영향을 이해해야합니다. 이러한 작업을 완전히 이해하지 못하거나 새 데이터 흐름을 평가하지 않으면 잠재적으로 데이터가 일관성을 잃거나 손상 될 수있는 시나리오가 발생할 수 있습니다. 다음 목록은 필터 개발자가 오프로드시주의해야 할 일련의 작업 항목을 요약 한 것입니다.

- 새로운 데이터 흐름, 필터에 미치는 영향 및 이러한 오프로드 된 작업을 지원하는 필터의 기능을 이해하십시오.
- HKLM\\System\\CurrentControlSet\\Services\\[필터] 하위 키에 SupportedFeatures REG_DWORD 값을 추가하려면 필터 설치 관리자를 업데이트하십시오. 오프로드 기능을 지정하기 위해이를 초기화하십시오.
- 오프로드 작업을 수행하려는 필터의 경우 등록을 **IRP_MJ_FILE_SYSTEM_CONTROL**로 업데이트하여 [FSCTL_OFFLOAD_READ](https://msdn.microsoft.com/library/windows/hardware/hh451101) 및 [FSCTL_OFFLOAD_WRITE](https://msdn.microsoft.com/library/windows/hardware/hh451122)를 처리하십시오.
- 오프로드 된 작업을 차단해야하는 필터의 경우 필터에서 상태 코드 STATUS_NOT_SUPPORTED를 반환하십시오. 레지스트리 값을 최종 사용자가 변경할 수 있으므로 차단 오프로드 작업을 적용하는 데 의존하지 마십시오. 필터는 오프로드 작업을 명시 적으로 허용하거나 금지해야합니다.



#### <span style="color:blue">토큰 복사</span>

오프로드 된 작업에서는 파일 데이터가 I / O 스택에 표시되지 않습니다. 대신 데이터의 논리적 프록시 인 512 바이트 토큰으로 간주됩니다. 이 토큰은 스토리지 서브 시스템에 의해 생성 된 공급 업체 특정 형식의 불투명하고 고유 한 문자열이거나 데이터 패턴 (예 : 0과 논리적으로 동일한 데이터 범위)을 나타 내기 위해 잘 알려진 유형일 수 있습니다. 토큰이 프록시 인 데이터를 수정하면 토큰이 + 효화되거나 저장 영역 서브 시스템이 벤더 특정 f} (예 : 스 냄샷 메커니즘을 통해)으로 원래 데이터를 지속시킬 수 있습니다. 파일의 지정된 범위에 대한 후속 오프로드 읽기 요청은 고유 한 토큰을 만듭니다.

잘 정의 된 데이터 패턴을 나타내는 토큰 클래스가 있습니다. 가장 일반적으로 잘 알려진 토큰은 0과 동일한 0 토큰입니다. 토큰이 잘 알려진 토큰으로 정의되면 STORAGE_OFFLOAD_TOKEN 구조의 TokenType 구성원이 STORAGE_OFFLOAD_TOKEN_TYPE_WELL_KNOWN으로 설정됩니다. 이 필드가 설정되면 WellKnownPattern 구성원은 토큰이되는 데이터 패턴을 결정합니다.

- WellKnownPattern 필드가 STORAGE_OFFLOAD_PATTERN_ZERO 또는 STORAGE_OFFLOAD_PATTERN_ZERO_WITH_PROTECTION_INFORMATION으로 설정되면 Zero Token을 나타냅니다. 이 토큰이 FSCTL_OFFLOAD_READ 작업에 의해 반환되면 원하는 파일 범위에 포함 된 데이터가 논리적으로 0과 같음을 나타냅니다. 이 토큰이 FSCTL_OFFLOAD_WRITE 작업에 제공되면 기록 할 파일의 원하는 범위가 논리적으로 0이어야 함을 나타냅니다.
- Zero Token 이외의 다른 Well Known Token 패턴은 현재 정의되어 있지 않습니다. 사용자가 자신의 Well Known Token 패턴을 정의하는 것은 권장하지 않습니다.



#### <span style="color:blue">잘림</span>

Windows가 통신하는 기본 저장 영역 서브 시스템은 오프로드 조작에서 원하는 데이터를 적게 처리 할 수 있습니다. 이를 잘라내 기 (truncation)라고합니다. 오프로드 읽기에서는 리턴 된 토큰이 요청 된 것보다 적은 데이터 범위를 나타냄을 의미합니다. 이것은 FSCTL_OFFLOAD_READ_OUTPUT 구조체의 TransferLength 멤버에 의해 표시되며, 이는 읽을 파일 범위의 시작부터 바이트 수입니다. 오프로드 쓰기의 경우 잘 렸음은 원하는 것보다 적은 데이터가 기록되었음을 나타냅니다. 이 값은 FSCTL_OFFLOAD_WRITE_OUTPUT 구조체의 LengthWritten 멤버로 표시되며, 기록 할 파일 범위의 시작부터 바이트 수입니다. 명령 처리에서의 오류 또는 큰 범위에 대한 스택 내의 제한으로 인해 잘림이 발생합니다.

NTFS가 범위를 잘라내어 읽기 또는 쓰기를 오프로드하는 두 가지 시나리오가 있습니다.

1. VDL이 파일 끝 (EOF) 앞에 있으면 복사 범위가 유효 데이터 길이 (VDL)로 잘립니다. 이것은 VDL이 논리 섹터 경계에 정렬되어 있다고 가정합니다. 그렇지 않으면 시나리오를 참조하십시오.

   ![](.\Images\odx-vdl-1.png)

   [FSCTL_OFFLOAD_READ](https://msdn.microsoft.com/library/windows/hardware/hh451101) 연산 중에 OFFLAD_READ_FLAG_ALL_ZERO_BEYOND_CURRENT_RANGE 플래그가 [FSCTL_OFFLOAD_READ_OUTPUT](https://msdn.microsoft.com/library/windows/hardware/hh451109) 구조체에 설정되어 파일의 나머지 부분에 0이 들어 있고 TransferLength 멤버가 VDL로 잘 렸음을 나타냅니다.

2. 시나리오 1과 유사하지만 VDL이 논리 섹터 경계에 정렬되지 않은 경우 원하는 범위는 NTFS에서 다음 논리 섹터 경계로 잘립니다.



#### <span style="color:blue">한계</span>

- 오프로드 작업은 NTFS 볼륨에서만 지원됩니다.
- 오프로드 작업은 원격 공유가 NTFS 볼륨이고 서버가 Windows Server 2012를 실행중인 경우 원격 파일 서버를 통해 지원됩니다 (원격 스택이 오프로드 작업도 지원한다고 가정).
- NTFS는 Bitlocker 또는 NTFS 암호화 (EFS), 중복 된 파일, 압축 파일, 상주 파일, 스파 스 파일 또는 TxF 트랜잭션에 참여하는 파일로 암호화 된 파일에서 수행되는 오프로드 FSCTL을 지원하지 않습니다.
- NTFS는 volsnap 스냅 샷 내의 파일에 대해 수행 된 오프로드 FSCTL을 지원하지 않습니다.
- 원하는 파일 범위가 소스 장치의 논리적 섹터 크기와 맞지 않거나 원하는 파일 범위가 대상 장치의 논리적 섹터 크기와 정렬되지 않은 경우 NTFS는 오프로드 FSCTL을 실패합니다. 이것은 non-cached IO와 동일한 의미를 갖는다.
- FSCTL_OFFLOAD_WRITE 전에 대상 파일을 미리 할당해야합니다 (SetEndOfFile 및 SetAllocation).
- 오프로드 읽기 및 오프로드 쓰기 처리시 NTFS는 먼저 CcCoherencyFlushAndPurgeCache를 호출하여 시스템 캐시의 수정 된 데이터를 커밋합니다. 이는 캐시되지 않은 IO와 동일한 의미입니다.



### 디스크 이미지를 올바르게 찾기

디스크 이미징 및 볼륨 관리 도구는 Volsnap으로 생성 된 스냅 샷을 사용할 때 디스크상의 이미지 데이터 영역을 찾는 위치와 사용자 데이터에 미치는 영향을 알아야합니다. 디스크 이미지가 부적절하게 위치하면 스냅 샷에 손상된 데이터가 포함됩니다.

일부 이미징 제품은 실제로 디스크의 처음 8K 바이트까지 확장 될 때 BIOS의 BPB (Parameter Parameter Block)가 4KB 밖에되지 않는다고 잘못 가정합니다. 결과적으로 볼륨의 클러스터 크기에 따라 이미징 도구가 BPB의 마지막 4K 바이트 부분에있는 사용자 데이터를 찾으면 볼륨에 대해 Volsnap 스냅 샷을 만든 후 데이터가 손실 될 수 있습니다. 이는 이미징 도구가 사용자 데이터를 디스크의 예약 된 영역에 저장했기 때문입니다.

장치에 설정된 논리 섹터 크기 (예 : 512 바이트 또는 4K 바이트)는 항상 8KB이므로 BPB의 크기를 결정하지 않습니다.

다음 표에서는 디스크 이미지의 데이터 영역에 대한 섹터 레이아웃 및 바이트 오프셋 요구 사항에 대해 설명합니다.

BCB 예약 영역 이미지 데이터 영역 0 (512 바이트 섹터) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 + 0 (바이트 오프셋) 4096 8192



### 볼륨 이름이 중복 된 볼륨 열거 형 이해

볼륨을 열거 할 때 결과 볼륨 정보 목록에 중복 볼륨 이름이 나타날 수 있습니다.

이 문제의 원인을 이해하려면 다음과 같은 시나리오를 고려하십시오. FltEnumerateVolumeInformation은 모든 시스템 볼륨을 열거하는 데 사용됩니다. 그 결과 버퍼에 볼륨 정보 구조가 채워집니다. 필터 관리자에게 알려진 각 볼륨에 대한 정보입니다. 이 버퍼에서 각 볼륨 정보 구조는 FILTER_VOLUME_BASIC_INFORMATION 또는 FILTER_VOLUME_STANDARD_INFORMATION 유형일 수 있지만 둘 다 가질 수는 없습니다.

볼륨 정보 구조의이 목록이 주어지면 여러 목록 요소가 동일한 볼륨 이름을 포함하는 것이 가능합니다. 즉, 두 개 이상의 list 요소의 FilterVolumeName 멤버가 동일 할 수 있습니다. 이것은 FltEnumerateVolumes와 같은 모든 필터 관리자 열거 루틴이 분리되었지만 해체되지 않은 볼륨을 열거하기 때문에 가능합니다 (열린 파일이 여전히 볼륨에 존재하기 때문에). 따라서 볼륨이 분리되면 해당 이름이 볼륨 정보 목록에 두 번 이상 표시 될 수 있습니다. 즉, 현재 마운트 된 상태에 대해 한 번, 그리고 가장 단순한 경우에 이전에 분리 된 상태이지만 찢어지지 않은 상태로 표시됩니다.

볼륨 정보 목록에 중복 된 볼륨 이름이 나타나면 위의 설명에 따라 동일한 이름의 각 그룹이 설명됩니다. 그러나 다음 절차를 사용하여 위의 시나리오를 확인할 수 있습니다.

- 목록에 FILTER_VOLUME_STANDARD_INFORMATION 유형의 구조가 채워진 경우 FilterVolumeName 멤버가 동일한 구조 그룹을 식별합니다. 이 그룹의 구조 중 하나 이상이 플래그 구성원에 FLTFL_VSI_DETACHED_VOLUME 플래그를 설정하면 그룹과 연관된 볼륨이 마운트 해제되었지만 철거되지 않은 상태가됩니다. 중복 된 볼륨 이름이 존재하는 이유를 확인합니다. 해당되는 경우 나머지 모든 그룹에 대해이 절차를 반복하십시오.
- 목록에 FILTER_VOLUME_BASIC_INFORMATION 유형의 구조가 채워진 경우이 목록을 해당 FILTER_VOLUME_STANDARD_INFORMATION 구조 양식으로 변환하고 이전 글 머리 기호에서와 같이 진행하십시오.

참고 FILTER_VOLUME_STANDARD_INFORMATION 구조는 Windows Vista에서만 사용할 수 있습니다.

이 주제의 영향을받는 루틴 및 구조는 다음과 같습니다.

[**FILTER_VOLUME_BASIC_INFORMATION**](https://msdn.microsoft.com/library/windows/hardware/ff541631)

[**FILTER_VOLUME_STANDARD_INFORMATION**](https://msdn.microsoft.com/library/windows/hardware/ff541647)

[**FilterVolumeFindFirst**](https://msdn.microsoft.com/library/windows/hardware/ff541525)

[**FilterVolumeFindNext**](https://msdn.microsoft.com/library/windows/hardware/ff541530)

[**FltEnumerateVolumeInformation**](https://msdn.microsoft.com/library/windows/hardware/ff542091)

[**FltEnumerateVolumes**](https://msdn.microsoft.com/library/windows/hardware/ff542092)

[**FltGetVolumeInformation**](https://msdn.microsoft.com/library/windows/hardware/ff543238)









