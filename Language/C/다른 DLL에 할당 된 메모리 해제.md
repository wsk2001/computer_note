# 다른 DLL에 할당 된 메모리 해제

출처: 다른 DLL에 할당 된 메모리 해제

다른 DLL 파일을 사용하는 DLL 파일을 사용하는 EXE 파일이 있습니다. 이 상황이 발생했습니다 :

### In DLL file 1:

```c++
class abc
{
    static bool FindSubFolders(const std::string & sFolderToCheck, 
                               std::vector< std::string > & vecSubFoldersFound);
}
```



### In DLL file 2:

```c++
void aFunction()
{
    std::vector<std::string> folders;
    std::string sLocation;
    ...
    abc::FindSubFolders(sLocation, folders)
}
```

릴리스 모드에서는 모든 것이 잘 작동합니다. 그러나 디버그 모드에서 폴더 벡터의 std :: string 중 하나의 소멸자에서 어설 션 오류가 발생합니다 (폴더가 함수의 끝에서 범위를 벗어날 때).



dbgheap.c : line 1274

```c++
/*
 * If this ASSERT fails, a bad pointer has been passed in. It may be
 * totally bogus, or it may have been allocated from another heap.
 * The pointer MUST come from the 'local' heap.
 */
_ASSERTE(_CrtIsValidHeapPointer(pUserData));
```

메모리가 DLL 파일 1의 힙에 할당되었지만 DLL 파일 2에서 해제되기 때문이라고 생각합니다.

dbgheap.c의 주석은 이것이 문제라는 주장에 상당히 반항적 인 것 같습니다.

방금 무시해도 문제가없는 것처럼 보이는 이유는 무엇입니까? 어설 션에 실패하지 않는 방법이 있습니까?



#### Answers-1

Sean이 이미 말했듯이 릴리스 빌드는 단순히 해당 delete 문을 무시하므로 메모리 누출이 가장 좋습니다.

두 DLL 파일이 컴파일되는 방식을 제어 할 수있는 경우 런타임 라이브러리에 멀티 스레드 디버그 DLL (/ MDd) 또는 멀티 스레드 DLL (/ MD) 설정을 사용해야합니다. 이렇게하면 두 DLL 파일 모두 동일한 런타임 시스템을 사용하고 동일한 힙을 공유합니다.

단점은 응용 프로그램과 함께 런타임 시스템을 설치해야한다는 것입니다 (Microsoft는이를위한 설치 프로그램을 제공합니다). Visual Studio는 해당 런타임 시스템도 설치하기 때문에 개발 시스템에서는 제대로 작동하지만 새로 설치된 시스템에서는 누락 된 DLL 파일이보고됩니다.

> 내 프로젝트 속성이 잘못되었습니다. 디버그 DLL (/ MDd)이 설정되지 않았습니다. 이제 제대로 작동합니다. 감사! –



#### Answers-2

릴리스 빌드에는 동일한 문제가 있지만 릴리스 빌드에는 문제가 없습니다. 그들은 단지 문제를 무시합니다. 당신은 결코 문제를 볼 수 없습니다. 또는 데이터가 손상되었을 수 있습니다. 또는 충돌이 발생할 수 있습니다. 아마도 사용자 만이 단순히 재현 할 수없는 버그를 경험하게 될 것입니다.

CRT 어설 션을 무시하지 마십시오.

항상 적절한 할당 기 (처음 할당 자에 맞는 할당 기)를 사용해야합니다. DLL 파일에서 정적 CRT 라이브러리를 사용하는 경우 DLL 파일은 다른 힙을 사용합니다. 힙간에 메모리 할당을 해제 할 수 없습니다. 동일한 힙을 사용하여 메모리 블록을 할당 및 할당 해제하십시오.

DLL 파일에서 공유 CRT 라이브러리를 사용하는 경우 동일한 힙을 사용해야하며 한 DLL 파일에 할당하고 다른 DLL 파일에 할당 해제 할 수 있습니다.



#### Answers-3

다른 말로, CRT가 두 모듈간에 공유되도록함으로써 문제를 해결할 수 있습니다. 그러나이 계약을 시행하기 어려운 일반적인 시나리오가 있습니다.

EXE 및 DLL이 동일한 CRT 버전 (6.0, 7.0, 8.0에서)에 대해 연결되지 않으면 공유 CRT에 연결하는 것이 작동하지 않기 때문입니다. 예를 들어 VC6.0에서 빌드 된 DLL을 가져와 VS2010에서 EXE 빌드와 함께 사용하려고하면 이전과 동일한 문제가 발생합니다. CRT의 두 버전은 프로세스에로드되며 EXE 및 DLL이 '공유'CRT를 사용하는지 여부에 관계없이 각각 할당에 자체 힙을 사용하여 동일하지 않습니다.

API에 대한 더 좋은 방법은 한쪽에 할당 된 객체가 같은 쪽에서도 파괴되도록하는 것입니다. 나는 이것이 불쾌한 방법 이라는 것을 알고 있지만 DLL이 바이너리 호환을 유지하는 유일한 방법입니다.



#### Answers-4

응용 프로그램 또는 하나 이상의 DLL 파일이 정적 버전의 표준 라이브러리에 연결되어있는 경우에만 문제가됩니다. MS는 표준 라이브러리의 공유 라이브러리 버전을 발표함으로써 약 10 년 전에 해결되었습니다. 표준 라이브러리의 각 버전은 자체 내부 힙을 빌드하므로 다중 힙을 사용하면 메모리를 올바른 힙으로 해제해야합니다. 표준 라이브러리의 공유 버전을 사용하면 모두 동일한 힙을 사용합니다.

오늘날 응용 프로그램의 표준 관행이며 모든 DLL 파일은 표준 라이브러리의 동적 버전을 사용하도록 작성해야합니다.

위의 유일한주의 사항은 자신의 힙을 만들고이 힙에서 메모리를 할당하는 것입니다. 그러나 이것은 매우 드문 상황에서만 수행되는 매우 전문적인 절차입니다 (이를 충분히 이해하면이 질문을하는 상황에 있지 않을 것입니다).

