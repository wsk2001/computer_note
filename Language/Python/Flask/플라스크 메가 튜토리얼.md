# 플라스크 메가 튜토리얼

출처: https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-i-hello-world

어서 오십시오! Python 및 Flask 프레임 워크를 사용하여 웹 애플리케이션을 작성하는 방법을 배우려고합니다. 위의 비디오는이 튜토리얼의 내용에 대한 개요를 제공합니다. 이 첫 번째 장에서는 Flask 프로젝트를 설정하는 방법을 배웁니다. 이 장을 마치면 컴퓨터에서 간단한 Flask 웹 응용 프로그램을 실행할 수 있습니다!

참고로 아래는 이 시리즈의 기사 목록입니다.

- [Chapter 1: Hello, World!](https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-i-hello-world) (this article)
- [Chapter 2: Templates](https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-ii-templates)
- [Chapter 3: Web Forms](https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-iii-web-forms)
- [Chapter 4: Database](https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-iv-database)
- [Chapter 5: User Logins](https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-v-user-logins)
- [Chapter 6: Profile Page and Avatars](https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-vi-profile-page-and-avatars)
- [Chapter 7: Error Handling](https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-vii-error-handling)
- [Chapter 8: Followers](https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-viii-followers)
- [Chapter 9: Pagination](https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-ix-pagination)
- [Chapter 10: Email Support](https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-x-email-support)
- [Chapter 11: Facelift](https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-xi-facelift)
- [Chapter 12: Dates and Times](https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-xii-dates-and-times)
- [Chapter 13: I18n and L10n](https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-xiii-i18n-and-l10n)
- [Chapter 14: Ajax](https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-xiv-ajax)
- [Chapter 15: A Better Application Structure](https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-xv-a-better-application-structure)
- [Chapter 16: Full-Text Search](https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-xvi-full-text-search)
- [Chapter 17: Deployment on Linux](https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-xvii-deployment-on-linux)
- [Chapter 18: Deployment on Heroku](https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-xviii-deployment-on-heroku)
- [Chapter 19: Deployment on Docker Containers](https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-xix-deployment-on-docker-containers)
- [Chapter 20: Some JavaScript Magic](https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-xx-some-javascript-magic)
- [Chapter 21: User Notifications](https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-xxi-user-notifications)
- [Chapter 22: Background Jobs](https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-xxii-background-jobs)
- [Chapter 23: Application Programming Interfaces (APIs)](https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-xxiii-application-programming-interfaces-apis)



## [Part I: Hello, World!](https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-i-hello-world)

참고 1 :이 튜토리얼의 레거시 버전을 찾고 있다면 [여기](https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-i-hello-world-legacy) 있습니다.

참고 2 :이 블로그에 대한 나의 작업을 지원하거나 매주 기사를 기다릴 인내심이 없다면이 튜토리얼의 전체 버전을 전자 책 또는 비디오 세트로 제공합니다. 자세한 내용은 [course.miguelgrinberg.com](https://courses.miguelgrinberg.com/)을 방문하십시오.

이 튜토리얼에 제시된 모든 코드 예제는 GitHub 리포지토리에서 호스팅됩니다. GitHub에서 코드를 다운로드하면 많은 타이핑을 줄일 수 있지만 적어도 처음 몇 장에서는 직접 코드를 입력하는 것이 좋습니다. Flask와 예제 응용 프로그램에 익숙해지면 입력이 너무 지루한 경우 GitHub에서 직접 코드에 액세스 할 수 있습니다.

각 장의 시작 부분에서, 장을 작업하는 동안 유용 할 수있는 3 개의 GitHub 링크를 제공합니다. Browse (찾아보기) 링크는 다음 장에서 소개 된 변경 사항을 포함하지 않고 읽고있는 장에 대한 변경 사항이 추가 된 곳에 Microblog 용 GitHub 리포지토리를 엽니 다. Zip 링크는 전체 애플리케이션을 포함하고이 장의 변경 사항을 포함하여 Zip 파일에 대한 다운로드 링크입니다. Diff 링크는 읽으려는 장에서 이루어진 모든 변경 사항을 그래픽으로 보여줍니다.

이 장의 GitHub 링크는 다음과 같습니다: *[Browse](https://github.com/miguelgrinberg/microblog/tree/v0.1), [Zip](https://github.com/miguelgrinberg/microblog/archive/v0.1.zip), [Diff](https://github.com/miguelgrinberg/microblog/compare/v0.0...v0.1).*



### 파이썬 설치

컴퓨터에 Python이 설치되어 있지 않다면 지금 설치하십시오. 운영 체제가 Python 패키지를 제공하지 않으면 Python 공식 웹 사이트에서 설치 프로그램을 다운로드 할 수 있습니다. WSL 또는 Cygwin과 함께 Microsoft Windows를 사용하는 경우 Windows 기본 버전의 Python을 사용하지 않고 Ubuntu (WSL을 사용하는 경우) 또는 Cygwin에서 구해야하는 Unix 친화적 버전을 사용하십시오.

Python 설치가 제대로 작동하도록하려면 터미널 창을 열고 python3을 입력하거나 작동하지 않는 경우 python 만 입력하십시오. 당신이 볼 것으로 예상되는 것은 다음과 같습니다.

```bash
$ python3
Python 3.5.2 (default, Nov 17 2016, 17:05:23)
[GCC 5.4.0 20160609] on linux
Type "help", "copyright", "credits" or "license" for more information.
>>> _
```

Python 인터프리터는 이제 대화식 프롬프트에서 기다리고 있습니다. 여기에서 Python 문을 입력 할 수 있습니다. 다음 장에서는이 대화식 프롬프트가 어떤 종류의 유용한 지 배울 것입니다. 그러나 지금은 시스템에 Python이 설치되어 있음을 확인했습니다. 대화식 프롬프트를 종료하려면 exit ()를 입력하고 Enter를 누르십시오. Linux 및 Mac OS X 버전의 Python에서는 Ctrl-D를 눌러 인터프리터를 종료 할 수도 있습니다. Windows에서 종료 바로 가기는 Ctrl-Z와 Enter입니다.



### 플라스크 설치

다음 단계는 Flask를 설치하는 것이지만 들어가기 전에 Python 패키지 설치와 관련된 모범 사례에 대해 설명하고자합니다.

Python에서는 누구나 플라스크를 다운로드하여 설치할 수있는 공용 저장소에서 Flask와 같은 패키지를 사용할 수 있습니다. 공식 Python 패키지 저장소는 PyPI라고하며, 이는 Python 패키지 색인을 나타냅니다 (일부 사람들은이 저장소를 '치즈 샵'이라고도 함). Python에는이 작업을 수행하는 pip라는 도구가 포함되어 있으므로 PyPI에서 패키지를 설치하는 것은 매우 간단합니다 (Python 2.7에서 pip는 Python과 함께 제공되지 않으며 별도로 설치해야 함).

컴퓨터에 패키지를 설치하려면 다음과 같이 pip를 사용하십시오.

```bash
$ pip install <package-name>
```

요컨대,이 패키지 설치 방법은 대부분의 경우 작동하지 않습니다. 파이썬 인터프리터가 컴퓨터의 모든 사용자를 위해 전 세계에 설치되어 있다면, 일반 사용자 계정이 수정 권한을 갖지 못할 가능성이 있으므로 위 명령을 실행하는 유일한 방법은 관리자로부터 실행하는 것입니다 계정. 그러나 그 복잡성이 없어도 위와 같이 패키지를 설치할 때 어떤 일이 발생하는지 고려하십시오. Pip 도구는 PyPI에서 패키지를 다운로드 한 다음 Python 설치에 추가합니다. 그 시점부터 시스템에있는 모든 Python 스크립트는이 패키지에 액세스 할 수 있습니다. 처음 시작할 때 Flask의 최신 버전 이었지만 현재 0.12 버전으로 대체 된 Flask 0.11 버전을 사용하여 웹 응용 프로그램을 완료 한 상황을 상상해보십시오. 이제 0.12 버전을 사용하려는 두 번째 응용 프로그램을 시작하려고하지만 설치 한 0.11 버전을 교체하면 이전 응용 프로그램이 손상 될 위험이 있습니다. 문제가 보입니까? 기존 응용 프로그램에서 사용할 Flask 0.11을 설치하고 새 응용 프로그램에 Flask 0.12를 설치하는 것이 이상적입니다.

여러 응용 프로그램에 대해 다른 버전의 패키지를 유지 관리하는 문제를 해결하기 위해 Python은 가상 환경 개념을 사용합니다. 가상 환경은 Python 인터프리터의 완전한 사본입니다. 가상 환경에 패키지를 설치할 때 시스템 전체 Python 인터프리터는 영향을받지 않으며 사본 만 영향을받습니다. 따라서 각 응용 프로그램마다 패키지 버전을 자유롭게 설치할 수있는 솔루션은 각 응용 프로그램마다 다른 가상 환경을 사용하는 것입니다. 가상 환경에는 가상 환경을 만든 사용자가 소유 한 추가 이점이 있으므로 관리자 계정이 필요하지 않습니다.

프로젝트가 존재하는 디렉토리를 만들어 봅시다. 이 디렉토리는 마이크로 블로그라고 부르겠습니다. 왜냐하면 그것이 응용 프로그램의 이름이기 때문입니다.

```bash
$ mkdir microblog
$ cd microblog
```

Python 3 버전을 사용하는 경우 가상 환경 지원이 포함되어 있으므로 가상 환경 지원이 필요합니다.

```bash
$ python3 -m venv venv
```

이 명령으로 Python에 venv 패키지를 실행하도록 요청하고 venv라는 가상 환경을 만듭니다. 명령의 첫 번째 venv는 Python 가상 환경 패키지의 이름이고 두 번째는이 특정 환경에 사용할 가상 환경 이름입니다. 이 혼란스러운 경우 두 번째 venv를 가상 환경에 할당하려는 다른 이름으로 바꿀 수 있습니다. 일반적으로 프로젝트 디렉토리에 이름이 venv 인 가상 환경을 작성하므로 프로젝트를 시작할 때마다 해당 가상 환경을 찾습니다.

일부 운영 체제에서는 위의 명령에서 python3 대신 python을 사용해야 할 수도 있습니다. 일부 설치에서는 Python 2.x 릴리스의 경우 python을, 3.x 릴리스의 경우 python3을 사용하는 반면, 다른 설치에서는 python을 3.x 릴리스에 매핑합니다.

명령이 완료되면 가상 환경 파일이 저장되는 venv라는 디렉토리가 생깁니다.

3.4 이전 (및 2.7 릴리스 포함)의 Python 버전을 사용하는 경우 가상 환경은 기본적으로 지원되지 않습니다. 해당 버전의 Python의 경우 가상 환경을 작성하기 전에 virtualenv라는 타사 도구를 다운로드하여 설치해야합니다. Virtualenv가 설치되면 다음 명령을 사용하여 가상 환경을 작성할 수 있습니다.

```bash
$ virtualenv venv
```

사용하는 방법에 관계없이 가상 환경을 만들어야합니다. 새로운 가상 환경을 활성화하려면 다음 명령을 사용하십시오.

```bash
$ source venv/bin/activate
(venv) $ _
```

Microsoft Windows 명령 프롬프트 창을 사용하는 경우 활성화 명령이 약간 다릅니다.

```bash
$ venv\Scripts\activate
(venv) $ _
```

가상 환경을 활성화하면 터미널 세션의 구성이 내부에 저장된 Python 인터프리터가 python을 입력 할 때 호출되는 인터페이스가되도록 수정됩니다. 또한 터미널 프롬프트는 활성화 된 가상 환경의 이름을 포함하도록 수정되었습니다. 터미널 세션에 대한 변경 사항은 모두 해당 세션에 대해 일시적이며 비공개이므로 터미널 창을 닫을 때 유지되지 않습니다. 여러 개의 터미널 창을 동시에 연 상태에서 작업하는 경우 각기 다른 가상 환경을 활성화하는 것이 좋습니다.

가상 환경을 만들고 활성화 했으므로 이제 Flask를 설치할 수 있습니다.

```bash
(venv) $ pip install flask
```

가상 환경에 Flask가 설치되어 있는지 확인하려면 Python 인터프리터를 시작하고 Flask를 가져올 수 있습니다.

```bash
>>> import flask
>>> _
```

이 설명에 오류가 없으면 플라스크가 설치되어 사용할 준비가되었으므로 축하합니다.



### 'Hello, World'플라스크 응용 프로그램

Flask 웹 사이트를 방문하면 5 줄의 코드가 포함 된 매우 간단한 예제 응용 프로그램을 사용할 수 있습니다. 그 간단한 예를 반복하는 대신, 좀 더 정교한 응용 프로그램을 작성하여 더 큰 응용 프로그램을 작성하기위한 좋은 기본 구조를 제공 할 것입니다.

응용 프로그램은 패키지에 존재합니다. Python에서 `__init__.py` 파일을 포함하는 하위 디렉토리는 패키지로 간주되며 가져올 수 있습니다. 패키지를 가져올 때 `__init__.py`는 패키지가 외부 세계에 노출되는 심볼을 실행하고 정의합니다.

응용 프로그램을 호스팅 할 `app`이라는 패키지를 만듭니다. 마이크로 블로그 디렉토리에 있는지 확인한 후 다음 명령을 실행하십시오.

```bash
(venv) $ mkdir app
```

앱 패키지의 `__init__.py`에는 다음 코드가 포함됩니다.

`app/__init__.py: Flask application instance`

```python
from flask import Flask

app = Flask(__name__)

from app import routes
```

위의 스크립트는 플라스크 패키지에서 가져온 Flask 클래스의 인스턴스로 응용 프로그램 객체를 생성합니다. Flask 클래스에 전달 된 `__name__ `변수는 Python 사전 정의 변수이며, 변수가 사용되는 모듈의 이름으로 설정됩니다. Flask는 템플릿 파일과 같은 관련 리소스를로드해야 할 때 여기에 전달 된 모듈의 위치를 시작 지점으로 사용합니다.이 장에서는 2 장에서 다룰 것입니다. 실질적인 목적으로 `__name__`을 전달하면 거의 항상 Flask를 올바른 것으로 구성하게됩니다. 방법. 그런 다음 응용 프로그램은 아직 존재하지 않는 경로(routes) 모듈을 가져옵니다.

처음에는 혼란스러워 보일 수있는 한 가지 측면은 app이라는 두 개의 엔티티가 있다는 것입니다. 앱 패키지는 앱 디렉토리와 `__init__.py` 스크립트에 의해 정의되며 from app import route 문에서 참조됩니다. 앱 변수는 `__init__.py` 스크립트에서 Flask 클래스의 인스턴스로 정의되어 앱 패키지의 멤버가됩니다.

또 다른 특징은 route 모듈이 항상 수행되는 것처럼 스크립트의 맨 위가 아니라 맨 아래로 가져 오는 것입니다. 맨 아래 가져 오기는 Flask 응용 프로그램의 일반적인 문제인 순환 가져 오기에 대한 해결 방법입니다. Routes 모듈이이 스크립트에 정의 된 app 변수를 가져와야한다는 것을 알 수 있습니다. 따라서 상호 반입 중 하나를 맨 아래에두면이 두 파일 간의 상호 참조로 인한 오류를 피할 수 있습니다.

Routes 모듈은 어떻게 되나요? 경로(routes)는 응용 프로그램이 구현하는 다른 URL입니다. Flask에서 응용 프로그램 경로에 대한 처리기는 뷰 함수라고하는 Python 함수로 작성됩니다. 보기 기능은 하나 이상의 경로 URL에 매핑되므로 클라이언트가 지정된 URL을 요청할 때 Flask가 실행할 논리를 알 수 있습니다.

app/routes.py라는 새 모듈에 작성해야하는 첫 번째보기 기능은 다음과 같습니다.

`app/routes.py: Home page route`

```python
from app import app

@app.route('/')
@app.route('/index')
def index():
    return "Hello, World!"
```

이 뷰 함수는 실제로 매우 간단합니다. 인사말을 문자열로 반환합니다. 함수 위의 두 가지 이상한 @ app.route 줄은 파이썬 언어의 고유 한 기능인 데코레이터입니다. 데코레이터는 뒤 따르는 기능을 수정합니다. **데코레이터의 일반적인 패턴은 이를 사용하여 특정 이벤트에 대한 콜백으로 함수를 등록하는 것입니다.** 이 경우 @ app.route 데코레이터는 인수로 제공된 URL과 함수 사이에 연결을 만듭니다. 이 예에는 URL / 및 /index를 이 함수에 연결하는 데코레이터가 두 개 있습니다. 이것은 웹 브라우저가이 두 URL 중 하나를 요청할 때 Flask가 이 함수를 호출하고 응답으로 그 반환 값을 브라우저에 다시 전달한다는 것을 의미합니다. 아직 완벽하게 이해되지 않으면 이 응용 프로그램을 실행할 때 약간만 나타납니다.

응용 프로그램을 완료하려면 Flask 응용 프로그램 인스턴스를 정의하는 최상위 수준의 Python 스크립트가 있어야합니다. 이 스크립트 microblog.py를 호출하여 응용 프로그램 인스턴스를 가져 오는 단일 행으로 정의 해 보겠습니다.

`microblog.py: Main application module`

```python
from app import app
```

두 앱 엔티티를 기억하십니까? 여기 같은 문장에서 둘 다 함께 볼 수 있습니다. Flask 응용 프로그램 인스턴스는 app이라고하며 app 패키지의 멤버입니다. from app import app 문은 app 패키지의 멤버 인 app 변수를 가져옵니다. 이 혼란스러운 것을 발견하면 패키지 또는 변수 이름을 다른 것으로 바꿀 수 있습니다.

모든 것을 올바르게하고 있는지 확인하기 위해 아래에서 프로젝트 구조 다이어그램을 볼 수 있습니다.

```bash
microblog/
  venv/
  app/
    __init__.py
    routes.py
  microblog.py
```

믿거 나 말거나,이 첫 번째 버전의 응용 프로그램이 완성되었습니다! 그러나 FLASK_APP 환경 변수를 설정하여 Flask를 가져 오는 방법을 알려 주어야합니다.

```bash
(venv) $ export FLASK_APP=microblog.py
```

Microsoft Windows를 사용하는 경우 위 명령에서 export 대신 set을 사용하십시오.

날아갈 준비가 되셨습니까? 다음 명령을 사용하여 첫 번째 웹 응용 프로그램을 실행할 수 있습니다.

```bash
(venv) $ flask run
 * Serving Flask app "microblog"
 * Running on http://127.0.0.1:5000/ (Press CTRL+C to quit)
```

서버가 초기화 된 후 클라이언트 연결을 기다립니다. Flask 실행 결과는 서버가 항상 자신의 컴퓨터 주소 인 IP 주소 127.0.0.1에서 실행되고 있음을 나타냅니다. 이 주소는 너무 일반적이므로 이전에 볼 수 있었던 더 간단한 이름 인 localhost도 있습니다. 네트워크 서버는 특정 포트 번호에서 연결을 수신합니다. 프로덕션 웹 서버에 배포 된 응용 프로그램은 일반적으로 포트 443을 수신하거나 암호화를 구현하지 않으면 80을 수신하지만 이러한 포트에 액세스하려면 관리 권한이 필요합니다. 이 응용 프로그램은 개발 환경에서 실행되므로 Flask는 무료로 사용할 수있는 포트 5000을 사용합니다. 이제 웹 브라우저를 열고 주소 필드에 다음 URL을 입력하십시오.

```bash
http://localhost:5000/
```

또는이 다른 URL을 사용할 수 있습니다.

```bash
http://localhost:5000/index
```

응용 프로그램 경로 매핑이 실제로 표시됩니까? 첫 번째 URL은 /에 매핑되고 두 번째 URL은 / index에 매핑됩니다. 두 라우트는 응용 프로그램에서 유일한보기 함수와 연관되므로 함수가 리턴하는 문자열 인 동일한 출력을 생성합니다. 다른 URL을 입력하면 응용 프로그램에서이 두 URL 만 인식하므로 오류가 발생합니다.

![](.\images\ch01-hello-world.png)

서버를 다 사용한 후에는 Ctrl-C를 눌러 중지 할 수 있습니다.

축하합니다. 웹 개발자가되기위한 첫 번째 큰 단계를 완료하셨습니다.

이 장을 마치기 전에 한 가지 더 언급하고 싶습니다. 환경 변수는 터미널 세션에서 기억되지 않으므로 새 터미널 창을 열 때 항상 FLASK_APP 환경 변수를 설정해야하는 번거 로움이 있습니다. 버전 1.0부터 Flask를 사용하면 flask 명령을 실행할 때 자동으로 가져올 환경 변수를 등록 할 수 있습니다. 이 옵션을 사용하려면 python-dotenv 패키지를 설치해야합니다.

```bash
(venv) $ pip install python-dotenv
```

그런 다음 환경 변수 이름과 값을 프로젝트의 최상위 디렉토리에있는 .flaskenv 파일에 쓸 수 있습니다.

`.flaskenv: Environment variables for flask command`

```python
FLASK_APP=microblog.py
```

이 작업은 선택 사항입니다. 환경 변수를 수동으로 설정하려면 항상 기억하는 한 완벽하게 좋습니다.



## [Part II: Templates](https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-ii-templates)

Flask Mega-Tutorial 시리즈의 두 번째 기사에서는 템플릿 작업 방법에 대해 설명하겠습니다.

1 장을 완료 한 후에는 다음과 같은 파일 구조를 가진 완전히 작동하지만 간단한 웹 응용 프로그램이 있어야합니다.

```bash
microblog\
  venv\
  app\
    __init__.py
    routes.py
  microblog.py
```

응용 프로그램을 실행하려면 터미널 세션에서 set FLASK_APP=microblog.py를 설정 한 다음 flask run을 실행하십시오. 웹 브라우저의 주소 표시 줄에 http://localhost:5000/ URL을 입력하여 열 수있는 응용 프로그램으로 웹 서버가 시작됩니다.

이 장에서는 동일한 응용 프로그램에서 계속 작업하며, 특히 복잡한 구조와 많은 동적 구성 요소를 가진 보다 정교한 웹 페이지를 생성하는 방법을 배웁니다. 지금까지 응용 프로그램 또는 개발 워크 플로에 대해 명확하지 않은 경우 계속하기 전에 1 장을 다시 검토하십시오.

이 장의 GitHub 링크는 다음과 같습니다: *[Browse](https://github.com/miguelgrinberg/microblog/tree/v0.2), [Zip](https://github.com/miguelgrinberg/microblog/archive/v0.2.zip), [Diff](https://github.com/miguelgrinberg/microblog/compare/v0.1...v0.2).*



### 템플릿이란 무엇입니까?

마이크로 블로깅 응용 프로그램의 홈 페이지에 사용자를 환영하는 제목이 있어야합니다. 지금은 나중에 응용 프로그램에 사용자 개념이 없다는 사실을 무시할 것입니다. 대신, 다음과 같이 모의 사용자를 사용하여 파이썬 사전으로 구현할 것입니다.

```python
user = {'username': 'Miguel'}
```

모의 객체를 만드는 것은 아직 존재하지 않는 시스템의 다른 부분에 대해 걱정할 필요없이 응용 프로그램의 한 부분에 집중할 수있는 유용한 기술입니다. 내 응용 프로그램의 홈 페이지를 디자인하고 싶습니다. 저를 혼란스럽게 할 사용자 시스템이 없다는 사실을 원하지 않으므로 계속 진행할 수 있도록 사용자 개체를 구성하면됩니다.

응용 프로그램의 뷰 함수는 간단한 문자열을 반환합니다. 내가 지금하고 싶은 것은 반환 된 문자열을 완전한 HTML 페이지로 확장하는 것입니다.

`app/routes.py: Return complete HTML page from view function`

```python
from app import app

@app.route('/')
@app.route('/index')
def index():
    user = {'username': 'Miguel'}
    return '''
<html>
    <head>
        <title>Home Page - Microblog</title>
    </head>
    <body>
        <h1>Hello, ''' + user['username'] + '''!</h1>
    </body>
</html>'''
```

HTML에 익숙하지 않은 경우 Wikipedia에서 [HTML 마크업](https://en.wikipedia.org/wiki/HTML#Markup)을 읽는것이 좋습니다.

위와 같이보기 기능을 업데이트하고 응용 프로그램이 브라우저에서 어떻게 보이는지보십시오.

![](./images/ch02-mock-user.png)

브라우저에 HTML을 전달하기 위해 위에서 사용한 솔루션이 좋지 않다는 것에 동의합니다. 사용자의 블로그 게시물이 지속적으로 변경 될 때 이 뷰 함수의 코드가 얼마나 복잡할 지 고려하십시오. 응용 프로그램에는 다른 URL과 관련된 더 많은보기 기능이있을 것이므로 언젠가 이 응용 프로그램의 레이아웃을 변경하기로 결정하고 모든보기 기능에서 HTML을 업데이트해야한다고 상상해보십시오. 이것은 응용 프로그램이 증가함에 따라 확장 될 수있는 옵션이 아닙니다.

응용 프로그램의 논리를 웹 페이지의 레이아웃이나 프레젠테이션과 분리하여 유지할 수 있다면 상황이 훨씬 더 잘 정리 될 것입니다. Python으로 응용 프로그램 논리를 코딩하는 동안 웹 디자이너를 고용하여 킬러 웹 사이트를 만들 수도 있습니다.

템플릿은 프리젠 테이션과 비즈니스 로직을 구분하는 데 도움이됩니다. Flask에서 템플릿은 별도의 파일로 작성되며 응용 프로그램 패키지 안에있는 템플릿 폴더에 저장됩니다. 따라서 마이크로 블로그 디렉토리에 있는지 확인한 후 템플리트가 저장 될 디렉토리를 작성하십시오.

```bash
(venv) $ mkdir app/templates
```

아래에서 첫 번째 템플릿을 볼 수 있는데, 위의 index ()보기 함수가 반환 한 HTML 페이지와 기능면에서 유사합니다. 이 파일을 app/templates/index.html에 작성하십시오.

`app/templates/index.html: Main page template`

```html
<html>
    <head>
        <title>{{ title }} - Microblog</title>
    </head>
    <body>
        <h1>Hello, {{ user.username }}!</h1>
    </body>
</html>
```

이것은 가장 표준적인 HTML 페이지입니다. 이 페이지에서 유일하게 흥미로운 점은 {{...}} 섹션으로 묶인 동적 컨텐츠에 대한 두 개의 자리 표시자가 있다는 것입니다. 이 자리 표시자는 가변적이며 런타임시에만 알려진 페이지 부분을 나타냅니다.

이제 페이지의 프리젠 테이션이 HTML 템플리트로 오프로드 되었으므로 보기 기능을 단순화 할 수 있습니다.

`app/routes.py: Use render\_template() function`

```python
from flask import render_template
from app import app

@app.route('/')
@app.route('/index')
def index():
    user = {'username': 'Miguel'}
    return render_template('index.html', title='Home', user=user)
```

이것은 훨씬 나아 보입니다. 이 새 버전의 응용 프로그램을 사용하여 템플릿 작동 방식을 확인하십시오. 브라우저에 페이지가로드되면 소스 HTML을보고 원본 템플릿과 비교할 수 있습니다.

템플릿을 완전한 HTML 페이지로 변환하는 작업을 렌더링이라고합니다. 템플릿을 렌더링하려면 Flask 프레임 워크와 함께 제공되는 `render_template()`이라는 함수를 가져와야했습니다. 이 함수는 템플릿 파일 이름과 템플릿 인수의 변수 목록을 가져와 동일한 템플릿을 반환하지만 모든 자리 표시자가 실제 값으로 바뀝니다.

`render_template()` 함수는 Flask 프레임 워크와 함께 제공되는 [Jinja2](http://jinja.pocoo.org/) 템플릿 엔진을 호출합니다. Jinja2는 `{{...}}` 블록을 `render_template()` 호출에 제공된 인수로 제공된 해당 값으로 대체합니다.



### 조건문

Jinja2가 렌더링 중에 자리 표시자를 실제 값으로 바꾸는 방법을 보았지만 이는 Jinja2가 템플릿 파일에서 지원하는 많은 강력한 작업 중 하나 일뿐입니다. 예를 들어, 템플릿은 `{% ... %}` 블록 안에 제공된 제어문도 지원합니다. Index.html 템플릿의 다음 버전은 조건문을 추가합니다.

`app/templates/index.html: Conditional statement in template`

```html
<html>
    <head>
        {% if title %}
        <title>{{ title }} - Microblog</title>
        {% else %}
        <title>Welcome to Microblog!</title>
        {% endif %}
    </head>
    <body>
        <h1>Hello, {{ user.username }}!</h1>
    </body>
</html>
```

이제 템플릿이 조금 더 똑똑해졌습니다. View 함수가 title placeholder 변수에 대한 값을 전달하는 것을 잊어 버린 경우 빈 제목을 표시하는 대신 템플리트가 기본 제목을 제공합니다. View 함수의 `render_template()` 호출에서 title 인수를 제거하여이 조건이 작동하는 방식을 시도 할 수 있습니다.



### 루프

로그인 한 사용자는 홈 페이지에서 연결된 사용자의 최근 게시물을보고 싶을 것이므로 이제는 응용 프로그램을 확장하여 지원합니다.

다시 한 번, 몇 가지 사용자와 게시 할 게시물을 만들기 위해 편리한 가짜 개체 트릭을 사용합니다.

`app/routes.py: Fake posts in view function`

```python
from flask import render_template
from app import app

@app.route('/')
@app.route('/index')
def index():
    user = {'username': 'Miguel'}
    posts = [
        {
            'author': {'username': 'John'},
            'body': 'Beautiful day in Portland!'
        },
        {
            'author': {'username': 'Susan'},
            'body': 'The Avengers movie was so cool!'
        }
    ]
    return render_template('index.html', title='Home', user=user, posts=posts)
```

사용자 게시물을 나타 내기 위해 각 요소가 작성자 및 본문 필드가있는 사전 인 목록을 사용하고 있습니다. 실제 사용자와 블로그 게시물을 구현할 때 이러한 필드 이름을 최대한 보존하려고 노력하여 가짜 개체를 사용하여 홈페이지 템플릿을 디자인하고 테스트하는 모든 작업이 계속되도록합니다. 실제 사용자와 게시물을 소개 할 때 유효합니다.

템플릿 측면에서 나는 새로운 문제를 해결해야한다. 게시물 목록에는 여러 요소가있을 수 있으며 페이지에 표시 할 게시물 수를 결정하는 것은보기 기능에 달려 있습니다. 템플릿은 게시물 수에 대한 가정을 할 수 없으므로 뷰가 일반적인 방식으로 전송하는만큼 많은 게시물을 렌더링 할 수 있도록 준비해야합니다.

이러한 유형의 문제에 대해 Jinja2는 제어 구조를 제공합니다.

`app/templates/index.html: for-loop in template`

```html
<html>
    <head>
        {% if title %}
        <title>{{ title }} - Microblog</title>
        {% else %}
        <title>Welcome to Microblog</title>
        {% endif %}
    </head>
    <body>
        <h1>Hi, {{ user.username }}!</h1>
        {% for post in posts %}
        <div><p>{{ post.author.username }} says: <b>{{ post.body }}</b></p></div>
        {% endfor %}
    </body>
</html>
```

간단 하죠? 이 새로운 버전의 응용 프로그램을 사용 해보고 게시물 목록에 더 많은 내용을 추가하여 템플릿이 어떻게 적응하고 항상보기 기능이 보내는 모든 게시물을 렌더링하는지 확인하십시오.

![](./images/ch02-mock-posts.png)

### 템플릿 상속

요즘 대부분의 웹 애플리케이션에는 페이지 상단에 내비게이션 바가 있는데, 여기에는 프로파일 편집, 로그인, 로그 아웃 등과 같은 자주 사용되는 링크가 있습니다. 내비게이션 바를 `index.html` 에 쉽게 추가 할 수 있습니다. HTML이 더 많은 템플릿이 있지만 응용 프로그램이 커짐에 따라 다른 페이지에도 동일한 탐색 모음이 필요합니다. 많은 HTML 템플릿에서 탐색 모음의 여러 복사본을 유지 관리하고 싶지는 않지만 가능한 경우 자신을 반복하지 않는 것이 좋습니다.

Jinja2에는이 문제를 구체적으로 해결하는 템플릿 상속 기능이 있습니다. 본질적으로 모든 템플릿에 공통적 인 페이지 레이아웃 부분을 다른 템플릿이 파생 된 기본 템플릿으로 이동하면됩니다.

이제 내가 할 것은 간단한 탐색 표시 줄과 이전에 구현 한 제목 논리를 포함하는 base.html이라는 기본 템플릿을 정의하는 것입니다. app/templates/base.html 파일에 다음 템플릿을 작성해야합니다.

`app/templates/base.html: Base template with navigation bar`

```html
<html>
    <head>
      {% if title %}
      <title>{{ title }} - Microblog</title>
      {% else %}
      <title>Welcome to Microblog</title>
      {% endif %}
    </head>
    <body>
        <div>Microblog: <a href="/index">Home</a></div>
        <hr>
        {% block content %}{% endblock %}
    </body>
</html>
```

이 템플릿에서는 블록 제어 문을 사용하여 파생 템플릿이 스스로 삽입 할 수있는 위치를 정의했습니다. 블록에는 고유 한 이름이 부여되며, 파생 템플릿은 컨텐츠를 제공 할 때 참조 할 수 있습니다.

기본 템플릿을 사용하면 base.html에서 상속하여 index.html을 단순화 할 수 있습니다.

`app/templates/index.html: Inherit from base template`

```html
{% extends "base.html" %}

{% block content %}
    <h1>Hi, {{ user.username }}!</h1>
    {% for post in posts %}
    <div><p>{{ post.author.username }} says: <b>{{ post.body }}</b></p></div>
    {% endfor %}
{% endblock %}
```

base.html 템플릿은 이제 일반 페이지 구조를 처리하므로 index.html에서 해당 요소를 모두 제거하고 내용 부분 만 남겨 두었습니다. `extends` 문은 두 템플릿 간의 상속 링크를 설정하므로 Jinja2는 `index.html`을 렌더링하라는 요청을받을 때 `base.html` 를 포함시켜야한다는 것을 알 수 있습니다. 두 템플릿은 이름 내용과 일치하는 블록 문을 가지고 있으며 Jinja2가 두 템플릿을 하나로 결합하는 방법을 알고 있습니다. 이제 애플리케이션에 대한 추가 페이지를 작성해야하는 경우 동일한 `base.html` 템플리트에서 파생 된 템플리트로 작성할 수 있으며,이를 통해 애플리케이션의 모든 페이지가 동일한 모양과 느낌을 복제없이 공유 할 수 있습니다.

![](./images/ch02-inheritance.png)



## [Part III: Web Forms](https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-iii-web-forms)

이번장은 Flask Mega-Tutorial 시리즈의 세 번째 기사이며, Web Form을 사용하는 방법을 알려 드리겠습니다.

2 장에서 나는 응용 프로그램의 홈 페이지를위한 간단한 템플릿을 만들었고, 사용자 나 블로그 게시물과 같이 아직없는 것들에 대한 자리 표시 자로 가짜 객체를 사용했다. 이 장에서는이 응용 프로그램에 아직 남아있는 많은 구멍 중 하나, 특히 Web Form을 통해 사용자의 입력을받는 방법에 대해 설명하겠습니다.

Web Form은 모든 웹 응용 프로그램에서 가장 기본적인 구성 요소 중 하나입니다. 사용자가 블로그 게시물을 제출하고 응용 프로그램에 로그인 할 수 있도록 Form을 사용할 것입니다.

이 장을 진행하기 전에 이전 장에서 남겨둔 마이크로 블로그 응용 프로그램이 설치되어 있고 오류없이 실행할 수 있는지 확인하십시오.

이 장의 GitHub 링크는 다음과 같습니다: *[Browse](https://github.com/miguelgrinberg/microblog/tree/v0.3), [Zip](https://github.com/miguelgrinberg/microblog/archive/v0.3.zip), [Diff](https://github.com/miguelgrinberg/microblog/compare/v0.2...v0.3).*



### Flask -WTF 소개

이 응용 프로그램에서 Web Form을 처리하기 위해 Flask-WTF 확장을 사용하겠습니다. Flask-WTF 확장은 WTForms 패키지 주위에 Flask와 잘 통합 된 thin wrapper 입니다. 이것은 내가 당신에게 제시하는 첫 번째 플라스크 확장이지만 마지막이 아닙니다. 확장은 Flask가 의도적으로 평가되지 않은 문제에 대한 솔루션을 제공하므로 Flask 생태계에서 매우 중요한 부분입니다.

Flask 확장은 pip와 함께 설치되는 일반 Python 패키지입니다. 가상 환경에 Flask-WTF를 설치할 수 있습니다.

```bash
(venv) $ pip install flask-wtf
```



### 구성

지금까지 응용 프로그램은 매우 간단하므로 이러한 이유로 구성에 대해 걱정할 필요가 없습니다. 그러나 가장 간단한 응용 프로그램을 제외한 모든 응용 프로그램의 경우 Flask (및 사용하는 Flask 확장 프로그램)는 작업 수행 방법에 어느 정도의 자유를 제공하며 결정을 내려야합니다. 구성 변수 목록으로서의 프레임 워크

응용 프로그램이 구성 옵션을 지정하기위한 여러 형식이 있습니다. 가장 기본적인 솔루션은 변수를 사용하기 위해 사전 스타일을 사용하는 app.config에서 변수를 키로 정의하는 것입니다. 예를 들어 다음과 같이 할 수 있습니다.

```bash
app = Flask(__name__)
app.config['SECRET_KEY'] = 'you-will-never-guess'
# ... add more variables here as needed
```

위 구문은 Flask에 대한 구성 옵션을 작성하기에 충분하지만 우려 분리 원칙을 적용하고 싶습니다. 따라서 구성을 애플리케이션을 작성하는 동일한 위치에 배치하는 대신 약간 더 정교한 구조를 사용하여 구성을 별도의 파일로 유지합니다.

확장 성이 뛰어나서 정말 좋아하는 형식은 클래스를 사용하여 구성 변수를 저장하는 것입니다. 일을 잘 정리하기 위해 별도의 파이썬 모듈에서 구성 클래스를 만들 것입니다. 아래에서 이 응용 프로그램의 새로운 구성 클래스가 최상위 디렉토리의 config.py 모듈에 저장되어 있습니다.

`config.py: Secret key configuration`

```python
import os

class Config(object):
    SECRET_KEY = os.environ.get('SECRET_KEY') or 'you-will-never-guess'
```

아주 간단 하죠? 구성 설정은 Config 클래스 내에서 클래스 변수로 정의됩니다. 응용 프로그램에 더 많은 구성 항목이 필요하므로 이 클래스에 추가 할 수 있으며 나중에 둘 이상의 구성 세트가 필요한 경우 서브 클래스를 작성할 수 있습니다. 그러나 아직 걱정하지 마십시오.

유일한 구성 항목으로 추가 한 `SECRET_KEY` 구성 변수는 대부분의 Flask 응용 프로그램에서 중요한 부분입니다. Flask 및 일부 확장은 비밀 키의 값을 암호화 키로 사용하여 서명 또는 토큰을 생성하는 데 유용합니다. Flask-WTF 확장 기능은 이를 사용하여 `Cross-Site Request Forgery` 또는 CSRF ( 'seasurf'로 발음)라는 불쾌한 공격으로부터 Web Form을 보호합니다. 이름에서 알 수 있듯이 비밀 키는 비밀 키로 생성됩니다. 토큰과 함께 생성 된 토큰 및 서명의 강도는 응용 프로그램의 신뢰할 수있는 관리자 이외의 사람이 이를 알지 못하기 때문입니다.

비밀 키의 값은 or 연산자로 결합 된 두 개의 용어가있는 표현식으로 설정됩니다. 첫 번째 용어는 SECRET_KEY라고도하는 환경 변수의 값을 찾습니다. 두 번째 용어는 단지 하드 코드 된 문자열입니다. 이것은 구성 변수에 대해 자주 반복되는 패턴입니다. 환경 변수에서 제공되는 값이 선호되지만 환경에서 변수를 정의하지 않으면 하드 코딩 된 문자열이 대신 사용됩니다. 이 응용 프로그램을 개발할 때는 보안 요구 사항이 낮으므로 이 설정을 무시하고 하드 코드 된 문자열을 사용할 수 있습니다. 그러나 이 응용 프로그램이 프로덕션 서버에 배포되면 환경에서 고유하고 추측하기 어려운 값을 설정하여 서버가 아무도 모르는 안전한 키를 갖도록합니다.

이제 설정 파일이 생겼으므로 Flask에게 파일을 읽고 적용하도록 지시해야합니다. app.config.from_object () 메서드를 사용하여 Flask 응용 프로그램 인스턴스를 만든 직후에 수행 할 수 있습니다.

`app/__init__.py: Flask configuration`

```python
from flask import Flask
from config import Config

app = Flask(__name__)
app.config.from_object(Config)

from app import routes
```

Config 클래스를 가져 오는 방식이 처음에는 혼란스러워 보일 수 있지만 플라스크 패키지 (소문자 'f')에서 Flask 클래스 (대문자 'F')를 가져 오는 방법을 보면 구성과 동일한 작업을 수행합니다. 소문자 'config'는 Python 모듈 config.py의 이름이며 대문자 'C'가있는 것은 실제 클래스입니다.

위에서 언급했듯이 구성 항목은 app.config의 사전 구문으로 액세스 할 수 있습니다. 여기 비밀 키의 가치를 확인하는 Python 인터프리터와의 빠른 세션을 볼 수 있습니다.

```bash
>>> from microblog import app
>>> app.config['SECRET_KEY']
'you-will-never-guess'
```



### 사용자 로그인 Form

Flask-WTF 확장 프로그램은 Python 클래스를 사용하여 Web Form을 나타냅니다. 폼 클래스는 단순히 폼의 필드를 클래스 변수로 정의합니다.

다시 한 번 우려를 구분하면서 새로운 app/forms.py 모듈을 사용하여 Web Form 클래스를 저장하겠습니다. 먼저 사용자 로그인 양식을 정의하여 사용자에게 사용자 이름과 비밀번호를 입력하도록 요청하십시오. 이 Form에는 'remember me'확인란과 submit  버튼도 포함됩니다.

`app/forms.py: Login form`

```python
from flask_wtf import FlaskForm
from wtforms import StringField, PasswordField, BooleanField, SubmitField
from wtforms.validators import DataRequired

class LoginForm(FlaskForm):
    username = StringField('Username', validators=[DataRequired()])
    password = PasswordField('Password', validators=[DataRequired()])
    remember_me = BooleanField('Remember Me')
    submit = SubmitField('Sign In')
```

대부분의 Flask 확장 프로그램은 최상위 가져 오기 기호에 `flask_<name>` 명명 규칙을 사용합니다. 이 경우 Flask-WTF는 flask_wtf 아래에 모든 기호가 있습니다. FlaskForm 기본 클래스는 `app/forms.py`의 맨 위에서 가져옵니다.

Flask-WTF 확장은 사용자 정의 된 버전을 제공하지 않기 때문에 이 양식에 사용중인 필드 유형을 나타내는 네 가지 클래스를 WTForms 패키지에서 직접 가져옵니다. 각 필드에 대해 객체는 LoginForm 클래스에서 클래스 변수로 작성됩니다. 각 필드에는 첫 번째 인수로 설명 또는 레이블이 제공됩니다.

일부 필드에 표시되는 선택적 유효성 검사기 인수는 유효성 검사 동작을 필드에 연결하는 데 사용됩니다. DataRequired 유효성 검증기는 단순히 필드가 비어 있지 않은지 점검합니다. 사용 가능한 더 많은 유효성 검사기가 있으며 그 중 일부는 다른 형식으로 사용됩니다.



### Form 템플릿

다음 단계는 웹 페이지에서 렌더링 될 수 있도록 HTML 템플리트에 양식을 추가하는 것입니다. 좋은 소식은 LoginForm 클래스에 정의 된 필드가 자신을 HTML로 렌더링하는 방법을 알고 있으므로 이 작업은 매우 간단하다는 것입니다. 아래에서 app/templates/login.html 파일에 저장하려는 로그인 템플릿을 볼 수 있습니다.

`app/templates/login.html: Login form template`

```html
{% extends "base.html" %}

{% block content %}
    <h1>Sign In</h1>
    <form action="" method="post" novalidate>
        {{ form.hidden_tag() }}
        <p>
            {{ form.username.label }}<br>
            {{ form.username(size=32) }}
        </p>
        <p>
            {{ form.password.label }}<br>
            {{ form.password(size=32) }}
        </p>
        <p>{{ form.remember_me() }} {{ form.remember_me.label }}</p>
        <p>{{ form.submit() }}</p>
    </form>
{% endblock %}
```

이 템플릿에서는 확장 템플릿 상속 문을 통해 2 장에 표시된 것처럼 `base.html` 템플릿을 한 번 더 재사용합니다. 실제로 모든 템플릿에서 이 작업을 수행하여 응용 프로그램의 모든 페이지에서 상단 탐색 모음이 포함 된 일관된 레이아웃을 보장합니다.

이 템플리트는 LoginForm 클래스에서 인스턴스화 된 양식 오브젝트가 인수로 제공 될 것으로 예상하며,이를 양식으로 참조 할 수 있습니다. 이 인수는 아직 작성하지 않은 login view 함수에 의해 전송됩니다.

HTML 양식 요소는 Web Form의 컨테이너로 사용됩니다. 양식의 action 속성은 사용자가 양식에 입력 한 정보를 제출할 때 사용해야하는 URL을 브라우저에 알리는 데 사용됩니다. 조치가 빈 문자열로 설정되면 양식은 현재 주소 표시 줄에있는 URL (페이지에서 양식을 렌더링 한 URL)로 제출됩니다. Method 속성은 서버에 양식을 제출할 때 사용해야하는 HTTP 요청 방법을 지정합니다. 기본값은 GET 요청과 함께 전송하는 것이지만 대부분의 경우 POST 요청을 사용하면 이 유형의 요청이 요청 본문에 양식 데이터를 제출할 수있는 반면 GET 요청은 양식을 추가하므로 사용자 환경이 향상됩니다. 브라우저 주소 표시 줄을 복잡하게 만듭니다. Novalidate 속성은이 양식의 필드에 유효성 검사를 적용하지 않도록 웹 브라우저에 지시하는 데 사용되며,이 작업을 서버에서 실행중인 Flask 응용 프로그램에 효과적으로 남겨 둡니다. Novalidate를 사용하는 것은 전적으로 선택 사항이지만이 첫 번째 형식의 경우이 장의 뒷부분에서 서버 측 유효성 검사를 테스트 할 수 있으므로이를 설정하는 것이 중요합니다.

`form.hidden_tag()` 템플릿 인수는 CSRF 공격으로부터 양식을 보호하는 데 사용되는 토큰을 포함하는 숨겨진 필드를 생성합니다. 양식을 보호하려면 이 숨겨진 필드를 포함하고 Flask 구성에 SECRET_KEY 변수를 정의하기 만하면됩니다. 이 두 가지를 처리하면 Flask-WTF가 나머지를 대신합니다.

과거에 HTML Web Form을 작성했다면 이 템플릿에 HTML 필드가없는 것이 이상 할 수 있습니다. 양식 객체의 필드가 자신을 HTML로 렌더링하는 방법을 알고 있기 때문입니다. 내가해야 할 일은 {{form.<field_name>.label}} 여기서 필드 레이블을 원했고 {{form.<field_name>() }} 필드를 원했습니다. 추가 HTML 속성이 필요한 필드의 경우 인수로 전달할 수 있습니다. 이 템플리트의 사용자 이름 및 비밀번호 필드는 크기를 입력 HTML 요소에 속성으로 추가 될 인수로 사용합니다. CSS 클래스 또는 ID를 첨부하여 필드를 구성 할 수도 있습니다.



### 폼 뷰

브라우저에서 이 양식을보기 전에 마지막 단계는 이전 섹션에서 템플릿을 렌더링하는 새로운보기 기능을 응용 프로그램에서 코딩하는 것입니다.

폼을 생성하는 /login URL에 매핑 된 새로운 뷰 함수를 작성하고 렌더링을 위해 템플릿으로 전달해 봅시다. 이 뷰 함수는 app/routes.py 모듈에서 이전과 함께 사용할 수도 있습니다.

`app/routes.py: Login view function`

```python
from flask import render_template
from app import app
from app.forms import LoginForm

# ...

@app.route('/login')
def login():
    form = LoginForm()
    return render_template('login.html', title='Sign In', form=form)
```

내가 여기서 한 일은 forms.py에서 `LoginForm` 클래스를 가져 와서 객체를 인스턴스화 한 다음 템플릿으로 보낸 것입니다. `form=form` 구문은 이상하게 보일 수 있지만 단순히 위의 행에서 작성되고 (오른쪽에 표시되는) 양식 오브젝트를 이름 양식 (왼쪽에 표시)이있는 템플리트로 전달합니다. 이것은 양식 필드를 렌더링하는 데 필요한 전부입니다.

로그인 양식에 쉽게 액세스 할 수 있도록 기본 템플리트는 탐색 모음에 해당 양식에 대한 링크를 포함 할 수 있습니다.

`app/templates/base.html: Login link in navigation bar`

```html
<div>
    Microblog:
    <a href="/index">Home</a>
    <a href="/login">Login</a>
</div>
```

이제 응용 프로그램을 실행하고 웹 브라우저에서 양식을 볼 수 있습니다. 응용 프로그램이 실행중인 상태에서 브라우저의 주소 표시 줄에 http://localhost:5000/을 입력 한 다음 맨 위 탐색 표시 줄에서 '로그인'링크를 클릭하여 새 로그인 양식을보십시오. 멋지다?

![](./images/ch03-login-form.png)

### Form 데이터 받기

제출 버튼을 누르면 브라우저에 'Method Not Allowed'오류가 표시됩니다. 이전 섹션의 로그인보기 기능이 지금까지 작업의 절반을 수행하기 때문입니다. 웹 페이지에 양식을 표시 할 수 있지만 아직 사용자가 제출 한 데이터를 처리하는 논리는 없습니다. 이것은 Flask-WTF가 작업을 정말 쉽게 만드는 또 다른 영역입니다. 다음은 사용자가 제출 한 데이터를 승인하고 확인하는 보기 기능의 업데이트 된 버전입니다.

`app/routes.py: Receiving login credentials`

```python
from flask import render_template, flash, redirect

@app.route('/login', methods=['GET', 'POST'])
def login():
    form = LoginForm()
    if form.validate_on_submit():
        flash('Login requested for user {}, remember_me={}'.format(
            form.username.data, form.remember_me.data))
        return redirect('/index')
    return render_template('login.html', title='Sign In', form=form)
```

이 버전의 첫 번째 새로운 것은 경로 데코레이터의 methods 인수입니다. 이것은 Flask에게 이 뷰 함수가 GET 및 POST 요청을 수락하고 GET 요청 만 수락하는 기본값을 무시 함을 알려줍니다. HTTP 프로토콜은 GET 요청이 클라이언트 (이 경우 웹 브라우저)에 정보를 리턴하는 요청이라고 명시합니다. 지금까지 애플리케이션의 모든 요청은이 유형입니다. POST 요청은 일반적으로 브라우저가 서버에 양식 데이터를 제출할 때 사용됩니다 (실제로 GET 요청도이  목적으로 사용될 수 있지만 권장되지는 않습니다). 브라우저가 POST 요청을 보내려고했으나 응용 프로그램이 이를 승인하도록 구성되지 않았기 때문에 브라우저가 이전에 표시 한 'Method Not Allowed'오류가 나타납니다. Methods 인수를 제공하면 Flask에게 어떤 요청 메소드를 승인해야하는지 알려줍니다.

form.validate_on_submit () 메소드는 모든 양식 처리 작업을 수행합니다. 브라우저가 양식과 함께 웹 페이지를 수신하기 위해 GET 요청을 보내면 이 메소드는 False를 리턴하므로,이 경우 함수는 if 문을 건너 뛰고 함수의 마지막 행에 템플리트를 직접 렌더링합니다.

사용자가 제출 버튼을 누르면 브라우저가 POST 요청을 보내면 form.validate_on_submit ()은 모든 데이터를 수집하고 필드에 연결된 모든 유효성 검사기를 실행하며 모든 것이 정상이면 True를 반환합니다. 데이터가 유효하고 응용 프로그램에서 처리 할 수 있음을 나타냅니다. 그러나 적어도 하나의 필드가 유효성 검사에 실패하면 함수는 False를 반환하므로 GET 요청 사례와 같이 양식이 사용자에게 다시 렌더링됩니다. 나중에 유효성 검사에 실패하면 오류 메시지를 추가하겠습니다.

form.validate_on_submit ()가 True를 반환하면 로그인 보기 함수는 Flask에서 가져온 두 가지 새로운 함수를 호출합니다. Flash () 함수는 사용자에게 메시지를 표시하는 유용한 방법입니다. 많은 응용 프로그램에서 이 기술을 사용하여 일부 작업의 성공 여부를 사용자에게 알립니다. 이 경우 이 메커니즘을 임시 솔루션으로 사용하려고합니다. 왜냐하면 사용자를 로그인하는 데 필요한 모든 인프라가 아직 없기 때문입니다. 내가 지금 할 수있는 최선은 응용 프로그램이 자격 증명을 받았음을 확인하는 메시지를 표시하는 것입니다.

로그인보기 함수에 사용 된 두 번째 새 함수는 redirect ()입니다. 이 함수는 클라이언트 웹 브라우저가 인수로 지정된 다른 페이지로 자동 탐색하도록 지시합니다. 이보기 기능은 이 기능을 사용하여 사용자를 응용 프로그램의 색인 페이지로 리디렉션합니다.

Flash () 함수를 호출하면 Flask가 메시지를 저장하지만 플래시 된 메시지는 마술처럼 웹 페이지에 나타나지 않습니다. 응용 프로그램의 템플릿은 사이트 레이아웃에 적합한 방식으로 이러한 깜박이는 메시지를 렌더링해야합니다. 이 템플릿을 기본 템플릿에 추가하여 모든 템플릿이 이 기능을 상속합니다. 업데이트 된 기본 템플릿입니다.

`app/templates/base.html: Flashed messages in base template`

```html
<html>
    <head>
        {% if title %}
        <title>{{ title }} - microblog</title>
        {% else %}
        <title>microblog</title>
        {% endif %}
    </head>
    <body>
        <div>
            Microblog:
            <a href="/index">Home</a>
            <a href="/login">Login</a>
        </div>
        <hr>
        {% with messages = get_flashed_messages() %}
        {% if messages %}
        <ul>
            {% for message in messages %}
            <li>{{ message }}</li>
            {% endfor %}
        </ul>
        {% endif %}
        {% endwith %}
        {% block content %}{% endblock %}
    </body>
</html>
```

여기서는 with 구문을 사용하여 get_flashed_messages () 호출 결과를 템플릿 컨텍스트에서 메시지 변수에 할당합니다. get_flashed_messages () 함수는 Flask에서 제공되며 이전에 flash ()로 등록 된 모든 메시지 목록을 반환합니다. 다음 조건은 메시지에 내용이 있는지 확인하고이 경우 <ul> 요소는 각 메시지와 함께 <li> 목록 항목으로 렌더링됩니다. 이 스타일의 렌더링은 멋지지 않지만 웹 응용 프로그램의 스타일 지정 주제는 나중에 제공됩니다.

이러한 플래시 메시지의 흥미로운 특성은 get_flashed_messages 함수를 통해 한 번 요청하면 메시지 목록에서 제거되므로 flash () 함수가 호출 된 후에 한 번만 나타납니다.

응용 프로그램을 한 번 더 시도하고 양식의 작동 방식을 테스트하기에 좋은시기입니다. DataRequired 유효성 검증 기가 제출 프로세스를 정지시키는 방법을 보려면 사용자 이름 또는 비밀번호 필드를 비워 양식을 제출하십시오.



### 필드 유효성 검사 개선

양식 필드에 첨부 된 유효성 검증기는 유효하지 않은 데이터가 애플리케이션에 허용되지 않도록합니다. 응용 프로그램이 잘못된 양식 입력을 처리하는 방법은 양식을 다시 표시하여 사용자가 필요한 수정을 할 수 있도록하는 것입니다.

유효하지 않은 데이터를 제출하려고하면 유효성 검사 메커니즘이 제대로 작동하지만 양식에 문제가 있음을 사용자에게 알려주지 않고 단순히 양식을 가져옵니다. 다음 작업은 유효성 검사에 실패한 각 필드 옆에 의미있는 오류 메시지를 추가하여 사용자 경험을 향상시키는 것입니다.

실제로 양식 유효성 검사기는 이러한 설명 오류 메시지를 이미 생성하므로 템플릿에서 렌더링 할 수있는 추가 논리 만 있으면됩니다.

사용자 이름 및 비밀번호 필드에 필드 유효성 검증 메시지가 추가 된 로그인 템플리트는 다음과 같습니다.

`app/templates/login.html: Validation errors in login form template`

```html
{% extends "base.html" %}

{% block content %}
    <h1>Sign In</h1>
    <form action="" method="post" novalidate>
        {{ form.hidden_tag() }}
        <p>
            {{ form.username.label }}<br>
            {{ form.username(size=32) }}<br>
            {% for error in form.username.errors %}
            <span style="color: red;">[{{ error }}]</span>
            {% endfor %}
        </p>
        <p>
            {{ form.password.label }}<br>
            {{ form.password(size=32) }}<br>
            {% for error in form.password.errors %}
            <span style="color: red;">[{{ error }}]</span>
            {% endfor %}
        </p>
        <p>{{ form.remember_me() }} {{ form.remember_me.label }}</p>
        <p>{{ form.submit() }}</p>
    </form>
{% endblock %}
```

내가 만든 유일한 변경 사항은 유효성 검사기에 의해 추가 된 오류 메시지를 빨간색으로 렌더링하는 사용자 이름 및 비밀번호 필드 바로 뒤에 for 루프를 추가하는 것입니다. 일반적으로 유효성 검사기가 첨부 된 모든 필드에는 형식에 따라 오류 메시지가 추가됩니다. Field_name .errors. 필드에는 여러 개의 유효성 검사기가 첨부되어 있고 둘 이상의 오류 메시지가 사용자에게 표시 될 수 있으므로 목록이됩니다.

빈 사용자 이름 또는 비밀번호로 양식을 제출하려고하면 빨간색으로 멋진 오류 메시지가 표시됩니다.

![](./images/ch03-validation.png)

### 링크 생성

로그인 양식은 이제 완전히 완성되었지만이 장을 닫기 전에 템플릿과 리디렉션에 링크를 포함시키는 올바른 방법에 대해 논의하고 싶었습니다. 지금까지 링크가 정의 된 몇 가지 예를 보았습니다. 예를 들어 다음은 기본 템플릿의 현재 탐색 모음입니다.

```html
   <div>
        Microblog:
        <a href="/index">Home</a>
        <a href="/login">Login</a>
    </div>
```

로그인보기 함수는 redirect () 함수로 전달되는 링크도 정의합니다.

```python
@app.route('/login', methods=['GET', 'POST'])
def login():
    form = LoginForm()
    if form.validate_on_submit():
        # ...
        return redirect('/index')
    # ...
```

템플릿과 소스 파일에 직접 링크를 작성하는 데있어 한 가지 문제점은 언젠가 링크를 재구성하기로 결정한 경우 전체 애플리케이션에서 이러한 링크를 검색하고 교체해야한다는 것입니다.

이러한 링크를보다 효과적으로 제어하기 위해 Flask는 url_for ()라는 함수를 제공합니다.이 함수는 URL의 내부 매핑을 사용하여 함수를보기 위해 URL을 생성합니다. 예를 들어, url_for ( 'login')은 / login을 리턴하고 url_for ( 'index')는 '/ index를 리턴합니다. Url_for ()의 인수는 엔드 포인트 이름으로, 뷰 함수의 이름입니다.

URL 대신 함수 이름을 사용하는 것이 더 좋은 이유를 물을 수 있습니다. 사실 URL은 완전히 내부적 인 뷰 함수 이름보다 변경 될 가능성이 훨씬 높습니다. 두 번째 이유는 나중에 배우는 것처럼 일부 URL에는 동적 구성 요소가 있으므로 해당 URL을 직접 생성하려면 여러 요소를 연결해야하므로 지루하고 오류가 발생하기 쉽습니다. Url_for ()는 이러한 복잡한 URL을 생성 할 수도 있습니다.

이제부터는 응용 프로그램 URL을 생성해야 할 때마다 url_for ()를 사용합니다. 그러면 기본 템플릿의 탐색 모음이 다음과 같이됩니다.

`app/templates/base.html: Use url\_for() function for links`

```html
  <div>
      Microblog:
      <a href="{{ url_for('index') }}">Home</a>
      <a href="{{ url_for('login') }}">Login</a>
  </div>
```

업데이트 된 login () 뷰 함수는 다음과 같습니다.

`app/routes.py: Use url\_for() function for links`

```python
from flask import render_template, flash, redirect, url_for

# ...

@app.route('/login', methods=['GET', 'POST'])
def login():
    form = LoginForm()
    if form.validate_on_submit():
        # ...
        return redirect(url_for('index'))
    # ...
```



## [Part IV: Database](https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-iv-database)

이것은 Flask Mega-Tutorial 시리즈의 네 번째 기사이며 데이터베이스 작업 방법을 알려 드리겠습니다.

이 장의 주제는 매우 중요합니다. 대부분의 응용 프로그램에는 효율적으로 검색 할 수있는 영구 데이터를 유지 관리해야 할 필요가 있으며 이는 바로 데이터베이스를위한 것입니다.

이 장의 GitHub 링크는 다음과 같습니다: *[Browse](https://github.com/miguelgrinberg/microblog/tree/v0.4), [Zip](https://github.com/miguelgrinberg/microblog/archive/v0.4.zip), [Diff](https://github.com/miguelgrinberg/microblog/compare/v0.3...v0.4).*



### 플라스크의 데이터베이스

이미 들어 보신 것처럼 Flask는 기본적으로 데이터베이스를 지원하지 않습니다. 이것은 Flask가 의도적으로 평가되지 않은 많은 영역 중 하나입니다. 응용 프로그램에 적응하지 않고 응용 프로그램에 가장 적합한 데이터베이스를 자유롭게 선택할 수 있기 때문입니다.

Python에는 데이터베이스에 대한 다양한 선택이 있으며, 그중 다수는 Flask 확장을 통해 응용 프로그램과 더 잘 통합됩니다. 데이터베이스는 관계형 모델을 따르는 그룹과 그렇지 않은 그룹으로 나눌 수 있습니다. 후자의 그룹은 종종 NoSQL이라고하며 인기있는 관계형 쿼리 언어 SQL을 구현하지 않음을 나타냅니다. 두 그룹 모두에 훌륭한 데이터베이스 제품이 있지만, 관계형 데이터베이스는 사용자 목록, 블로그 게시물 등과 같은 데이터를 구조화 한 응용 프로그램에 더 적합하지만 NoSQL 데이터베이스는 덜 정의 된 구조. 이 응용 프로그램은 대부분의 다른 응용 프로그램과 마찬가지로 두 유형의 데이터베이스를 사용하여 구현할 수 있지만 위에서 언급 한 이유로 관계형 데이터베이스를 사용하겠습니다.

3 장에서 나는 당신에게 첫 번째 플라스크 확장을 보여 주었다. 이 장에서는 두 가지를 더 사용하겠습니다. 첫 번째는 Flask-SQLAlchemy로, Object Relational Mapper 또는 ORM 인 널리 사용되는 SQLAlchemy 패키지에 Flask 친화적 인 래퍼를 제공하는 확장입니다. ORM을 사용하면 응용 프로그램에서 테이블과 SQL 대신 클래스, 개체 및 메서드와 같은 고급 엔터티를 사용하여 데이터베이스를 관리 할 수 있습니다. ORM의 임무는 고급 작업을 데이터베이스 명령으로 변환하는 것입니다.

SQLAlchemy의 장점은 하나가 아니라 많은 관계형 데이터베이스에 대한 ORM이라는 것입니다. SQLAlchemy는 널리 사용되는 MySQL, PostgreSQL 및 SQLite를 포함하여 긴 데이터베이스 엔진 목록을 지원합니다. 서버가 필요없는 간단한 SQLite 데이터베이스를 사용하여 개발을 수행 할 수 있고 프로덕션 서버에 응용 프로그램을 배포 할 때 더 강력한 MySQL 또는 PostgreSQL 서버를 선택할 수 있기 때문에 이는 매우 강력합니다. 응용 프로그램을 변경하십시오.

가상 환경에 Flask-SQLAlchemy를 설치하려면 먼저 이를 활성화 한 후 다음을 실행하십시오.

```bash
(venv) $ pip install flask-sqlalchemy
```



### 데이터베이스 마이그레이션

내가 본 대부분의 데이터베이스 자습서는 데이터베이스 작성 및 사용을 다루지 만 응용 프로그램이 변경되거나 증가함에 따라 기존 데이터베이스를 업데이트하는 문제를 적절하게 다루지 않습니다. 관계형 데이터베이스는 구조화 된 데이터를 중심으로하기 때문에 어렵습니다. 따라서 구조가 변경 될 때 이미 데이터베이스에있는 데이터를 수정 된 구조로 마이그레이션해야합니다.

이 장에서 설명 할 두 번째 확장은 Flask-Migrate입니다. 실제로 Flask-Migrate는 실제로 여러분의 것입니다. 이 확장은 SQLAlchemy의 데이터베이스 마이그레이션 프레임 워크 인 Alembic 용 Flask 랩퍼입니다. 데이터베이스 마이그레이션 작업을 수행하면 데이터베이스를 시작하는 데 약간의 작업이 추가되지만 향후 데이터베이스를 변경할 수있는 강력한 방법을 지불하면 적은 비용이 듭니다.

Flask-Migrate의 설치 프로세스는 본 다른 확장과 유사합니다.

```bash
(venv) $ pip install flask-migrate
```



### Flask-SQLAlchemy 구성

개발 중에는 SQLite 데이터베이스를 사용하겠습니다. SQLite 데이터베이스는 각 응용 프로그램이 디스크의 단일 파일에 저장되며 MySQL 및 PostgreSQL과 같은 데이터베이스 서버를 실행할 필요가 없으므로 소규모 응용 프로그램을 개발하는 데 가장 편리한 선택입니다.

구성 파일에 추가 할 두 가지 새로운 구성 항목이 있습니다.

`config.py: Flask-SQLAlchemy configuration`

```
import os
basedir = os.path.abspath(os.path.dirname(__file__))

class Config(object):
    # ...
    SQLALCHEMY_DATABASE_URI = os.environ.get('DATABASE_URL') or \
        'sqlite:///' + os.path.join(basedir, 'app.db')
    SQLALCHEMY_TRACK_MODIFICATIONS = False
```

Flask-SQLAlchemy 확장은 SQLALCHEMY_DATABASE_URI 구성 변수에서 응용 프로그램 데이터베이스의 위치를 가져옵니다. 3 장을 기억할 때 일반적으로 환경 변수에서 구성을 설정하고 환경이 변수를 정의하지 않을 때 대체 값을 제공하는 것이 좋습니다. 이 경우 DATABASE_URL 환경 변수에서 데이터베이스 URL을 가져오고 정의되지 않은 경우 응용 프로그램의 기본 디렉토리에있는 app.db라는 데이터베이스를 구성합니다.이 데이터베이스는 basedir 변수에 저장됩니다 .

SQLALCHEMY_TRACK_MODIFICATIONS 구성 옵션은 내가 필요하지 않은 Flask-SQLAlchemy의 기능을 비활성화하기 위해 False로 설정되어 데이터베이스에서 변경 될 때마다 응용 프로그램에 신호를 보냅니다.

데이터베이스는 데이터베이스 인스턴스에 의해 응용 프로그램에 표시됩니다. 데이터베이스 마이그레이션 엔진에도 인스턴스가 있습니다. `app/__init__.py` 파일에서 어플리케이션 다음에 작성해야하는 오브젝트입니다.

`app/__init__.py: Flask-SQLAlchemy and Flask-Migrate initialization`

```python
from flask import Flask
from config import Config
from flask_sqlalchemy import SQLAlchemy
from flask_migrate import Migrate

app = Flask(__name__)
app.config.from_object(Config)
db = SQLAlchemy(app)
migrate = Migrate(app, db)

from app import routes, models
```

init 스크립트를 세 가지로 변경했습니다. 먼저 데이터베이스를 나타내는 db 객체를 추가했습니다. 그런 다음 마이그레이션 엔진을 나타내는 다른 개체를 추가했습니다. Flask 확장 기능을 사용하는 방법에 패턴이 있기를 바랍니다. 대부분의 확장은이 두 가지로 초기화됩니다. 마지막으로 맨 아래에 `models`이라는 새 모듈을 가져옵니다. 이 모듈은 데이터베이스의 구조를 정의합니다.



### 데이터베이스 모델

데이터베이스에 저장 될 데이터는 일반적으로 데이터베이스 모델이라고하는 클래스 모음으로 표시됩니다. SQLAlchemy 내의 ORM 계층은 이러한 클래스에서 작성된 오브젝트를 적절한 데이터베이스 테이블의 행으로 맵핑하는 데 필요한 변환을 수행합니다.

사용자를 나타내는 모델을 만들어 봅시다. [WWW SQL Designer](http://ondras.zarovi.cz/sql/demo) 도구를 사용하여 users 테이블에서 사용하려는 데이터를 나타 내기 위해 다음 다이어그램을 만들었습니다.

![](./images/ch04-users.png)

(역자주: [WWW SQL Designer](http://ondras.zarovi.cz/sql/demo) 는 온라인 에서 DB Table 의 Diagram 그리는것을 지원하는 Site 임 )

Id 필드는 일반적으로 모든 모델에 있으며 기본 키로 사용됩니다. 데이터베이스의 각 사용자에게는이 필드에 저장된 고유 한 id 값이 할당됩니다. 대부분의 경우 기본 키는 데이터베이스에 의해 자동으로 할당되므로 기본 키로 표시된 id 필드 만 제공하면됩니다.

Username, email 및 password_hash 필드는 문자열 (또는 데이터베이스 전문 용어의 VARCHAR)로 정의되며 데이터베이스가 공간 사용을 최적화 할 수 있도록 최대 길이가 지정됩니다. 사용자 이름과 이메일 필드는 자명하지만, password_hash 필드는주의를 기울여야합니다. 내가 구축하는 응용 프로그램이 보안 모범 사례를 채택하고 있는지 확인하고 싶기 때문에 데이터베이스에 사용자 암호를 저장하지 않을 것입니다. 암호 저장 문제는 데이터베이스가 손상되면 공격자가 암호에 액세스 할 수 있으며 사용자에게 치명적일 수 있다는 것입니다. 암호를 직접 작성하는 대신 암호 해시를 작성하여 보안을 크게 향상시킵니다. 이것은 다른 장의 주제가 될 것이므로 지금은 너무 걱정하지 마십시오.

이제 users 테이블에 원하는 것을 알고 있으므로 새 app / models.py 모듈에서 코드로 변환 할 수 있습니다.

`app/models.py: User database model`

```python
from app import db

class User(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    username = db.Column(db.String(64), index=True, unique=True)
    email = db.Column(db.String(120), index=True, unique=True)
    password_hash = db.Column(db.String(128))

    def __repr__(self):
        return '<User {}>'.format(self.username)    
```

위에서 생성 한 User 클래스는 Flask-SQLAlchemy의 모든 모델에 대한 기본 클래스 인 db.Model에서 상속됩니다. 이 클래스는 여러 필드를 클래스 변수로 정의합니다. 필드는 필드 유형을 인수로 사용하는 db.Column 클래스의 인스턴스로 작성됩니다. 예를 들어, 고유하고 색인화 된 필드를 표시 할 수있는 다른 선택적 인수는 데이터베이스 검색을 효율적으로 수행하는 데 중요합니다. .

`__repr__` 메소드는 파이썬에게이 클래스의 객체를 인쇄하는 방법을 알려줍니다. 이것은 디버깅에 유용합니다. 아래의 파이썬 인터프리터 세션에서 `__repr__()` 메소드가 작동하는 것을 볼 수 있습니다.

```python
>>> from app.models import User
>>> u = User(username='susan', email='susan@example.com')
>>> u
<User susan>
```



### 마이그레이션 리포지토리 생성

이전 섹션에서 작성된 모델 클래스는이 애플리케이션의 초기 데이터베이스 구조 (또는 스키마)를 정의합니다. 그러나 응용 프로그램이 계속 증가함에 따라 구조를 변경해야 할 필요성이 생겨 새로운 것을 추가 할 가능성이 높지만 때로는 항목을 수정하거나 제거 할 수도 있습니다. Alembic (Flask-Migrate에서 사용하는 마이그레이션 프레임 워크)은 데이터베이스를 처음부터 다시 작성하지 않아도되는 방식으로 이러한 스키마를 변경합니다.

이 어려운 작업을 수행하기 위해 Alembic은 마이그레이션 스크립트를 저장하는 디렉토리 인 마이그레이션 저장소를 유지 관리합니다. 데이터베이스 스키마가 변경 될 때마다 마이그레이션 세부 사항이 포함 된 마이그레이션 스크립트가 저장소에 추가됩니다. 데이터베이스에 마이그레이션을 적용하기 위해 이러한 마이그레이션 스크립트는 작성된 순서대로 실행됩니다.

플라스크 마이 그레이트는 플라스크 명령을 통해 해당 명령을 표시합니다. 플라스크 실행을 이미 보았습니다. 플라스크 고유의 하위 명령입니다. 플라스크 db 하위 명령은 Flask-Migrate에 의해 추가되어 데이터베이스 마이그레이션과 관련된 모든 것을 관리합니다. 플라스크 db init를 실행하여 마이크로 블로그 용 마이그레이션 저장소를 작성해 보겠습니다.

```bash
(venv) $ flask db init
  Creating directory /home/miguel/microblog/migrations ... done
  Creating directory /home/miguel/microblog/migrations/versions ... done
  Generating /home/miguel/microblog/migrations/alembic.ini ... done
  Generating /home/miguel/microblog/migrations/env.py ... done
  Generating /home/miguel/microblog/migrations/README ... done
  Generating /home/miguel/microblog/migrations/script.py.mako ... done
  Please edit configuration/connection/logging settings in
  '/home/miguel/microblog/migrations/alembic.ini' before proceeding.
```

플라스크 명령은 FLASK_APP 환경 변수를 사용하여 Flask 응용 프로그램이 어디에 있는지 확인합니다. 이 애플리케이션의 경우 1 장에서 설명한대로 FLASK_APP=microblog.py를 설정하려고합니다.

이 명령을 실행하면 몇 개의 파일과 버전 하위 디렉토리가 포함 된 새 마이그레이션 디렉토리가 나타납니다. 이 모든 파일은 지금부터 프로젝트의 일부로 취급되어야하며 특히 소스 제어에 추가되어야합니다.



### 최초의 데이터베이스 마이그레이션

마이그레이션 저장소가 준비되면 첫 번째 데이터베이스 마이그레이션을 작성해야합니다. 여기에는 사용자 데이터베이스 모델에 맵핑되는 users 테이블이 포함됩니다. 데이터베이스 마이그레이션을 작성하는 방법에는 수동 또는 자동의 두 가지가 있습니다. Alembic은 자동으로 마이그레이션을 생성하기 위해 데이터베이스 모델에서 정의한 데이터베이스 스키마를 데이터베이스에서 현재 사용 된 실제 데이터베이스 스키마와 비교합니다. 그런 다음 데이터베이스 스키마를 애플리케이션 모델과 일치시키는 데 필요한 변경 사항으로 마이그레이션 스크립트를 채 웁니다. 이 경우 이전 데이터베이스가 없으므로 자동 마이그레이션은 전체 사용자 모델을 마이그레이션 스크립트에 추가합니다. Flask db migrate 하위 명령은 다음과 같은 자동 마이그레이션을 생성합니다.

```bash
(venv) $ flask db migrate -m "users table"
INFO  [alembic.runtime.migration] Context impl SQLiteImpl.
INFO  [alembic.runtime.migration] Will assume non-transactional DDL.
INFO  [alembic.autogenerate.compare] Detected added table 'user'
INFO  [alembic.autogenerate.compare] Detected added index 'ix_user_email' on '['email']'
INFO  [alembic.autogenerate.compare] Detected added index 'ix_user_username' on '['username']'
  Generating /home/miguel/microblog/migrations/versions/e517276bb1c2_users_table.py ... done
```

이 명령의 출력은 Alembic이 마이그레이션에 포함시킨 내용에 대한 아이디어를 제공합니다. 처음 두 줄은 정보를 제공하기 때문에 무시해도됩니다. 그런 다음 사용자 테이블과 두 개의 인덱스를 찾았습니다. 그런 다음 마이그레이션 스크립트를 작성한 위치를 알려줍니다. E517276bb1c2 코드는 마이그레이션을 위해 자동으로 생성 된 고유 코드입니다 (다를 수 있음). -m 옵션과 함께 제공된 주석은 선택 사항이며 마이그레이션에 간단한 설명 텍스트를 추가합니다.

생성 된 마이그레이션 스크립트는 이제 프로젝트의 일부이므로 소스 제어에 통합해야합니다. 스크립트가 어떻게 보이는지 궁금하다면 스크립트를 검사하십시오. Upgrade () 및 downgrade ()라는 두 가지 기능이 있음을 알 수 있습니다. Upgrade () 함수는 마이그레이션을 적용하고 downgrade () 함수는 마이그레이션을 제거합니다. 이를 통해 Alembic은 다운 그레이드 경로를 사용하여 히스토리의 어느 시점으로, 심지어 이전 버전으로 데이터베이스를 마이그레이션 할 수 있습니다.

Flask db migrate 명령은 데이터베이스를 변경하지 않고 마이그레이션 스크립트 만 생성합니다. 데이터베이스에 변경 사항을 적용하려면 flask db upgrade 명령을 사용해야합니다.

```bash
(venv) $ flask db upgrade
INFO  [alembic.runtime.migration] Context impl SQLiteImpl.
INFO  [alembic.runtime.migration] Will assume non-transactional DDL.
INFO  [alembic.runtime.migration] Running upgrade  -> e517276bb1c2, users table
```

이 응용 프로그램은 SQLite를 사용하므로, 업그레이드 명령은 데이터베이스가 존재하지 않음을 감지하여이를 작성합니다 (이 명령이 완료된 후 app.db라는 파일이 추가됨, 즉 SQLite 데이터베이스 임). MySQL 및 PostgreSQL과 같은 데이터베이스 서버로 작업하는 경우 업그레이드를 실행하기 전에 데이터베이스 서버에서 데이터베이스를 작성해야합니다.

Flask-SQLAlchemy는 기본적으로 데이터베이스 테이블에 '뱀 사례'명명 규칙을 사용합니다. 위의 사용자 모델의 경우 데이터베이스의 해당 테이블 이름은 user입니다. AddressAndPhone 모델 클래스의 경우 테이블 이름은 address_and_phone입니다. 고유 한 테이블 이름을 선택하려면 `__tablename__`이라는 속성을 모델 클래스에 추가하고 원하는 이름을 문자열로 설정할 수 있습니다.



### 데이터베이스 업그레이드 및 다운 그레이드 워크 플로우

이 시점에서 응용 프로그램이 초기 단계에 있지만 앞으로 데이터베이스 마이그레이션 전략이 무엇인지 논의하는 데 아무런 문제가 없습니다. 개발 컴퓨터에 응용 프로그램이 있고 온라인 및 사용중인 프로덕션 서버에 사본을 배포했다고 가정 해보십시오.

다음 릴리스의 앱에서는 모델에 변경 사항을 도입해야합니다 (예 : 새 테이블 추가). 마이그레이션이 없으면 개발 시스템과 서버에서 데이터베이스의 스키마를 변경하는 방법을 알아 내야하며 이는 많은 작업이 될 수 있습니다.

그러나 데이터베이스 마이그레이션 지원을 사용하면 애플리케이션에서 모델을 수정 한 후 새 마이그레이션 스크립트 (flask db migration)를 생성 한 후 자동 생성이 올바른지 확인한 후 변경 사항을 개발 데이터베이스에 적용 할 수 있습니다. (플래시 DB 업그레이드). 마이그레이션 스크립트를 소스 제어에 추가하고 커미트합니다.

새 버전의 응용 프로그램을 프로덕션 서버에 릴리스 할 준비가되면 업데이트 된 응용 프로그램 버전 (새 마이그레이션 스크립트 포함)을 다운로드하고 플라스크 DB 업그레이드를 실행하면됩니다. Alembic은 프로덕션 데이터베이스가 스키마의 최신 개정으로 업데이트되지 않았 음을 감지하고 이전 릴리스 이후에 작성된 모든 새 마이그레이션 스크립트를 실행합니다.

앞에서 언급했듯이 플라스크 db 다운 그레이드 명령이있어 마지막 마이그레이션을 취소합니다. 프로덕션 시스템에서이 옵션이 필요하지는 않지만 개발 중에 매우 유용 할 수 있습니다. 마이그레이션 스크립트를 생성하고 적용했을 수 있습니다. 변경 한 내용이 정확히 필요한 것이 아니라는 것을 알기 위해서입니다. 이 경우 데이터베이스를 다운 그레이드하고 마이그레이션 스크립트를 삭제 한 다음 새 스크립트를 생성하여 교체 할 수 있습니다.



### Database Relationships

관계형 데이터베이스는 데이터 항목 간의 관계를 잘 저장합니다. 사용자가 블로그 게시물을 작성하는 경우를 고려하십시오. 사용자는 users 테이블에 레코드가 있고 게시물은 posts 테이블에 레코드가 있습니다. 특정 게시물을 작성한 사람을 기록하는 가장 효율적인 방법은 두 개의 관련 레코드를 연결하는 것입니다.

사용자와 게시물 사이의 링크가 설정되면 데이터베이스는이 링크에 대한 쿼리에 응답 할 수 있습니다. 가장 사소한 것은 블로그 게시물이 있고 사용자가 작성한 내용을 알아야 할 때입니다. 더 복잡한 쿼리는이 쿼리의 반대입니다. 사용자가있는 경우이 사용자가 작성한 모든 게시물을 알고 싶을 수 있습니다. Flask-SQLAlchemy는 두 가지 유형의 쿼리를 모두 지원합니다.

관계를 확인하기 위해 블로그 게시물을 저장하도록 데이터베이스를 확장 해 봅시다. 새 게시물 테이블의 스키마는 다음과 같습니다.

![](./images/ch04-users-posts.png)

게시물 테이블에는 필수 ID, 게시물 본문 및 타임 스탬프가 있습니다. 그러나 이러한 예상 필드 외에도 게시물을 작성자와 연결하는 user_id 필드를 추가하고 있습니다. 모든 사용자가 고유 한 id 기본 키를 가지고 있음을 확인했습니다. 블로그 게시물을 작성한 사용자에게 블로그 게시물을 연결하는 방법은 사용자의 ID에 대한 참조를 추가하는 것입니다. 이것이 바로 user_id 필드입니다. 이 user_id 필드를 외래 키라고합니다. 위의 데이터베이스 다이어그램은 외래 키를 참조하는 테이블의 필드와 id 필드 사이의 링크로 표시합니다. '한 명의'사용자가 '많은'게시물을 작성하기 때문에 이러한 종류의 관계를 일대 다라고합니다.

수정 된 app/models.py는 다음과 같습니다.

`app/models.py: Posts database table and relationship`

```python
from datetime import datetime
from app import db

class User(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    username = db.Column(db.String(64), index=True, unique=True)
    email = db.Column(db.String(120), index=True, unique=True)
    password_hash = db.Column(db.String(128))
    posts = db.relationship('Post', backref='author', lazy='dynamic')

    def __repr__(self):
        return '<User {}>'.format(self.username)

class Post(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    body = db.Column(db.String(140))
    timestamp = db.Column(db.DateTime, index=True, default=datetime.utcnow)
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'))

    def __repr__(self):
        return '<Post {}>'.format(self.body)
```

새로운 Post 클래스는 사용자가 작성한 블로그 게시물을 나타냅니다. 타임 스탬프 필드가 색인화되며, 시간순으로 게시물을 검색하려는 경우에 유용합니다. 또한 기본 인수를 추가하고 datetime.utcnow 함수를 전달했습니다. 함수를 기본값으로 전달하면 SQLAlchemy는 해당 함수를 호출하는 값으로 필드를 설정합니다 (utcnow 후에 ()를 포함하지 않았으므로 함수 자체를 전달하지만 호출 결과는 전달하지 않습니다) ). 일반적으로 서버 애플리케이션에서 UTC 날짜 및 시간으로 작업하려고합니다. 이를 통해 사용자의 위치에 관계없이 균일 한 타임 스탬프를 사용할 수 있습니다. 이 타임 스탬프는 표시 될 때 사용자의 현지 시간으로 변환됩니다.

user_id 필드는 user.id에 대한 외래 키로 초기화되었습니다. 이는 users 테이블의 id 값을 참조한다는 의미입니다. 이 참조에서 사용자 부분은 모델의 데이터베이스 테이블 이름입니다. Db.relationship () 호출과 같은 일부 경우 모델이 모델 클래스에 의해 참조되는 경우가 불행히도 불일치입니다.이 클래스는 일반적으로 대문자로 시작하지만 다른 경우에는이 db.ForeignKey () 선언 SQLAlchemy는 자동으로 소문자와 여러 단어로 된 모델 이름에 대해 뱀을 사용하는 데이터베이스 테이블 이름으로 모델을 제공합니다.

사용자 클래스에는 새로운 게시물 필드가 있으며 이는 db.relationship으로 초기화됩니다. 이것은 실제 데이터베이스 필드가 아니라 사용자와 게시물 간의 관계에 대한 높은 수준의 관점이므로 데이터베이스 다이어그램에는 없습니다. 일대 다 관계의 경우, db.relationship 필드는 일반적으로 '일'쪽에 정의되며 '다'에 대한 편리한 액세스 방법으로 사용됩니다. 예를 들어 사용자가 u에 저장된 경우 u.posts 표현식은 해당 사용자가 작성한 모든 게시물을 반환하는 데이터베이스 쿼리를 실행합니다. Db.relationship의 첫 번째 인수는 관계의 '다'측면을 나타내는 모델 클래스입니다. 이 인수는 모델이 모듈에서 나중에 정의 된 경우 클래스 이름을 가진 문자열로 제공 될 수 있습니다. Backref 인수는 'one'오브젝트를 가리키는 'many'클래스의 오브젝트에 추가 될 필드 이름을 정의합니다. 그러면 post.author 표현식이 추가되어 게시물을받은 사용자를 반환합니다. 게으른 인수는 관계에 대한 데이터베이스 쿼리가 발행되는 방법을 정의하며, 나중에 설명하겠습니다. 이러한 세부 사항이 아직 이해가되지 않더라도 걱정하지 마십시오.이 기사의 끝 부분에서 이에 대한 예를 보여 드리겠습니다.

애플리케이션 모델에 대한 업데이트가 있으므로 새 데이터베이스 마이그레이션을 생성해야합니다.

```bash
(venv) $ flask db migrate -m "posts table"
INFO  [alembic.runtime.migration] Context impl SQLiteImpl.
INFO  [alembic.runtime.migration] Will assume non-transactional DDL.
INFO  [alembic.autogenerate.compare] Detected added table 'post'
INFO  [alembic.autogenerate.compare] Detected added index 'ix_post_timestamp' on '['timestamp']'
  Generating /home/miguel/microblog/migrations/versions/780739b227a7_posts_table.py ... done
```

그리고 데이터베이스에 마이그레이션을 적용해야합니다.

```bash
(venv) $ flask db upgrade
INFO  [alembic.runtime.migration] Context impl SQLiteImpl.
INFO  [alembic.runtime.migration] Will assume non-transactional DDL.
INFO  [alembic.runtime.migration] Running upgrade e517276bb1c2 -> 780739b227a7, posts table
```

소스 제어에 프로젝트를 저장하는 경우 새 마이그레이션 스크립트를 추가해야합니다.



### 동작 시간

데이터베이스를 정의하는 데 오랜 시간이 걸리지 만 모든 것이 어떻게 작동하는지는 보여주지 않았습니다. 애플리케이션에 아직 데이터베이스 로직이 없으므로 Python 인터프리터에서 데이터베이스를 사용하여 익숙해 지도록하자. Python을 실행하여 Python을 시작하십시오. 인터프리터를 시작하기 전에 가상 환경이 활성화되어 있는지 확인하십시오.

Python 프롬프트에서 데이터베이스 인스턴스와 모델을 가져 오십시오.

```python
>>> from app import db
>>> from app.models import User, Post
```

새 사용자를 작성하여 시작하십시오.

```python
>>> u = User(username='john', email='john@example.com')
>>> db.session.add(u)
>>> db.session.commit()
```

데이터베이스의 변경은 세션 컨텍스트에서 수행되며 db.session으로 액세스 할 수 있습니다. 세션에 여러 변경 사항이 누적 될 수 있으며 모든 변경 사항이 등록되면 모든 변경 사항을 원자 적으로 기록하는 단일 db.session.commit ()을 발행 할 수 있습니다. 세션에서 작업하는 동안 언제든지 오류가 발생하면 db.session.rollback ()을 호출하면 세션이 중단되고 세션에 저장된 모든 변경 사항이 제거됩니다. 기억해야 할 중요한 사항은 db.session.commit ()이 호출 될 때 변경 사항이 데이터베이스에만 기록된다는 것입니다. 세션은 데이터베이스가 일관성이없는 상태를 유지하지 않도록 보장합니다.

다른 사용자를 추가합시다 :

```python
>>> u = User(username='susan', email='susan@example.com')
>>> db.session.add(u)
>>> db.session.commit()
```

데이터베이스는 모든 사용자를 반환하는 쿼리에 응답 할 수 있습니다.

```bash
>>> users = User.query.all()
>>> users
[<User john>, <User susan>]
>>> for u in users:
...     print(u.id, u.username)
...
1 john
2 susan
```

모든 모델에는 데이터베이스 쿼리를 실행하기위한 진입 점 인 쿼리 속성이 있습니다. 가장 기본적인 쿼리는 해당 클래스의 모든 요소를 반환하는 쿼리이며 적절하게 이름이 all ()입니다. 해당 사용자가 추가되면 id 필드가 자동으로 1과 2로 설정되었습니다.

쿼리를 수행하는 다른 방법이 있습니다. 사용자의 ID를 알고 있으면 다음과 같이 해당 사용자를 검색 할 수 있습니다.

```bash
>>> u = User.query.get(1)
>>> u
<User john>
```

이제 블로그 게시물을 추가하겠습니다 :

```python
>>> u = User.query.get(1)
>>> p = Post(body='my first post!', author=u)
>>> db.session.add(p)
>>> db.session.commit()
```

타임 스탬프 필드에 대한 값을 설정할 필요가 없었습니다. 해당 필드에는 모델 정의에서 볼 수있는 기본값이 있기 때문입니다. 그리고 user_id 필드는 어떻습니까? User 클래스에서 만든 db.relationship은 posts 속성을 사용자에게 추가하고 author 속성을 게시물에 추가합니다. 사용자 ID를 다루지 않고 저자 가상 필드를 사용하여 게시물에 저자를 할당합니다. SQLAlchemy는 관계 및 외래 키에 대한 높은 수준의 추상화를 제공하므로 그 점에서 훌륭합니다.

이 세션을 완료하기 위해 몇 가지 데이터베이스 쿼리를 더 살펴 보겠습니다.

```python
>>> # get all posts written by a user
>>> u = User.query.get(1)
>>> u
<User john>
>>> posts = u.posts.all()
>>> posts
[<Post my first post!>]

>>> # same, but with a user that has no posts
>>> u = User.query.get(2)
>>> u
<User susan>
>>> u.posts.all()
[]

>>> # print post author and body for all posts 
>>> posts = Post.query.all()
>>> for p in posts:
...     print(p.id, p.author.username, p.body)
...
1 john my first post!

# get all users in reverse alphabetical order
>>> User.query.order_by(User.username.desc()).all()
[<User susan>, <User john>]
```

Flask-SQLAlchemy 문서는 데이터베이스를 쿼리하는 데 사용할 수있는 많은 옵션에 대해 배우는 가장 좋은 곳입니다.

이 섹션을 완료하려면 위에서 작성된 테스트 사용자 및 게시물을 삭제하여 데이터베이스가 깨끗하고 다음 장에 준비되도록하십시오.

```python
>>> users = User.query.all()
>>> for u in users:
...     db.session.delete(u)
...
>>> posts = Post.query.all()
>>> for p in posts:
...     db.session.delete(p)
...
>>> db.session.commit()
```



### 쉘 컨텍스트

Python 인터프리터를 시작한 직후, 이전 섹션의 시작 부분에서 수행 한 작업을 기억하십니까? 가장 먼저 가져온 것은 다음과 같습니다.

```python
>>> from app import db
>>> from app.models import User, Post
```

응용 프로그램에서 작업하는 동안 Python 셸에서 매우 자주 테스트해야하므로 매번 위의 가져 오기를 반복해야하는 것은 지루한 일입니다. 플라스크 쉘 명령은 플라스크 우산 명령에서 매우 유용한 도구입니다. 쉘 명령은 실행 후 Flask가 구현 한 두 번째 '핵심'명령입니다. 이 명령의 목적은 애플리케이션 컨텍스트에서 Python 인터프리터를 시작하는 것입니다. 그게 무슨 뜻이야? 다음 예를 참조하십시오.

```python
(venv) $ python
>>> app
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
NameError: name 'app' is not defined
>>>

(venv) $ flask shell
>>> app
<Flask 'app'>
```

일반 인터프리터 세션을 사용하면 앱 심볼을 명시 적으로 가져 오지 않으면 알 수 없지만 플라스크 셸을 사용하는 경우 명령이 애플리케이션 인스턴스를 미리 가져옵니다. Flask shell의 좋은 점은 앱을 미리 가져 오는 것이 아니라 미리 가져 오는 다른 기호 목록 인 'shell context'를 구성 할 수 있다는 것입니다.

microblog.py의 다음 함수는 데이터베이스 인스턴스 및 모델을 쉘 세션에 추가하는 쉘 컨텍스트를 작성합니다.

```python
from app import app, db
from app.models import User, Post

@app.shell_context_processor
def make_shell_context():
    return {'db': db, 'User': User, 'Post': Post}
```

app.shell_context_processor 데코레이터는 함수를 쉘 컨텍스트 함수로 등록합니다. 플라스크 쉘 명령이 실행될 때이 기능을 호출하고 쉘 세션에서이 기능이 반환 한 항목을 등록합니다. 함수가 사전이 아닌 목록을 반환하는 이유는 각 항목에 대해 사전 키로 제공되는 쉘에서 참조 될 이름을 제공해야하기 때문입니다.

쉘 컨텍스트 프로세서 기능을 추가 한 후에는 데이터베이스 엔티티를 가져 오지 않고도 작업 할 수 있습니다.

```python
(venv) $ flask shell
>>> db
<SQLAlchemy engine=sqlite:////Users/migu7781/Documents/dev/flask/microblog2/app.db>
>>> User
<class 'app.models.User'>
>>> Post
<class 'app.models.Post'>
```

db, User 및 Post에 액세스 할 때 위의 시도를하고 NameError 예외가 발생하면 make_shell_context () 함수가 Flask에 등록되지 않습니다. 가장 큰 원인은 환경에서 FLASK_APP \u003d microblog.py를 설정하지 않았기 때문입니다. 이 경우 1 장으로 돌아가서 FLASK_APP 환경 변수를 설정하는 방법을 검토하십시오. 새 터미널 창을 열 때이 변수를 설정하는 것을 잊어 버린 경우 해당 장의 끝에 설명 된대로 .flaskenv 파일을 프로젝트에 추가하는 것을 고려할 수 있습니다.



## [Part V: User Logins](https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-v-user-logins)

다음은 Flask Mega-Tutorial 시리즈의 다섯 번째 부분으로, 사용자 로그인 하위 시스템을 만드는 방법을 알려 드리겠습니다.

3 장에서는 사용자 로그인 양식을 만드는 방법을 배우고 4 장에서는 데이터베이스 작업 방법을 배웠습니다. 이 장에서는이 두 장의 주제를 결합하여 간단한 사용자 로그인 시스템을 만드는 방법을 설명합니다.

이 장의 GitHub 링크는 다음과 같습니다:  *[Browse](https://github.com/miguelgrinberg/microblog/tree/v0.5), [Zip](https://github.com/miguelgrinberg/microblog/archive/v0.5.zip), [Diff](https://github.com/miguelgrinberg/microblog/compare/v0.4...v0.5).*



### 비밀번호 해싱

4 장에서 사용자 모델에는 password_hash 필드가 주어졌으며 지금까지는 사용되지 않았습니다. 이 필드의 목적은 로그인 과정에서 사용자가 입력 한 비밀번호를 확인하는 데 사용되는 사용자 비밀번호의 해시를 보유하는 것입니다. 암호 해싱은 보안 전문가에게 맡겨야하는 복잡한 주제이지만 응용 프로그램에서 호출하기 쉬운 방식으로 모든 논리를 구현하는 사용하기 쉬운 라이브러리가 몇 가지 있습니다.

비밀번호 해싱을 구현하는 패키지 중 하나는 Werkzeug입니다. Flask를 설치할 때 pip 출력에서 참조되는 것을 볼 수 있습니다. 이는 핵심 종속성 중 하나이기 때문입니다. 종속성이므로 Werkzeug가 이미 가상 환경에 설치되어 있습니다. 다음 Python 셸 세션은 비밀번호를 해시하는 방법을 보여줍니다.

```python
>>> from werkzeug.security import generate_password_hash
>>> hash = generate_password_hash('foobar')
>>> hash
'pbkdf2:sha256:50000$vT9fkZM8$04dfa35c6476acf7e788a1b5b3c35e217c78dc04539d295f011f01f18cd2175f'
```

이 예에서 비밀번호 foobar는 알려진 역방향 조작이없는 일련의 암호화 조작을 통해 긴 인코딩 된 문자열로 변환됩니다. 즉, 해시 된 비밀번호를 얻은 사용자는이를 사용하여 원래 비밀번호를 얻을 수 없습니다. 추가 조치로, 동일한 비밀번호를 여러 번 해시하면 다른 결과가 표시되므로 두 사용자가 해시를보고 동일한 비밀번호를 가지고 있는지 식별 할 수 없습니다.

검증 프로세스는 다음과 같이 Werkzeug의 두 번째 기능으로 수행됩니다.

```python
>>> from werkzeug.security import check_password_hash
>>> check_password_hash(hash, 'foobar')
True
>>> check_password_hash(hash, 'barfoo')
False
```

확인 기능은 이전에 생성 된 비밀번호 해시와 로그인시 사용자가 입력 한 비밀번호를 사용합니다. 사용자가 제공 한 비밀번호가 해시와 일치하면이 함수는 True를 리턴하고 그렇지 않으면 False를 리턴합니다.

전체 비밀번호 해싱 로직은 사용자 모델에서 두 가지 새로운 방법으로 구현 될 수 있습니다.

`*app/models.py*: Password hashing and verification`

```python
from werkzeug.security import generate_password_hash, check_password_hash

# ...

class User(db.Model):
    # ...

    def set_password(self, password):
        self.password_hash = generate_password_hash(password)

    def check_password(self, password):
        return check_password_hash(self.password_hash, password)
```

이 두 가지 방법을 사용하면 사용자 개체는 이제 원래 암호를 저장할 필요없이 안전한 암호 확인을 수행 할 수 있습니다. 다음은 이러한 새로운 방법의 사용법 예입니다.

```python
>>> u = User(username='susan', email='susan@example.com')
>>> u.set_password('mypassword')
>>> u.check_password('anotherpassword')
False
>>> u.check_password('mypassword')
True
```



### 플라스크 로그인 소개

이 장에서는 Flask-Login이라는 매우 인기있는 Flask 확장을 소개합니다. 이 확장 기능은 사용자 로그인 상태를 관리하므로 예를 들어 사용자가 응용 프로그램에 로그인 한 다음 응용 프로그램이 사용자가 로그인 한 것을 '기억'하는 동안 다른 페이지로 이동할 수 있습니다. 브라우저 창을 닫은 후에도 사용자가 로그인 상태를 유지할 수 있습니다. 이 장을 준비하려면 가상 환경에 Flask-Login을 설치하여 시작할 수 있습니다.

```bash
(venv) $ pip install flask-login
```

다른 확장 프로그램과 마찬가지로 Flask-Login은 `app/__ init__.py`의 응용 프로그램 인스턴스 직후에 생성하고 초기화해야합니다. 이것이 이 확장이 초기화되는 방법입니다 :

`*app/__init__.py*: Flask-Login initialization`

```python
# ...
from flask_login import LoginManager

app = Flask(__name__)
# ...
login = LoginManager(app)

# ...
```



### 플라스크 로그인을위한 사용자 모델 준비

Flask-Login 확장은 응용 프로그램의 사용자 모델과 함께 작동하며 특정 속성 및 메서드가 구현 될 것으로 예상합니다. 이러한 접근 방식은 이러한 필수 항목이 모델에 추가되는 한 Flask-Login에는 다른 요구 사항이 없으므로 데이터베이스 시스템을 기반으로하는 사용자 모델과 함께 작동 할 수 있기 때문에 좋습니다.

네 가지 필수 항목은 다음과 같습니다.

- `is_authenticated`: 사용자에게 유효한 자격 증명이 있으면 True이고 그렇지 않으면 False입니다.
- `is_active`: 사용자 계정이 활성화되어 있으면 True이고 그렇지 않으면 False입니다.
- `is_anonymous`:일반 사용자의 경우 False이고 특수한 익명 사용자의 경우 True 인 속성입니다.
- `get_id()`: 사용자의 고유 식별자를 문자열 (Python 2를 사용하는 경우 유니 코드)로 반환하는 메소드입니다.

이 네 가지를 쉽게 구현할 수 있지만 구현이 상당히 일반적이기 때문에 Flask-Login은 대부분의 사용자 모델 클래스에 적합한 일반 구현을 포함하는 UserMixin이라는 믹스 인 클래스를 제공합니다. 믹스 인 클래스가 모델에 추가되는 방법은 다음과 같습니다.

`*app/models.py*: Flask-Login user mixin class`

```python
# ...
from flask_login import UserMixin

class User(UserMixin, db.Model):
    # ...
```



### 사용자 로더 기능

Flask-Login은 응용 프로그램에 연결하는 각 사용자에게 할당 된 저장 공간 인 Flask의 사용자 세션에 고유 식별자를 저장하여 로그인 한 사용자를 추적합니다. 로그인 한 사용자가 새 페이지를 탐색 할 때마다 Flask-Login은 세션에서 사용자의 ID를 검색 한 다음 해당 사용자를 메모리에로드합니다.

Flask-Login은 데이터베이스에 대해 아무것도 모르기 때문에 사용자를로드하는 데 응용 프로그램의 도움이 필요합니다. 따라서 확장 프로그램은 응용 프로그램이 사용자 로더 기능을 구성 할 것으로 예상합니다.이 기능은 ID가 주어진 사용자를로드하기 위해 호출 될 수 있습니다. 이 기능은 app / models.py 모듈에서 추가 할 수 있습니다.

`*app/models.py*: Flask-Login user loader function`

```python
from app import login
# ...

@login.user_loader
def load_user(id):
    return User.query.get(int(id))
```

사용자 로더는 @login.user_loader 데코레이터를 사용하여 Flask-Login에 등록됩니다. Flask-Login이 인수로 함수에 전달하는 id는 문자열이 될 것이므로 숫자 ID를 사용하는 데이터베이스는 위에서 볼 수 있듯이 문자열을 정수로 변환해야합니다.



### 사용자 로그인 

로그인 뷰 함수를 다시 방문 해보자.이 함수는 방금 flash () 메시지를 발행 한 가짜 로그인을 구현했다. 애플리케이션이 사용자 데이터베이스에 액세스하고 비밀번호 해시를 생성하고 확인하는 방법을 알고 있으므로이보기 기능을 완료 할 수 있습니다.

`*app/routes.py*: Login view function logic`

```python
# ...
from flask_login import current_user, login_user
from app.models import User

# ...

@app.route('/login', methods=['GET', 'POST'])
def login():
    if current_user.is_authenticated:
        return redirect(url_for('index'))
    form = LoginForm()
    if form.validate_on_submit():
        user = User.query.filter_by(username=form.username.data).first()
        if user is None or not user.check_password(form.password.data):
            flash('Invalid username or password')
            return redirect(url_for('login'))
        login_user(user, remember=form.remember_me.data)
        return redirect(url_for('index'))
    return render_template('login.html', title='Sign In', form=form)
```

Login () 함수의 맨 위 두 줄은 이상한 상황을 처리합니다. 로그인 한 사용자가 있고 사용자가 애플리케이션의 / login URL로 이동한다고 가정하십시오. 분명히 그것은 실수이므로, 나는 그것을 허용하고 싶지 않습니다. Current_user 변수는 Flask-Login에서 가져 오며 처리 중에 언제라도 사용하여 요청의 클라이언트를 나타내는 사용자 오브젝트를 얻을 수 있습니다. 이 변수의 값은 데이터베이스의 사용자 객체 (Flask-Login이 위에서 제공 한 사용자 로더 콜백을 통해 읽음)이거나 사용자가 아직 로그인하지 않은 경우 특수 익명 사용자 객체 일 수 있습니다. Flask-Login이 사용자 객체에 필요했던 속성을 기억하십니까? 그 중 하나는 is_authenticated이며, 사용자가 로그인했는지 여부를 확인하는 데 편리합니다. 사용자가 이미 로그인하면 색인 페이지로 리디렉션됩니다.

앞에서 사용한 flash () 호출 대신 사용자를 로그인 할 수 있습니다. 첫 번째 단계는 데이터베이스에서 사용자를로드하는 것입니다. 사용자 이름은 양식 제출과 함께 제공되므로 데이터베이스를 쿼리하여 사용자를 찾을 수 있습니다. 이를 위해 SQLAlchemy 쿼리 개체의 filter_by () 메서드를 사용하고 있습니다. Filter_by ()의 결과는 일치하는 사용자 이름을 가진 객체 만 포함하는 쿼리입니다. 하나 또는 0 개의 결과 만있을 것이라는 것을 알고 있기 때문에 first ()를 호출하여 쿼리를 완료합니다. first ()를 호출하면 사용자 객체가 있으면 반환하고 그렇지 않으면 None을 반환합니다. 4 장에서 쿼리에서 all () 메서드를 호출하면 쿼리가 실행되고 해당 쿼리와 일치하는 모든 결과 목록이 표시됩니다. First () 메소드는 하나의 결과 만 필요한 경우 쿼리를 실행하는 데 일반적으로 사용되는 또 다른 방법입니다.

제공된 사용자 이름과 일치하면 양식과 함께 제공된 암호가 유효한지 확인할 수 있습니다. 이것은 위에서 정의한 check_password () 메소드를 호출하여 수행됩니다. 사용자와 함께 저장된 비밀번호 해시를 가져 와서 양식에 입력 한 비밀번호가 해시와 일치하는지 여부를 판별합니다. 이제 두 가지 가능한 오류 조건이 있습니다. 사용자 이름이 유효하지 않거나 사용자의 암호가 올바르지 않을 수 있습니다. 두 경우 모두 메시지를 플래시 한 후 다시 로그인 프롬프트로 리디자가 다시 시도 할 수 있도록합니다.

사용자 이름과 비밀번호가 모두 올바른 경우 Flask-Login에서 제공되는 login_user () 함수를 호출합니다. 이 기능은 사용자를 로그인 한 상태로 등록하므로 사용자가 탐색 할 이후의 모든 페이지에는 current_user 변수가 해당 사용자로 설정됩니다.

로그인 프로세스를 완료하기 위해 새로 로그인 한 사용자를 색인 페이지로 리디렉션합니다.



### 사용자 로그 아웃

또한 사용자에게 응용 프로그램에서 로그 아웃 할 수있는 옵션을 제공해야한다는 것을 알고 있습니다. 이것은 Flask-Login의 logout_user () 함수로 수행 할 수 있습니다. 다음은 로그 아웃보기 기능입니다.

`App / routes.py : 로그 아웃보기 기능`

```python
# ...
from flask_login import logout_user

# ...

@app.route('/logout')
def logout():
    logout_user()
    return redirect(url_for('index'))
```

이 링크를 사용자에게 공개하기 위해 사용자가 로그인 한 후 탐색 모음의 로그인 링크가 자동으로 로그 아웃 링크로 전환되도록 할 수 있습니다. 이것은 base.html 템플릿의 조건부로 수행 할 수 있습니다.

`*app/templates/base.html*: Conditional login and logout links`

```html
    <div>
        Microblog:
        <a href="{{ url_for('index') }}">Home</a>
        {% if current_user.is_anonymous %}
        <a href="{{ url_for('login') }}">Login</a>
        {% else %}
        <a href="{{ url_for('logout') }}">Logout</a>
        {% endif %}
    </div>
```

Is_anonymous 속성은 Flask-Login이 UserMixin 클래스를 통해 사용자 개체에 추가하는 속성 중 하나입니다. Current_user.is_anonymous 표현식은 사용자가 로그인하지 않은 경우에만 True가됩니다.



### 사용자에게 로그인 요청

Flask-Login은 사용자가 응용 프로그램의 특정 페이지를보기 전에 로그인하도록하는 매우 유용한 기능을 제공합니다. 로그인하지 않은 사용자가 보호 된 페이지를 보려고하면 Flask-Login은 자동으로 사용자를 로그인 양식으로 리디렉션하고 로그인 프로세스가 완료된 후 사용자가 보려는 페이지로만 리디렉션합니다.

이 기능을 구현하려면 Flask-Login에서 로그인을 처리하는보기 기능이 무엇인지 알아야합니다. *App/__ init__.py*에 추가 할 수 있습니다 :

```python
# ...
login = LoginManager(app)
login.login_view = 'login'
```

위의 'login'값은 로그인보기의 함수 (또는 엔드 포인트) 이름입니다. 다시 말해, URL을 얻기 위해 url_for () 호출에 사용할 이름입니다.

Flask-Login이 익명 사용자로부터보기 기능을 보호하는 방법은 @login_required라는 데코레이터를 사용하는 것입니다. Flask의 @ app.route 데코레이터 아래에있는 뷰 함수에이 데코레이터를 추가하면이 기능이 보호되며 인증되지 않은 사용자에 대한 액세스는 허용되지 않습니다. 다음은 데코레이터를 응용 프로그램의 인덱스보기 기능에 적용하는 방법입니다.

`*app/routes.py*: @login\_required decorator`

```python
from flask_login import login_required

@app.route('/')
@app.route('/index')
@login_required
def index():
    # ...
```

남아있는 것은 성공적인 로그인에서 사용자가 액세스하려는 페이지로 리디렉션을 다시 구현하는 것입니다. 로그인하지 않은 사용자가 @login_required 데코레이터로 보호 된 뷰 함수에 액세스하면 데코레이터가 로그인 페이지로 리디렉션되지만이 리디렉션에 추가 정보를 포함시켜 응용 프로그램으로 돌아갈 수 있습니다. 첫 페이지. 예를 들어 사용자가 / index로 이동하면 @login_required 데코레이터가 요청을 가로 채고 / login으로의 리디렉션으로 응답하지만이 URL에 쿼리 문자열 인수를 추가하여 완전한 리디렉션 URL을 / login? next \u003d /인덱스. 다음 쿼리 문자열 인수는 원래 URL로 설정되므로 응용 프로그램은이를 사용하여 로그인 후 다시 리디렉션 할 수 있습니다.

다음 쿼리 문자열 인수를 읽고 처리하는 방법을 보여주는 코드 스 니펫입니다.

`*app/routes.py*: Redirect to "next" page`

```python
from flask import request
from werkzeug.urls import url_parse

@app.route('/login', methods=['GET', 'POST'])
def login():
    # ...
    if form.validate_on_submit():
        user = User.query.filter_by(username=form.username.data).first()
        if user is None or not user.check_password(form.password.data):
            flash('Invalid username or password')
            return redirect(url_for('login'))
        login_user(user, remember=form.remember_me.data)
        next_page = request.args.get('next')
        if not next_page or url_parse(next_page).netloc != '':
            next_page = url_for('index')
        return redirect(next_page)
    # ...
```

Flask-Login의 login_user () 함수를 호출하여 사용자가 로그인 한 직후 다음 쿼리 문자열 인수의 값을 얻습니다. 플라스크는 클라이언트가 요청과 함께 보낸 모든 정보를 포함하는 요청 변수를 제공합니다. 특히 request.args 속성은 쿼리 문자열의 내용을 친숙한 사전 형식으로 노출합니다. 성공적인 로그인 후 리디렉션 할 위치를 결정하기 위해 실제로 고려해야 할 세 가지 경우가 있습니다.

- 로그인 URL에 다음 인수가 없으면 사용자는 색인 페이지로 경로 재 지정됩니다.
- 로그인 URL에 상대 경로 (또는 도메인 부분이없는 URL)로 설정된 다음 인수가 포함 된 경우 사용자는 해당 URL로 리디렉션됩니다.
- 로그인 URL에 도메인 이름을 포함하는 전체 URL로 설정된 다음 인수가 포함 된 경우 사용자는 색인 페이지로 경로 재 지정됩니다.

첫 번째와 두 번째 경우는 자명하다. 세 번째 경우는 응용 프로그램을보다 안전하게 만드는 것입니다. 공격자는 다음 인수에서 악의적 인 사이트에 URL을 삽입 할 수 있으므로 URL이 상대적 일 때만 응용 프로그램이 리디렉션되므로 리디렉션은 응용 프로그램과 동일한 사이트 내에 유지됩니다. URL이 상대적인지 절대적인지 확인하려면 Werkzeug의 url_parse () 함수로 구문 분석 한 다음 netloc 구성 요소가 설정되어 있는지 확인하십시오.



### 템플릿에 로그인 한 사용자 표시

2 장에서이 방법을 기억하십니까? 사용자 하위 시스템을 설치하기 전에 응용 프로그램의 홈 페이지를 디자인하는 데 도움이되는 가짜 사용자를 만들었습니까? 응용 프로그램에 실제 사용자가 있으므로 가짜 사용자를 제거하고 실제 사용자와 작업을 시작할 수 있습니다. 가짜 사용자 대신 템플릿에서 Flask-Login의 current_user를 사용할 수 있습니다.

`*app/templates/index.html*: Pass current user to template`

```html
{% extends "base.html" %}

{% block content %}
    <h1>Hi, {{ current_user.username }}!</h1>
    {% for post in posts %}
    <div><p>{{ post.author.username }} says: <b>{{ post.body }}</b></p></div>
    {% endfor %}
{% endblock %}
```

그리고 뷰 함수에서 사용자 템플릿 인수를 제거 할 수 있습니다.

`*app/routes.py*: Do not pass user to template anymore`

```python
@app.route('/')
@app.route('/index')
def index():
    # ...
    return render_template("index.html", title='Home Page', posts=posts)
```

로그인 및 로그 아웃 기능의 작동 방식을 테스트하기에 좋은시기입니다. 여전히 사용자 등록이 없으므로 데이터베이스에 사용자를 추가하는 유일한 방법은 Python 쉘을 통해 수행하는 것이므로 flask shell을 실행하고 다음 명령을 입력하여 사용자를 등록하십시오.

```python
>>> u = User(username='susan', email='susan@example.com')
>>> u.set_password('cat')
>>> db.session.add(u)
>>> db.session.commit()
```

응용 프로그램을 시작하고 http://localhost:5000/ 또는 http://localhost:5000/index에 액세스하려고하면 즉시 로그인 페이지로 리디렉션되고 사용자의 자격 증명을 사용하여 로그인하면 당신이 당신의 데이터베이스에 추가하면, 당신은 개인 인사말을 볼 수있는 원래 페이지로 돌아갑니다.



### 사용자 등록

이 장에서 만들려고하는 마지막 기능은 등록 양식이므로 사용자는 웹 양식을 통해 자신을 등록 할 수 있습니다. App / forms.py에서 웹 폼 클래스를 만들어 봅시다 :

`*app/forms.py*: User registration form`

```python
from flask_wtf import FlaskForm
from wtforms import StringField, PasswordField, BooleanField, SubmitField
from wtforms.validators import ValidationError, DataRequired, Email, EqualTo
from app.models import User

# ...

class RegistrationForm(FlaskForm):
    username = StringField('Username', validators=[DataRequired()])
    email = StringField('Email', validators=[DataRequired(), Email()])
    password = PasswordField('Password', validators=[DataRequired()])
    password2 = PasswordField(
        'Repeat Password', validators=[DataRequired(), EqualTo('password')])
    submit = SubmitField('Register')

    def validate_username(self, username):
        user = User.query.filter_by(username=username.data).first()
        if user is not None:
            raise ValidationError('Please use a different username.')

    def validate_email(self, email):
        user = User.query.filter_by(email=email.data).first()
        if user is not None:
            raise ValidationError('Please use a different email address.')
```

유효성 검사와 관련된이 새로운 형식에는 몇 가지 흥미로운 것들이 있습니다. 먼저 이메일 필드에 DataRequired 뒤에 Email이라는 두 번째 유효성 검사기를 추가했습니다. 이 필드는 사용자가이 필드에 입력 한 내용이 전자 메일 주소의 구조와 일치하도록 WTForms와 함께 제공되는 또 다른 주식 유효성 검사기입니다.

이 양식은 등록 양식이므로 오타의 위험을 줄이기 위해 사용자에게 암호를 두 번 입력하도록 요청하는 것이 일반적입니다. 이러한 이유로 비밀번호 및 비밀번호 2 필드가 있습니다. 두 번째 비밀번호 필드는 EqualTo라는 또 다른 주식 유효성 검사기를 사용하여 해당 값이 첫 번째 비밀번호 필드의 값과 동일한 지 확인합니다.

또한이 클래스에 validate_username () 및 validate_email ()이라는 두 가지 메소드를 추가했습니다. Validate_ field_name 패턴과 일치하는 메소드를 추가하면 WTForms는 해당 메소드를 사용자 정의 유효성 검증기로 사용하고 스톡 유효성 검증기 외에이를 호출합니다. 이 경우 사용자가 입력 한 사용자 이름과 전자 메일 주소가 아직 데이터베이스에 없는지 확인하기 위해이 두 가지 방법으로 결과가 없을 것으로 예상되는 데이터베이스 쿼리를 실행합니다. 결과가 존재하면 ValidationError를 발생시켜 유효성 검사 오류가 발생합니다. 예외에 인수로 포함 된 메시지는 사용자가 볼 수있는 필드 옆에 표시되는 메시지입니다.

이 양식을 웹 페이지에 표시하려면 app / templates / register.html 파일에 HTML 템플릿을 저장해야합니다. 이 템플릿은 로그인 양식의 템플릿과 유사하게 구성됩니다.

`*app/templates/register.html*: Registration template`

```html
{% extends "base.html" %}

{% block content %}
    <h1>Register</h1>
    <form action="" method="post">
        {{ form.hidden_tag() }}
        <p>
            {{ form.username.label }}<br>
            {{ form.username(size=32) }}<br>
            {% for error in form.username.errors %}
            <span style="color: red;">[{{ error }}]</span>
            {% endfor %}
        </p>
        <p>
            {{ form.email.label }}<br>
            {{ form.email(size=64) }}<br>
            {% for error in form.email.errors %}
            <span style="color: red;">[{{ error }}]</span>
            {% endfor %}
        </p>
        <p>
            {{ form.password.label }}<br>
            {{ form.password(size=32) }}<br>
            {% for error in form.password.errors %}
            <span style="color: red;">[{{ error }}]</span>
            {% endfor %}
        </p>
        <p>
            {{ form.password2.label }}<br>
            {{ form.password2(size=32) }}<br>
            {% for error in form.password2.errors %}
            <span style="color: red;">[{{ error }}]</span>
            {% endfor %}
        </p>
        <p>{{ form.submit() }}</p>
    </form>
{% endblock %}
```

로그인 양식 템플리트에는 새 사용자를 양식 바로 아래의 등록 양식으로 보내는 링크가 필요합니다.

`*app/templates/login.html*: Link to registration page`

```html
 <p>New User? <a href="{{ url_for('register') }}">Click to Register!</a></p>
```

마지막으로 app / routes.py에서 사용자 등록을 처리 할 뷰 함수를 작성해야합니다.

`*app/routes.py*: User registration view function`

```python
from app import db
from app.forms import RegistrationForm

# ...

@app.route('/register', methods=['GET', 'POST'])
def register():
    if current_user.is_authenticated:
        return redirect(url_for('index'))
    form = RegistrationForm()
    if form.validate_on_submit():
        user = User(username=form.username.data, email=form.email.data)
        user.set_password(form.password.data)
        db.session.add(user)
        db.session.commit()
        flash('Congratulations, you are now a registered user!')
        return redirect(url_for('login'))
    return render_template('register.html', title='Register', form=form)
```

이 뷰 함수는 대부분 설명이 필요합니다. 먼저이 라우트를 호출하는 사용자가 로그인하지 않았는지 확인하십시오. 양식은 로그인하는 것과 같은 방식으로 처리됩니다. if validate_on_submit () 조건부에서 수행되는 논리는 사용자 이름으로 새 사용자를 작성합니다. 전자 메일 및 암호를 제공하고 데이터베이스에 기록한 다음 로그인 프롬프트로 리디렉션하여 사용자가 로그인 할 수 있도록합니다.

![](./images/ch05-register-form.png)

이러한 변경으로 사용자는이 응용 프로그램에서 계정을 만들고 로그인 및 로그 아웃 할 수 있어야합니다. 등록 양식에 추가 한 모든 유효성 검사 기능을 사용하여 작동 방식을보다 잘 이해하도록하십시오. 다음 장에서 사용자 인증 하위 시스템을 다시 방문하여 사용자가 잊어 버린 경우 비밀번호를 재설정 할 수 있도록하는 등의 추가 기능을 추가 할 것입니다. 그러나 현재로서는 응용 프로그램의 다른 영역을 계속 구축하기에 충분합니다.



## [Part VI: Profile Page and Avatars](https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-vi-profile-page-and-avatars)

다음은 Flask Mega-Tutorial 시리즈의 6 번째 버전으로, 사용자 프로필 페이지를 만드는 방법을 알려 드리겠습니다.

이 장은 응용 프로그램에 사용자 프로필 페이지를 추가하기위한 것입니다. 사용자 프로필 페이지는 종종 사용자 자신이 입력 한 정보와 함께 사용자에 대한 정보가 표시되는 페이지입니다. 모든 사용자에 대한 프로필 페이지를 동적으로 생성하는 방법을 보여 드리고 사용자가 정보를 입력하는 데 사용할 수있는 작은 프로필 편집기를 추가하겠습니다.

이 장의 GitHub 링크는 다음과 같습니다: *[Browse](https://github.com/miguelgrinberg/microblog/tree/v0.6), [Zip](https://github.com/miguelgrinberg/microblog/archive/v0.6.zip), [Diff](https://github.com/miguelgrinberg/microblog/compare/v0.5...v0.6).*



### 사용자 프로필 페이지

사용자 프로필 페이지를 만들려면 먼저 /user/<username> URL에 매핑되는 새보기 기능을 작성해 보겠습니다.

`*app/routes.py*: User profile view function`

```python
@app.route('/user/<username>')
@login_required
def user(username):
    user = User.query.filter_by(username=username).first_or_404()
    posts = [
        {'author': user, 'body': 'Test post #1'},
        {'author': user, 'body': 'Test post #2'}
    ]
    return render_template('user.html', user=user, posts=posts)
```

이 뷰 함수를 선언하는 데 사용한 `@app.route` 데코레이터는 이전 뷰 함수와 약간 다르게 보입니다. 이 경우 동적 구성 요소가 `<` and `>`로 둘러싸인 <username> URL 구성 요소로 표시됩니다. 경로에 동적 구성 요소가있는 경우 Flask는 URL의 해당 부분에있는 모든 텍스트를 수락하고 실제 텍스트를 인수로 사용하여보기 함수를 호출합니다. 예를 들어, 클라이언트 브라우저가 URL / user / susan을 요청하면, username 인수가 'susan'로 설정된 뷰 함수가 호출됩니다. 이 뷰 기능은 로그인 한 사용자 만 액세스 할 수 있으므로 Flask-Login에서 @login_required 데코레이터를 추가했습니다.

이 뷰 함수의 구현은 매우 간단합니다. 먼저 사용자 이름으로 쿼리를 사용하여 데이터베이스에서 사용자를로드하려고합니다. 모든 결과를 얻으려면 all ()을 호출하거나 첫 번째 결과 만 얻으려면 first ()를 호출하거나 결과가 0이 아닌 경우 None ()을 호출하여 데이터베이스 쿼리를 실행할 수 있습니다. 이 뷰 함수에서는 first_or_404 ()라는 변형을 사용하고 있는데 결과가있을 때 first ()와 똑같이 작동하지만 결과가없는 경우 자동으로 404 오류를 클라이언트로 보냅니다. 이런 식으로 쿼리를 실행하면 쿼리에서 사용자를 반환했는지 확인하지 않아도됩니다. 사용자 이름이 데이터베이스에 없으면 함수가 반환되지 않고 404 예외가 발생하기 때문입니다.

데이터베이스 쿼리가 404 오류를 트리거하지 않으면 주어진 사용자 이름을 가진 사용자가 발견되었음을 의미합니다. 다음으로이 사용자에 대한 가짜 게시물 목록을 초기화하고 마지막으로 사용자 객체와 게시물 목록을 전달할 새로운 user.html 템플릿을 렌더링합니다.

User.html 템플릿은 다음과 같습니다.

```html
{% extends "base.html" %}

{% block content %}
    <h1>User: {{ user.username }}</h1>
    <hr>
    {% for post in posts %}
    <p>
    {{ post.author.username }} says: <b>{{ post.body }}</b>
    </p>
    {% endfor %}
{% endblock %}
```

프로필 페이지가 완성되었지만 웹 사이트 어디에도 해당 링크가 없습니다. 사용자가 자신의 프로필을 좀 더 쉽게 확인할 수 있도록 상단의 탐색 표시 줄에 링크를 추가하겠습니다.

`*app/templates/base.html*: User profile template`

```html
    <div>
      Microblog:
      <a href="{{ url_for('index') }}">Home</a>
      {% if current_user.is_anonymous %}
      <a href="{{ url_for('login') }}">Login</a>
      {% else %}
      <a href="{{ url_for('user', username=current_user.username) }}">Profile</a>
      <a href="{{ url_for('logout') }}">Logout</a>
      {% endif %}
    </div>
```

여기서 흥미로운 변화는 프로필 페이지에 대한 링크를 생성하는 데 사용되는 url_for () 호출입니다. 사용자 프로파일보기 함수는 동적 인수를 사용하므로 url_for () 함수는 해당 값을 키워드 인수로받습니다. 이것은 로그인 한 사용자 프로필을 가리키는 링크이므로 Flask-Login의 current_user를 사용하여 올바른 URL을 생성 할 수 있습니다.

![](./images/ch06-user-profile.png)

지금 응용 프로그램을 사용해보십시오. 상단의 프로필 링크를 클릭하면 자신의 사용자 페이지로 이동합니다. 현재 다른 사용자의 프로필 페이지로 연결되는 링크는 없지만 해당 페이지에 액세스하려면 브라우저의 주소 표시 줄에 직접 URL을 입력 할 수 있습니다. 예를 들어, 응용 프로그램에 'john'이라는 사용자가 등록되어 있으면 주소 표시 줄에 http://localhost:5000/user/john을 입력하여 해당 사용자 프로필을 볼 수 있습니다.



### Avatars

방금 만든 프로필 페이지가 지루하다는 데 동의합니다. 좀 더 재미있게하기 위해 사용자 아바타를 추가 할 것입니다. 그러나 서버에 업로드 된 이미지 모음을 처리하는 대신 Gravatar 서비스를 사용하여 모든 사용자에게 이미지를 제공 할 것입니다 .

Gravatar 서비스는 사용이 매우 간단합니다. 지정된 사용자의 이미지를 요청하려면 https://www.gravatar.com/avatar/ hash 형식의 URL을 입력하십시오. 여기서 hash는 사용자 이메일 주소의 MD5 해시입니다. 아래에서 이메일 john@example.com을 가진 사용자의 Gravatar URL을 얻는 방법을 확인할 수 있습니다.

```python
>>> from hashlib import md5
>>> 'https://www.gravatar.com/avatar/' + md5(b'john@example.com').hexdigest()
'https://www.gravatar.com/avatar/d4c74594d841139328695756648b6bd6'
```

실제 예를 보려면 내 자신의 Gravatar URL은 https://www.gravatar.com/avatar/729e26a2a2c7ff24a71958d4aa4e5f35입니다. 이 URL에 대해 Gravatar가 반환하는 내용은 다음과 같습니다.

**저자 사진 출력**

기본적으로 반환되는 이미지 크기는 80x80 픽셀이지만 URL의 쿼리 문자열에 s 인수를 추가하여 다른 크기를 요청할 수 있습니다. 예를 들어, 내 아바타를 128x128 픽셀 이미지로 얻으려면 URL은 https://www.gravatar.com/avatar/729e26a2a2c7ff24a71958d4aa4e5f35?s=128입니다.

쿼리 문자열 인수로 Gravatar에 전달할 수있는 또 다른 흥미로운 인수는 d로, 서비스에 등록 된 아바타가없는 사용자에게 Gravatar가 제공하는 이미지를 결정합니다. 내가 가장 좋아하는 'identicon'은 모든 이메일마다 다른 멋진 기하학적 디자인을 반환합니다. 예를 들면 다음과 같습니다.

Ghostery와 같은 일부 웹 브라우저 확장 프로그램은 Automattic (Gravatar 서비스 소유자)이 아바타에 대한 요청에 따라 방문하는 사이트를 결정할 수 있으므로 Gravatar 이미지를 차단합니다. 브라우저에 아바타가 표시되지 않으면 브라우저에 설치 한 확장 프로그램으로 인한 문제 일 수 있습니다.

아바타는 사용자와 연결되어 있으므로 아바타 URL을 생성하는 논리를 사용자 모델에 추가하는 것이 좋습니다.

`*app/models.py*: User avatar URLs`

```python
from hashlib import md5
# ...

class User(UserMixin, db.Model):
    # ...
    def avatar(self, size):
        digest = md5(self.email.lower().encode('utf-8')).hexdigest()
        return 'https://www.gravatar.com/avatar/{}?d=identicon&s={}'.format(
            digest, size)
```

User 클래스의 새로운 avatar () 메소드는 요청 된 크기 (픽셀)로 조정 된 사용자 아바타 이미지의 URL을 반환합니다. 아바타가 등록되지 않은 사용자의 경우 'identicon'이미지가 생성됩니다. MD5 해시를 생성하려면 먼저 Gravatar 서비스에 필요한 이메일을 소문자로 변환하십시오. 그런 다음 Python의 MD5 지원은 문자열이 아닌 바이트에서 작동하므로 문자열을 해시 함수에 전달하기 전에 문자열을 바이트로 인코딩합니다.

Gravatar 서비스가 제공하는 다른 옵션에 대해 배우려면 해당 [문서 웹 사이트](https://gravatar.com/site/implement/images)를 방문하십시오.

다음 단계는 아바타 이미지를 사용자 프로필 템플릿에 삽입하는 것입니다.

`*app/templates/user.html*: User avatar in template`

```html
{% extends "base.html" %}

{% block content %}
    <table>
        <tr valign="top">
            <td><img src="{{ user.avatar(128) }}"></td>
            <td><h1>User: {{ user.username }}</h1></td>
        </tr>
    </table>
    <hr>
    {% for post in posts %}
    <p>
    {{ post.author.username }} says: <b>{{ post.body }}</b>
    </p>
    {% endfor %}
{% endblock %}
```

아바타 URL 반환을 담당하는 User 클래스를 만드는 좋은 점은 언젠가 Gravatar 아바타가 내가 원하는 것이 아니라고 결정하면 다른 URL을 반환하기 위해 avatar () 메서드를 다시 작성하면 모든 템플릿이 표시되기 시작한다는 것입니다. 자동으로 새로운 아바타.

사용자 프로필 페이지 상단에 멋진 아바타가 있지만 실제로 그만 둘 이유가 없습니다. 하단에 사용자의 게시물이 있는데 각각 작은 아바타를 가질 수 있습니다. 물론 사용자 프로필 페이지의 경우 모든 게시물에 동일한 아바타가 있지만 기본 페이지에서 동일한 기능을 구현할 수 있으며 각 게시물은 작성자의 아바타로 장식되며 정말 멋지게 보입니다.

개별 게시물에 아바타를 표시하려면 템플릿을 조금만 변경하면됩니다.

`*app/templates/user.html*: User avatars in posts`

```html
{% extends "base.html" %}

{% block content %}
    <table>
        <tr valign="top">
            <td><img src="{{ user.avatar(128) }}"></td>
            <td><h1>User: {{ user.username }}</h1></td>
        </tr>
    </table>
    <hr>
    {% for post in posts %}
    <table>
        <tr valign="top">
            <td><img src="{{ post.author.avatar(36) }}"></td>
            <td>{{ post.author.username }} says:<br>{{ post.body }}</td>
        </tr>
    </table>
    {% endfor %}
{% endblock %}
```

![](./images/ch06-avatars.png)

### Jinja2 하위 템플릿 사용

사용자 프로필 페이지는 아바타와 함께 사용자가 작성한 게시물을 표시하도록 설계되었습니다. 이제 색인 페이지에 비슷한 레이아웃의 게시물이 표시되기를 원합니다. 게시물 렌더링을 처리하는 템플릿 부분을 복사하여 붙여 넣을 수는 있지만 나중에이 레이아웃을 변경하기로 결정하면 두 템플릿을 모두 업데이트해야한다는 것을 기억해야하기 때문에 이상적이지 않습니다.

대신 하나의 게시물을 렌더링하는 하위 템플릿을 만든 다음 user.html 및 index.html 템플릿에서 모두 참조합니다. 먼저 단일 게시물에 대한 HTML 마크 업만으로 하위 템플릿을 만들 수 있습니다. 이 템플릿의 이름을 app / templates / _post.html로 지정하겠습니다. _ 접두사는 하위 템플릿 인 템플릿 파일을 인식하는 데 도움이되는 명명 규칙입니다.

`*app/templates/_post.html*: Post sub-template`

```html
    <table>
        <tr valign="top">
            <td><img src="{{ post.author.avatar(36) }}"></td>
            <td>{{ post.author.username }} says:<br>{{ post.body }}</td>
        </tr>
    </table>
```

User.html 템플릿에서이 하위 템플릿을 호출하려면 Jinja2의 include 문을 사용합니다.

```html
{% extends "base.html" %}

{% block content %}
    <table>
        <tr valign="top">
            <td><img src="{{ user.avatar(128) }}"></td>
            <td><h1>User: {{ user.username }}</h1></td>
        </tr>
    </table>
    <hr>
    {% for post in posts %}
        {% include '_post.html' %}
    {% endfor %}
{% endblock %}
```

응용 프로그램의 색인 페이지는 아직 제대로 구현되지 않았으므로 아직이 기능을 추가하지 않을 것입니다.



### 더 흥미로운 프로필

새로운 사용자 프로필 페이지의 한 가지 문제는 실제로 많은 정보를 표시하지 않는다는 것입니다. 사용자는이 페이지에서 그들에 대해 조금 이야기하고 싶기 때문에 여기에 표시 할 내용을 스스로 작성하도록하겠습니다. 또한 각 사용자가 마지막으로 사이트에 액세스 한 시간을 추적하고 프로필 페이지에 표시 할 것입니다.

이 모든 추가 정보를 지원하기 위해 가장 먼저해야 할 일은 두 개의 새로운 필드로 데이터베이스의 users 테이블을 확장하는 것입니다.

`*app/models.py*: New fields in user model`

```python
class User(UserMixin, db.Model):
    # ...
    about_me = db.Column(db.String(140))
    last_seen = db.Column(db.DateTime, default=datetime.utcnow)
```

데이터베이스가 수정 될 때마다 데이터베이스 마이그레이션을 생성해야합니다. 4 장에서는 마이그레이션 스크립트를 통해 데이터베이스 변경 사항을 추적하도록 응용 프로그램을 설정하는 방법을 보여주었습니다. 이제 데이터베이스에 추가 할 두 개의 새 필드가 있으므로 첫 번째 단계는 마이그레이션 스크립트를 생성하는 것입니다.

```python
(venv) $ flask db migrate -m "new fields in user model"
INFO  [alembic.runtime.migration] Context impl SQLiteImpl.
INFO  [alembic.runtime.migration] Will assume non-transactional DDL.
INFO  [alembic.autogenerate.compare] Detected added column 'user.about_me'
INFO  [alembic.autogenerate.compare] Detected added column 'user.last_seen'
  Generating /home/miguel/microblog/migrations/versions/37f06a334dbf_new_fields_in_user_model.py ... done
```

마이그레이션 명령의 출력은 User 클래스의 두 개의 새 필드가 감지되었음을 보여 주므로 좋아 보입니다. 이제이 변경 사항을 데이터베이스에 적용 할 수 있습니다.

```python
(venv) $ flask db upgrade
INFO  [alembic.runtime.migration] Context impl SQLiteImpl.
INFO  [alembic.runtime.migration] Will assume non-transactional DDL.
INFO  [alembic.runtime.migration] Running upgrade 780739b227a7 -> 37f06a334dbf, new fields in user model
```

마이그레이션 프레임 워크를 사용하는 것이 얼마나 유용한 지 알고 싶습니다. 데이터베이스에 있던 모든 사용자는 여전히 존재하며 마이그레이션 프레임 워크는 데이터를 손상시키지 않고 마이그레이션 스크립트의 변경 사항을 외과 적으로 적용합니다.

다음 단계에서는 다음 두 가지 새로운 필드를 사용자 프로필 템플릿에 추가하겠습니다.

`*app/templates/user.html*: Show user information in user profile template`

```html
{% extends "base.html" %}

{% block content %}
    <table>
        <tr valign="top">
            <td><img src="{{ user.avatar(128) }}"></td>
            <td>
                <h1>User: {{ user.username }}</h1>
                {% if user.about_me %}<p>{{ user.about_me }}</p>{% endif %}
                {% if user.last_seen %}<p>Last seen on: {{ user.last_seen }}</p>{% endif %}
            </td>
        </tr>
    </table>
    ...
{% endblock %}
```

Jinja2의 조건부 에서이 두 필드를 래핑하고 있습니다. 설정 된 경우에만 표시되기를 원하기 때문입니다. 이 시점에서이 두 개의 새 필드는 모든 사용자에게 비어 있으므로 지금 응용 프로그램을 실행하면이 필드가 표시되지 않습니다.



### 사용자의 마지막 방문 시간 기록

Last_seen 필드로 시작하겠습니다. 둘 중 더 쉽습니다. 내가하고 싶은 것은 해당 사용자가 서버에 요청을 보낼 때마다 주어진 사용자에 대해이 필드에 현재 시간을 쓰는 것입니다.

브라우저에서 요청할 수있는 모든 가능한 뷰 함수에이 필드를 설정하기 위해 로그인을 추가하는 것은 명백히 비현실적이지만, 요청이 뷰 함수로 디스패치되기 전에 약간의 일반 논리를 실행하는 것은 Flask의 웹 응용 프로그램에서 일반적인 작업입니다. 기본 기능으로 제공합니다. 해결책을 살펴보십시오.

`*app/routes.py*: Record time of last visit`

```python
from datetime import datetime

@app.before_request
def before_request():
    if current_user.is_authenticated:
        current_user.last_seen = datetime.utcnow()
        db.session.commit()
```

Flask의 @before_request 데코레이터는 뷰 함수 직전에 실행되는 데코 레이팅 된 함수를 등록합니다. 이것은 응용 프로그램의보기 기능 전에 실행하려는 코드를 삽입 할 수 있기 때문에 매우 유용하며 한곳에서 사용할 수 있습니다. 구현은 단순히 current_user가 로그인되어 있는지 확인하고이 경우 last_seen 필드를 현재 시간으로 설정합니다. 앞에서 언급했듯이 서버 응용 프로그램은 일관된 시간 단위로 작동해야하며 표준 관행은 UTC 시간대를 사용하는 것입니다. 시스템의 현지 시간을 사용하는 것은 좋은 생각이 아닙니다. 데이터베이스에 들어가는 것은 사용자의 위치에 달려 있기 때문입니다. 마지막 단계는 데이터베이스 세션을 커밋하여 위에서 변경 한 내용이 데이터베이스에 기록되도록하는 것입니다. 커밋 전에 db.session.add ()가없는 이유가 궁금하다면 current_user를 참조 할 때 Flask-Login이 사용자 로더 콜백 함수를 호출하여 대상 사용자를 넣을 데이터베이스 쿼리를 실행합니다. 데이터베이스 세션. 따라서이 기능에서 사용자를 다시 추가 할 수 있지만 이미 존재하므로 필요하지 않습니다.

이렇게 변경 한 후 프로필 페이지를 보면 '최근에 본'줄에 현재 시간과 매우 가까운 시간이 표시됩니다. 프로필 페이지에서 벗어나 다시 돌아 오면 시간이 지속적으로 업데이트되는 것을 볼 수 있습니다.

UTC 시간대에 이러한 타임 스탬프를 저장한다는 사실은 프로필 페이지에 표시된 시간도 UTC로 표시합니다. 또한 시간 형식은 실제로 Python datetime 객체의 내부 표현이기 때문에 예상 한 것과 다릅니다. 지금부터는이 두 가지 문제에 대해 걱정하지 않을 것입니다. 이후 장에서 웹 응용 프로그램에서 날짜와 시간을 다루는 주제를 다루기 때문입니다.

![](./images/ch06-last-seen.png)



### Profile Editor

또한 사용자에게 자신에 대한 정보를 입력 할 수있는 양식을 제공해야합니다. 이 양식을 통해 사용자는 자신의 사용자 이름을 변경하고 새로운 about_me 필드에 저장하기 위해 자신에 대한 정보를 작성할 수 있습니다. 폼 클래스를 작성해 봅시다 :

`*app/forms.py*: Profile editor form`

```python
from wtforms import StringField, TextAreaField, SubmitField
from wtforms.validators import DataRequired, Length

# ...

class EditProfileForm(FlaskForm):
    username = StringField('Username', validators=[DataRequired()])
    about_me = TextAreaField('About me', validators=[Length(min=0, max=140)])
    submit = SubmitField('Submit')
```

이 양식에 새 필드 유형과 새 유효성 검사기를 사용하고 있습니다. '정보'필드의 경우 사용자가 텍스트를 입력 할 수있는 여러 줄 상자 인 TextAreaField를 사용하고 있습니다. 이 필드의 유효성을 검사하기 위해 Length를 사용하고 있는데, 입력 한 텍스트가 0에서 140 자 사이인지 확인합니다. 이는 데이터베이스의 해당 필드에 할당 한 공간입니다.

이 양식을 렌더링하는 템플릿은 다음과 같습니다.

`*app/templates/edit_profile.html*: Profile editor form`

```html
{% extends "base.html" %}

{% block content %}
    <h1>Edit Profile</h1>
    <form action="" method="post">
        {{ form.hidden_tag() }}
        <p>
            {{ form.username.label }}<br>
            {{ form.username(size=32) }}<br>
            {% for error in form.username.errors %}
            <span style="color: red;">[{{ error }}]</span>
            {% endfor %}
        </p>
        <p>
            {{ form.about_me.label }}<br>
            {{ form.about_me(cols=50, rows=4) }}<br>
            {% for error in form.about_me.errors %}
            <span style="color: red;">[{{ error }}]</span>
            {% endfor %}
        </p>
        <p>{{ form.submit() }}</p>
    </form>
{% endblock %}
```

마지막으로 모든 것을 하나로 묶는 뷰 함수가 있습니다.

`*app/routes.py*: Edit profile view function`

```python
from app.forms import EditProfileForm

@app.route('/edit_profile', methods=['GET', 'POST'])
@login_required
def edit_profile():
    form = EditProfileForm()
    if form.validate_on_submit():
        current_user.username = form.username.data
        current_user.about_me = form.about_me.data
        db.session.commit()
        flash('Your changes have been saved.')
        return redirect(url_for('edit_profile'))
    elif request.method == 'GET':
        form.username.data = current_user.username
        form.about_me.data = current_user.about_me
    return render_template('edit_profile.html', title='Edit Profile',
                           form=form)
```

이보기 기능은 양식을 처리하는 다른보기 기능과 약간 다릅니다. Validate_on_submit ()이 True를 반환하면 양식의 데이터를 사용자 개체로 복사 한 다음 데이터베이스에 개체를 씁니다. 그러나 validate_on_submit ()이 False를 반환하면 두 가지 이유가있을 수 있습니다. 첫째, 브라우저가 방금 GET 요청을 보냈기 때문에 양식 템플릿의 초기 버전을 제공하여 응답해야합니다. 브라우저가 양식 데이터와 함께 POST 요청을 보낼 때도있을 수 있지만 해당 데이터의 내용이 잘못되었습니다. 이 양식의 경우이 두 경우를 별도로 처리해야합니다. GET 요청으로 양식을 처음으로 요청하는 경우 데이터베이스에 저장된 데이터로 필드를 미리 채우고 싶습니다. 따라서 제출 사례에서 수행 한 작업과 반대로 수행해야합니다. 사용자 필드에 저장된 데이터는 해당 양식 필드가 사용자에 대해 저장된 현재 데이터를 갖도록합니다. 그러나 유효성 검사 오류의 경우 양식 필드에 이미 WTForms가 채워져 있기 때문에 양식 필드에 아무것도 쓰지 않으려 고합니다. 이 두 경우를 구별하기 위해 초기 요청에 대해서는 GET이 될 request.method와 유효성 검사에 실패한 제출에 대해서는 POST를 확인합니다.

![](./images/ch06-edit-profile.png)

사용자가 프로파일 편집기 페이지에 쉽게 액세스 할 수 있도록 프로파일 페이지에 링크를 추가 할 수 있습니다.

`*app/templates/user.html*: Edit profile link`

```html
                {% if user == current_user %}
                <p><a href="{{ url_for('edit_profile') }}">Edit your profile</a></p>
                {% endif %}
```

내가 사용하는 영리한 조건에주의를 기울여 다른 사람의 프로필을 볼 때가 아니라 자신의 프로필을 볼 때 편집 링크가 나타나는지 확인하십시오.

![](./images/ch06-user-profile-link.png)



## [Part VII: Error Handling](https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-vii-error-handling)

이것은 Flask Mega-Tutorial 시리즈의 일곱 번째 부분이며, Flask 응용 프로그램에서 오류 처리 방법을 알려 드리겠습니다.

이 장의 GitHub 링크는:  *[Browse](https://github.com/miguelgrinberg/microblog/tree/v0.7), [Zip](https://github.com/miguelgrinberg/microblog/archive/v0.7.zip), [Diff](https://github.com/miguelgrinberg/microblog/compare/v0.6...v0.7).* 입니다.



### 플라스크에서의 오류 처리

Flask 애플리케이션에서 오류가 발생하면 어떻게됩니까? 알아내는 가장 좋은 방법은 직접 체험하는 것입니다. 계속해서 응용 프로그램을 시작하고 두 명 이상의 사용자가 등록되어 있는지 확인하십시오. 사용자 중 하나로 로그인하여 프로파일 페이지를 열고 '편집'링크를 클릭하십시오. 프로필 편집기에서 사용자 이름을 이미 등록 된 다른 사용자의 사용자 이름으로 변경하고 붐! 무서운 '내부 서버 오류'페이지가 나타납니다.

![](./images/ch07-500-error.png)



응용 프로그램이 실행중인 터미널 세션을 보면 오류 의 [스택 추적](http://en.wikipedia.org/wiki/Stack_trace) 이 표시됩니다. 스택 추적은 오류를 생성 한 행까지 모든 스택에서 호출 순서를 보여주기 때문에 오류 디버깅에 매우 유용합니다.

```python
(venv) $ flask run
 * Serving Flask app "microblog"
 * Running on http://127.0.0.1:5000/ (Press CTRL+C to quit)
[2017-09-14 22:40:02,027] ERROR in app: Exception on /edit_profile [POST]
Traceback (most recent call last):
  File "/home/miguel/microblog/venv/lib/python3.6/site-packages/sqlalchemy/engine/base.py", line 1182, in _execute_context
    context)
  File "/home/miguel/microblog/venv/lib/python3.6/site-packages/sqlalchemy/engine/default.py", line 470, in do_execute
    cursor.execute(statement, parameters)
sqlite3.IntegrityError: UNIQUE constraint failed: user.username
```

스택 추적은 버그가 무엇인지 나타냅니다. 응용 프로그램을 사용하면 사용자가 사용자 이름을 변경할 수 있으며 선택한 새 사용자 이름이 이미 시스템에있는 다른 사용자와 충돌하지 않는지 확인할 수 없습니다. 오류는 SQLAlchemy에서 발생하는데,이 데이터베이스에서 새 사용자 이름을 쓰려고 시도하지만 `username`열이로 정의되어 있으므로 데이터베이스가이를 거부합니다 `unique=True`.

사용자에게 제공되는 오류 페이지는 오류에 대한 많은 정보를 제공하지 않으며 이는 좋습니다. 나는 사용자가 데이터베이스 오류, 사용중인 데이터베이스 또는 데이터베이스의 테이블 및 필드 이름으로 인해 충돌이 발생했다는 것을 사용자가 배우기를 원하지 않습니다. 모든 정보는 내부에 보관해야합니다.

이상적이지 않은 것들이 몇 가지 있습니다. 매우 추악하고 응용 프로그램 레이아웃과 일치하지 않는 오류 페이지가 있습니다. 또한 터미널에 덤프되는 중요한 응용 프로그램 스택 추적이있어 오류를 놓치지 않도록 지속적으로 지켜봐야합니다. 물론 수정해야 할 버그가 있습니다. 이 모든 문제를 다룰 예정이지만 먼저 Flask의 *디버그 모드에* 대해 이야기하겠습니다 .

## 디버그 모드

위에서 오류를 처리하는 방법은 프로덕션 서버에서 실행되는 시스템에 적합합니다. 오류가있는 경우 사용자에게 모호한 오류 페이지가 표시되지만 (이 오류 페이지를 더 좋게 만들지 만) 오류에 대한 중요한 세부 정보는 서버 프로세스 출력 또는 로그 파일에 있습니다.

그러나 애플리케이션을 개발할 때 Flask가 브라우저에서 직접 멋진 디버거를 출력하는 모드 인 디버그 모드를 사용할 수 있습니다. 디버그 모드를 활성화하려면 응용 프로그램을 중지 한 후 다음 환경 변수를 설정하십시오.

```python
(venv) $ export FLASK_DEBUG=1
```

Microsoft Windows를 사용 `set`하는 경우 대신 대신 사용하십시오 `export`.

를 설정 한 후 `FLASK_DEBUG`서버를 다시 시작하십시오. 터미널의 출력은 다음과 같이 약간 다릅니다.

```python
(venv) microblog2 $ flask run
 * Serving Flask app "microblog"
 * Forcing debug mode on
 * Running on http://127.0.0.1:5000/ (Press CTRL+C to quit)
 * Restarting with stat
 * Debugger is active!
 * Debugger PIN: 177-562-960
```

이제 브라우저에서 대화 형 디버거를 보려면 응용 프로그램 충돌을 한 번 더 만드십시오.

![플라스크 디버거](.\images\mega-tutorial/ch07-debugger.png)

디버거를 사용하면 각 스택 프레임을 확장하고 해당 소스 코드를 볼 수 있습니다. 또한 모든 프레임에서 Python 프롬프트를 열고 변수 값을 확인하는 등의 유효한 Python 표현식을 실행할 수 있습니다.

프로덕션 서버에서는 Flask 응용 프로그램을 디버그 모드로 실행하지 않아야합니다. 디버거를 통해 사용자는 서버에서 원격으로 코드를 실행할 수 있으므로 응용 프로그램이나 서버에 침투하려는 악의적 인 사용자에게 예기치 않은 선물이 될 수 있습니다. 추가 보안 조치로 브라우저에서 실행되는 디버거가 잠기기 시작하고 처음 사용할 때 `flask run`명령 의 출력에서 볼 수있는 PIN 번호를 묻습니다 .

내가 디버그 모드의 항목입니다 때문에, 나는이다 디버그 모드로 설정되어 두 번째 중요한 기능을 언급해야한다 *장전을* . 소스 파일이 수정 될 때 응용 프로그램을 자동으로 다시 시작하는 매우 유용한 개발 기능입니다. `flask run`디버그 모드에서 실행 하면 응용 프로그램에서 작업 할 수 있으며 파일을 저장할 때마다 응용 프로그램이 다시 시작되어 새 코드를 가져옵니다.

## 맞춤 오류 페이지

Flask는 응용 프로그램이 자체 오류 페이지를 설치하는 메커니즘을 제공하므로 사용자는 평범하고 지루한 기본 페이지를 볼 필요가 없습니다. 예를 들어, 가장 일반적인 두 가지 HTTP 오류 404 및 500에 대한 사용자 정의 오류 페이지를 정의 해 봅시다. 다른 오류에 대한 페이지를 정의하는 것도 같은 방식으로 작동합니다.

사용자 지정 오류 처리기를 선언하기 위해 `@errorhandler`데코레이터가 사용됩니다. 오류 처리기를 새로운 *app / errors.py* 모듈 에 넣겠습니다 .

*app / errors.py* : 사용자 정의 오류 처리기

```python
from flask import render_template
from app import app, db

@app.errorhandler(404)
def not_found_error(error):
    return render_template('404.html'), 404

@app.errorhandler(500)
def internal_error(error):
    db.session.rollback()
    return render_template('500.html'), 500
```

오류 기능은 기능을 보는 것과 매우 유사하게 작동합니다. 이 두 가지 오류에 대해서는 해당 템플릿의 내용을 반환합니다. 두 함수 모두 템플릿 다음에 두 번째 값 (오류 코드 번호)을 반환합니다. 지금까지 만든 모든 뷰 함수에 대해 기본값 200 (성공적인 응답을위한 상태 코드)이 내가 원하는 것이므로 두 번째 반환 값을 추가 할 필요가 없습니다. 이 경우 이들은 오류 페이지이므로 응답의 상태 코드가이를 반영하기를 원합니다.

데이터베이스 오류 후에 500 개의 오류에 대한 오류 처리기가 호출 될 수 있습니다. 실제로는 사용자 이름이 위의 중복입니다. 실패한 데이터베이스 세션이 템플리트에 의해 트리거 된 데이터베이스 액세스를 방해하지 않도록 세션 롤백을 발행합니다. 세션이 깨끗한 상태로 재설정됩니다.

다음은 404 오류의 템플릿입니다.

*app / templates / 404.html* : 오류 템플릿을 찾을 수 없음

```html
{% extends "base.html" %}

{% block content %}
    <h1>File Not Found</h1>
    <p><a href="{{ url_for('index') }}">Back</a></p>
{% endblock %}
```

다음은 500 오류에 대한 것입니다.

*app / templates / 500.html* : 내부 서버 오류 템플릿

```html
{% extends "base.html" %}

{% block content %}
    <h1>An unexpected error has occurred</h1>
    <p>The administrator has been notified. Sorry for the inconvenience!</p>
    <p><a href="{{ url_for('index') }}">Back</a></p>
{% endblock %}
```

두 템플릿 모두 템플릿에서 상속 `base.html`되므로 오류 페이지의 모양과 느낌이 응용 프로그램의 일반 페이지와 동일합니다.

이러한 오류 처리기를 Flask에 등록 하려면 응용 프로그램 인스턴스를 만든 후 새 *app / errors.py* 모듈 을 가져와야합니다 .

*app / __ init__.py* : 가져 오기 오류 처리기

```python
# ...

from app import routes, models, errors
```

`FLASK_DEBUG=0`터미널 세션에서 설정 한 다음 중복 된 사용자 이름 버그를 한 번 더 트리거하면 약간 더 친숙한 오류 페이지가 표시됩니다.

![맞춤 500 오류 페이지](.\images\mega-tutorial/ch07-500-custom.png)

## 이메일로 오류 보내기

Flask가 제공하는 기본 오류 처리의 다른 문제점은 알림이없고 오류에 대한 스택 추적이 터미널에 인쇄되므로 오류를 발견하기 위해 서버 프로세스의 출력을 모니터링해야한다는 것입니다. 개발하는 동안 응용 프로그램을 실행하면 완벽하게 작동하지만 응용 프로그램이 프로덕션 서버에 배포되면 아무도 출력을 보지 않으므로 더 강력한 솔루션을 배치해야합니다.

오류에 대해 선제 적으로 접근하는 것이 매우 중요하다고 생각합니다. 응용 프로그램의 프로덕션 버전에서 오류가 발생하면 즉시 알고 싶습니다. 그래서 첫 번째 해결책은 오류 직후 이메일을 보내도록 Flask를 구성하는 것입니다. 이메일 본문의 오류 추적 추적.

첫 번째 단계는 이메일 서버 세부 사항을 구성 파일에 추가하는 것입니다.

*config.py* : 이메일 구성

```python
class Config(object):
    # ...
    MAIL_SERVER = os.environ.get('MAIL_SERVER')
    MAIL_PORT = int(os.environ.get('MAIL_PORT') or 25)
    MAIL_USE_TLS = os.environ.get('MAIL_USE_TLS') is not None
    MAIL_USERNAME = os.environ.get('MAIL_USERNAME')
    MAIL_PASSWORD = os.environ.get('MAIL_PASSWORD')
    ADMINS = ['your-email@example.com']
```

이메일의 구성 변수에는 서버 및 포트, 암호화 된 연결을 가능하게하는 부울 플래그 및 선택적 사용자 이름 및 비밀번호가 포함됩니다. 5 개의 구성 변수는 해당 환경 변수에서 제공됩니다. 전자 메일 서버가 환경에 설정되어 있지 않으면 전자 메일 오류를 비활성화해야한다는 표시로 사용하겠습니다. 이메일 서버 포트는 환경 변수로 제공 될 수도 있지만 설정되지 않은 경우 표준 포트 25가 사용됩니다. 전자 메일 서버 자격 증명은 기본적으로 사용되지 않지만 필요한 경우 제공 할 수 있습니다. `ADMINS`자신의 이메일 주소가이 목록에 있어야 있도록 구성 변수는 오류 보고서를받을 이메일 주소 목록입니다.

Flask는 Python `logging`패키지를 사용 하여 로그를 작성 하며이 패키지에는 이미 이메일로 로그를 보낼 수있는 기능이 있습니다. 오류로 이메일을 전송하기 위해해야 할 일은 Flask 로거 객체에 [SMTPHandler](https://docs.python.org/3.6/library/logging.handlers.html#smtphandler) 인스턴스를 추가하는 [것](https://docs.python.org/3.6/library/logging.handlers.html#smtphandler) 입니다 `app.logger`.

*app / __ init__.py* : 이메일로 오류 기록

```python
import logging
from logging.handlers import SMTPHandler

# ...

if not app.debug:
    if app.config['MAIL_SERVER']:
        auth = None
        if app.config['MAIL_USERNAME'] or app.config['MAIL_PASSWORD']:
            auth = (app.config['MAIL_USERNAME'], app.config['MAIL_PASSWORD'])
        secure = None
        if app.config['MAIL_USE_TLS']:
            secure = ()
        mail_handler = SMTPHandler(
            mailhost=(app.config['MAIL_SERVER'], app.config['MAIL_PORT']),
            fromaddr='no-reply@' + app.config['MAIL_SERVER'],
            toaddrs=app.config['ADMINS'], subject='Microblog Failure',
            credentials=auth, secure=secure)
        mail_handler.setLevel(logging.ERROR)
        app.logger.addHandler(mail_handler)
```

당신이 볼 수 있듯이, 나는 단지 응용 프로그램으로 표시됩니다 디버그 모드없이 실행 중일 때 이메일 로거를 활성화하는거야 `app.debug`되는 `True`전자 메일 서버 구성에 존재하는 경우도합니다.

많은 이메일 서버에 존재하는 선택적 보안 옵션을 처리해야하기 때문에 이메일 로거 설정은 다소 지루합니다. 그러나 본질적으로 위의 코드는 `SMTPHandler`인스턴스를 생성하고 경고, 정보 또는 디버깅 메시지가 아닌 오류 만보고하고 최종적으로 `app.logger`Flask 의 객체에 연결하도록 인스턴스를 설정합니다 .

이 기능을 테스트하는 방법에는 두 가지가 있습니다. 가장 쉬운 방법은 Python의 SMTP 디버깅 서버를 사용하는 것입니다. 이것은 전자 메일을 수락하는 가짜 전자 메일 서버이지만 전자 메일을 보내지 않고 콘솔에 인쇄합니다. 이 서버를 실행하려면 두 번째 터미널 세션을 열고 다음 명령을 실행하십시오.

```python
(venv) $ python -m smtpd -n -c DebuggingServer localhost:8025
```

실행 디버깅 SMTP 서버를두고 첫 번째 단자와 세트로 돌아가 `export MAIL_SERVER=localhost`과 `MAIL_PORT=8025`(사용 환경에 `set`대신 `export`Microsoft Windows를 사용하는 경우). 애플리케이션이 디버그 모드에서 이메일을 보내지 않으므로 `FLASK_DEBUG`변수가 설정되어 있는지 `0`또는 전혀 설정되어 있지 않은지 확인하십시오 . 응용 프로그램을 실행하고 SQLAlchemy 오류를 한 번 더 트리거하여 가짜 전자 메일 서버를 실행하는 터미널 세션에 오류의 전체 스택 추적이 포함 된 전자 메일이 어떻게 표시되는지 확인하십시오.

이 기능에 대한 두 번째 테스트 방법은 실제 이메일 서버를 구성하는 것입니다. 다음은 Gmail 계정의 이메일 서버를 사용하기위한 구성입니다.

```bash
export MAIL_SERVER=smtp.googlemail.com
export MAIL_PORT=587
export MAIL_USE_TLS=1
export MAIL_USERNAME=<your-gmail-username>
export MAIL_PASSWORD=<your-gmail-password>
```

Microsoft Windows를 사용 하는 경우 위의 각 설명 `set`대신에 사용하십시오 `export`.

Gmail 계정에 "안전하지 않은 앱"액세스를 명시 적으로 허용하지 않으면 Gmail 계정의 보안 기능으로 인해 애플리케이션이 이메일을 통해 이메일을 보내지 못할 수 있습니다. [여기](https://support.google.com/accounts/answer/6010255?hl=en) 에서이 내용을 읽을 수 있으며 계정의 보안이 걱정되는 경우 이메일 테스트만을 위해 구성하는 보조 계정을 만들거나 보안이 취약한 앱을 일시적으로 만 테스트하여이 테스트를 실행 한 다음 되돌릴 수 있습니다 기본값으로.

## 파일에 로깅

이메일을 통해 오류를 수신하는 것은 좋지만 때로는 이것으로 충분하지 않습니다. 파이썬 예외로 끝나지 않고 큰 문제는 아니지만 몇 가지 실패 조건이 있지만 여전히 디버깅 목적으로 저장하기에 충분히 흥미로울 수 있습니다. 이러한 이유로 응용 프로그램의 로그 파일도 유지 관리합니다.

파일 처리기 로그를 다른 처리기 (이번 [RotatingFileHandler](https://docs.python.org/3.6/library/logging.handlers.html#rotatingfilehandler) 유형) 로 사용하려면 전자 메일 처리기와 비슷한 방식으로 응용 프로그램 로거에 연결해야합니다.

*app / __ init__.py* : 파일에 로깅

```python
# ...
from logging.handlers import RotatingFileHandler
import os

# ...

if not app.debug:
    # ...

    if not os.path.exists('logs'):
        os.mkdir('logs')
    file_handler = RotatingFileHandler('logs/microblog.log', maxBytes=10240,
                                       backupCount=10)
    file_handler.setFormatter(logging.Formatter(
        '%(asctime)s %(levelname)s: %(message)s [in %(pathname)s:%(lineno)d]'))
    file_handler.setLevel(logging.INFO)
    app.logger.addHandler(file_handler)

    app.logger.setLevel(logging.INFO)
    app.logger.info('Microblog startup')
```

*로그* 디렉토리에 이름 `microblog.log`이있는 로그 파일을 작성하고 있습니다.이 디렉토리가 없으면 작성합니다.

이 `RotatingFileHandler`클래스는 로그를 회전시켜 애플리케이션이 오랫동안 실행될 때 로그 파일이 너무 커지지 않도록하기 때문에 좋습니다. 이 경우 로그 파일의 크기를 10KB로 제한하고 마지막 10 개의 로그 파일을 백업으로 유지합니다.

이 `logging.Formatter`클래스는 로그 메시지에 대한 사용자 정의 형식을 제공합니다. 이 메시지는 파일로 전송되므로 가능한 많은 정보를 원합니다. 그래서 타임 스탬프, 로깅 수준, 메시지 및 소스 파일과 로그 항목이 시작된 줄 번호를 포함하는 형식을 사용하고 있습니다.

로깅을 더 유용하게 만들기 위해 `INFO`응용 프로그램 로거와 파일 로거 처리기 모두에서 로깅 수준을 범주로 낮추고 있습니다. 경우에 당신은 그들이는, 로깅 범주에 익숙하지 않은 `DEBUG`, `INFO`, `WARNING`, `ERROR`와 `CRITICAL`심각도가 증가하는 순서.

로그 파일의 첫 번째 흥미로운 용도로 서버는 시작할 때마다 로그에 한 줄을 씁니다. 이 애플리케이션이 프로덕션 서버에서 실행될 때이 로그 항목은 서버가 다시 시작된시기를 알려줍니다.

## 중복 된 사용자 이름 버그 수정

사용자 이름 중복 버그를 너무 오랫동안 악용했습니다. 이 유형의 오류를 처리하기 위해 응용 프로그램을 준비하는 방법을 보여 주었으므로 계속 진행할 수 있습니다.

당신이 기억한다면, `RegistrationForm`이미 사용자 이름에 대한 유효성 검사를 구현하지만 편집 양식의 요구 사항이 약간 다릅니다. 등록하는 동안 양식에 입력 한 사용자 이름이 데이터베이스에 존재하지 않는지 확인해야합니다. 프로필 편집 양식에서 동일한 검사를 수행해야하지만 한 가지 예외가 있습니다. 사용자가 원래 사용자 이름을 그대로두면 해당 사용자 이름이 해당 사용자에게 이미 할당되어 있으므로 유효성 검사를 통해 사용자 이름을 허용해야합니다. 아래에서이 양식의 사용자 이름 유효성 검사를 어떻게 구현했는지 확인할 수 있습니다.

*app / forms.py* : 프로필 편집 양식에서 사용자 이름을 확인합니다.

```python
class EditProfileForm(FlaskForm):
    username = StringField('Username', validators=[DataRequired()])
    about_me = TextAreaField('About me', validators=[Length(min=0, max=140)])
    submit = SubmitField('Submit')

    def __init__(self, original_username, *args, **kwargs):
        super(EditProfileForm, self).__init__(*args, **kwargs)
        self.original_username = original_username

    def validate_username(self, username):
        if username.data != self.original_username:
            user = User.query.filter_by(username=self.username.data).first()
            if user is not None:
                raise ValidationError('Please use a different username.')
```

구현은 사용자 정의 유효성 검사 방법이지만 원래 사용자 이름을 인수로 허용하는 오버로드 된 생성자가 있습니다. 이 사용자 이름은 인스턴스 변수로 저장되고 `validate_username()`메소드 에서 체크인됩니다 . 양식에 입력 한 사용자 이름이 원래 사용자 이름과 동일하면 데이터베이스의 중복 여부를 확인할 이유가 없습니다.

이 새로운 유효성 검사 방법을 사용하려면 양식 객체가 생성되는 view 함수에 원래 사용자 이름 인수를 추가해야합니다.

*app / routes.py* : 프로필 편집 양식에서 사용자 이름을 확인합니다.

```python
@app.route('/edit_profile', methods=['GET', 'POST'])
@login_required
def edit_profile():
    form = EditProfileForm(current_user.username)
    # ...
```

이제 버그가 수정되었으며 대부분의 경우 프로필 편집 양식의 복제가 방지됩니다. 두 개 이상의 프로세스가 동시에 데이터베이스에 액세스 할 때 작동하지 않을 수 있으므로 완벽한 솔루션은 아닙니다. 이 경우 *경쟁 조건으로* 인해 유효성 검사가 통과 될 수 있지만 잠시 후 이름 바꾸기를 시도하면 데이터베이스가 이미 다른 프로세스에 의해 변경되어 사용자 이름을 바꿀 수 없습니다. 많은 서버 프로세스가있는 매우 바쁜 응용 프로그램을 제외하고는 다소 가능성이 없으므로 지금은 걱정하지 않을 것입니다.

이 시점에서 오류를 한 번 더 재현하여 새로운 양식 유효성 검사 방법으로 오류를 방지 할 수 있습니다.



## [Part VIII: Followers](https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-viii-followers)

이 글은 Flask Mega-Tutorial 시리즈의 8 번째 작품으로, 트위터 및 기타 소셜 네트워크와 유사한 '팔로어'기능을 구현하는 방법을 설명합니다.

이 장의 GitHub 링크는:  *[Browse](https://github.com/miguelgrinberg/microblog/tree/v0.8), [Zip](https://github.com/miguelgrinberg/microblog/archive/v0.8.zip), [Diff](https://github.com/miguelgrinberg/microblog/compare/v0.7...v0.8).*



## 재검토 된 데이터베이스 관계

위에서 말한대로 각 사용자에 대해 "followed"및 "follower"사용자 목록을 유지하고 싶다고했습니다. 불행히도 관계형 데이터베이스에는 이러한 목록에 사용할 수있는 목록 유형이 없습니다. 모든 레코드와 이러한 레코드 사이의 관계가있는 테이블이 있습니다.

데이터베이스에는 사용자를 나타내는 테이블이 있으므로 남은 것은 팔로어 / 팔로어 링크를 모델링 할 수있는 적절한 관계 유형을 제시하는 것입니다. 이제 기본적인 데이터베이스 관계 유형을 검토하십시오.

### 일대 다

나는 [4 장](https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-iv-database) 에서 이미 일대 다 관계를 사용했다 . 이 관계에 대한 다이어그램은 다음과 같습니다.

![일대 다 관계](.\images\mega-tutorial/ch04-users-posts.png)

이 관계로 연결된 두 엔터티는 사용자와 게시물입니다. 나는 사용자가 가지고 있다고 *많은* 게시물을, 그리고 게시물이 *하나의* 사용자 (또는 저자). 관계는 "많은"쪽에 *외래 키* 를 사용하여 데이터베이스에 표시됩니다 . 위의 관계에서 외래 키는 테이블에 `user_id`추가 된 필드 `posts`입니다. 이 필드는 각 게시물을 사용자 테이블의 작성자 레코드에 연결합니다.

해당 `user_id`입력란이 특정 게시물의 작성자에게 직접 액세스 할 수 있다는 것이 분명 하지만 반대 방향은 어떻습니까? 관계가 유용하기 위해서는 주어진 사용자가 작성한 게시물 목록을 얻을 수 있어야합니다. `user_id`필드 `posts`데이터베이스는 우리가 "X의 USER_ID가 모든 게시물을 검색"효율적인 쿼리를 허용 인덱스를 가지고있는 테이블은이 질문에 대답하기에 충분하다.

### 다 대다

다 대다 관계는 조금 더 복잡합니다. 예를 들어,이 데이터베이스를 고려 `students`하고 `teachers`. 나는 학생이 가지고 말할 수있는 *많은* 교사와 교사가 *많은* 학생들. 두 끝에서 두 개의 일대 다 관계가 겹치는 것과 같습니다.

이 유형의 관계를 위해 데이터베이스를 쿼리하고 주어진 학생을 가르치는 교사 목록과 교사 클래스의 학생 목록을 얻을 수 있어야합니다. 기존 테이블에 외래 키를 추가하여 수행 할 수 없으므로 관계형 데이터베이스에 표시하기가 실제로 쉽지 않습니다.

다 대다 관계를 표시하려면 *연관 테이블* 이라는 보조 테이블을 사용해야 *합니다* . 데이터베이스가 학생과 교사의 예를 찾는 방법은 다음과 같습니다.

![다 대다](.\images\mega-tutorial/ch08-students-teachers.png)

처음에는 명확하지 않을 수도 있지만 두 개의 외래 키가있는 연결 테이블은 관계에 대한 모든 쿼리에 효율적으로 응답 할 수 있습니다.

### 다 대일 및 일대일

다대 일은 일대 다 관계와 유사합니다. 차이점은이 관계가 "많은"측면에서 바라본다는 것입니다.

일대일 관계는 일대 다의 특별한 경우입니다. 표현은 비슷하지만 "많은"측에 둘 이상의 링크가있는 것을 막기 위해 데이터베이스에 제한 조건이 추가됩니다. 이 유형의 관계가 유용한 경우가 있지만 다른 유형만큼 일반적이지 않습니다.

## 추종자 대표

모든 관계 유형의 개요를 살펴보면, 사용자가 다음 있기 때문에, 추종자를 추적 할 수있는 적절한 데이터 모델은 다 대다 관계임을 결정할 수 있도록 쉽게 *많은* 사용자 및 사용자가 *많은* 추종자를. 그러나 비틀기가 있습니다. 학생과 교사의 사례에서 저는 다 대다 관계를 통해 관련된 두 개의 엔티티를 가졌습니다. 그러나 추종자의 경우 다른 사용자를 따르는 사용자가 있으므로 사용자 만 있습니다. 다 대다 관계의 두 번째 실체는 무엇입니까?

관계의 두 번째 엔터티도 사용자입니다. 클래스의 인스턴스가 동일한 클래스의 다른 인스턴스에 연결되는 *관계를 자기 참조 관계* 라고하며 이것이 바로 여기에 있습니다.

다음은 추종자를 추적하는 자기 참조 다 대다 관계의 다이어그램입니다.

![다 대다](.\images\mega-tutorial/ch08-followers-schema.png)

`followers`테이블의 관계를 연관 테이블이다. 이 테이블의 외래 키는 사용자를 사용자와 연결하기 때문에 사용자 테이블의 항목을 모두 가리 킵니다. 이 테이블의 각 레코드는 팔로어 사용자와 팔로어 사용자 간의 하나의 링크를 나타냅니다. 학생 및 교사의 예와 같이 이와 같은 설정을 통해 데이터베이스는 내가 필요로하는 추종자 및 추종자 사용자에 대한 모든 질문에 대답 할 수 있습니다. 꽤 깔끔한.

## 데이터베이스 모델 표현

먼저 데이터베이스에 추종자를 추가합시다. `followers`연관 테이블 은 다음 과 같습니다.

*app / models.py* : 팔로워 관련 테이블

```python
followers = db.Table('followers',
    db.Column('follower_id', db.Integer, db.ForeignKey('user.id')),
    db.Column('followed_id', db.Integer, db.ForeignKey('user.id'))
)
```

이것은 위의 다이어그램에서 연결 테이블을 직접 번역 한 것입니다. 사용자 및 게시물 테이블에서했던 것처럼이 테이블을 모델로 선언하지 않습니다. 외래 키 이외의 데이터가없는 보조 테이블이므로 연관된 모델 클래스없이 생성했습니다.

이제 users 테이블에서 다 대다 관계를 선언 할 수 있습니다.

*app / models.py* : 다 대다 팔로워 관계

```python
class User(UserMixin, db.Model):
    # ...
    followed = db.relationship(
        'User', secondary=followers,
        primaryjoin=(followers.c.follower_id == id),
        secondaryjoin=(followers.c.followed_id == id),
        backref=db.backref('followers', lazy='dynamic'), lazy='dynamic')
```

관계 설정은 사소하지 않습니다. 나는에 대한처럼 `posts`일대 다 관계, 내가 사용하고 `db.relationship`모델 클래스의 관계를 정의하는 기능. 이 관계는 `User`인스턴스를 다른 `User`인스턴스에 연결하므로이 관계로 연결된 한 쌍의 사용자에 대해 왼쪽 사용자가 오른쪽 사용자를 따르고 있다고 가정합니다. 왼쪽 `followed`에서이 관계를 쿼리 할 때 왼쪽에서이 관계를 쿼리 할 때 따르는 사용자 목록 (즉 오른쪽에있는 사람들)을 얻을 수 있기 때문에 왼쪽 사용자에게 보이는 관계를 정의하고 있습니다. `db.relationship()`호출 에 대한 모든 인수를 하나씩 살펴 보자 .

- `'User'`관계의 오른쪽 엔터티입니다 (왼쪽 엔터티는 부모 클래스 임). 이것은 자기 참조 관계이기 때문에 양쪽에서 같은 클래스를 사용해야합니다.
- `secondary` 이 관계에 사용되는 연결 테이블을 구성합니다.이 클래스 바로 위에 정의했습니다.
- `primaryjoin`왼쪽 엔터티 (팔로어 사용자)를 연결 테이블과 연결하는 조건을 나타냅니다. 관계의 왼쪽에 대한 결합 조건 `follower_id`은 연관 테이블 의 필드와 일치하는 사용자 ID 입니다. `followers.c.follower_id`식은 참조 `follower_id`어소시에이션 테이블 칼럼.
- `secondaryjoin`오른쪽 엔터티 (따라서 사용자)를 연결 테이블과 연결하는 조건을 나타냅니다. 이 조건은의 조건과 비슷하지만 `primaryjoin`현재 사용하고있는 유일한 차이점 `followed_id`은 연관 테이블의 다른 외래 키입니다.
- `backref`오른쪽 엔터티에서이 관계에 액세스하는 방법을 정의합니다. 왼쪽에서 관계의 이름 `followed`이이므로 오른쪽에서 이름 `followers`을 사용 하여 오른쪽의 대상 사용자에 연결된 모든 왼쪽 사용자를 나타냅니다. 추가 `lazy`인수는이 쿼리의 실행 모드를 나타냅니다. `dynamic`특별히 요청 될 때까지 쿼리가 실행되지 않도록 설정 하는 모드는 게시물 일대 다 관계를 설정하는 방법입니다.
- `lazy`은에서 동일한 이름의 매개 변수와 유사 `backref`하지만이 매개 변수 는 오른쪽 대신 왼쪽 쿼리에 적용됩니다.

이해하기 어려운 경우 걱정하지 마십시오. 이 쿼리를 사용하는 방법을 잠시 후에 보여 드리면 모든 것이 명확 해집니다.

데이터베이스 변경 사항은 새 데이터베이스 마이그레이션에 기록해야합니다.

```bash
(venv) $ flask db migrate -m "followers"
INFO  [alembic.runtime.migration] Context impl SQLiteImpl.
INFO  [alembic.runtime.migration] Will assume non-transactional DDL.
INFO  [alembic.autogenerate.compare] Detected added table 'followers'
  Generating /home/miguel/microblog/migrations/versions/ae346256b650_followers.py ... done

(venv) $ flask db upgrade
INFO  [alembic.runtime.migration] Context impl SQLiteImpl.
INFO  [alembic.runtime.migration] Will assume non-transactional DDL.
INFO  [alembic.runtime.migration] Running upgrade 37f06a334dbf -> ae346256b650, followers
```

## "follows"추가 및 제거

SQLAlchemy ORM 덕분에 다른 사용자를 따르는 사용자 `followed`는 마치 목록 인 것처럼 관계를 가지고 작업하는 데이터베이스에 기록 될 수 있습니다 . 예를 들어, 두 명의 사용자 `user1`와 `user2`변수를 저장 한 경우이 간단한 명령문으로 첫 번째 사용자를 두 번째로 따를 수 있습니다.

```python
user1.followed.append(user2)
```

사용자 팔로우를 중단하려면 다음을 수행하십시오.

```python
user1.followed.remove(user2)
```

추종자를 추가하고 제거하는 것이 매우 쉽지만 코드에서 재사용 성을 높이고 싶기 때문에 코드에 "추가"및 "제거"를 뿌리지 않습니다. 대신, "팔로우"및 "언 팔로우"기능을 `User`모델의 메소드로 구현하겠습니다 . 이 장의 뒷부분에서 볼 수 있듯이 단위 테스트가 훨씬 쉬워 지므로 애플리케이션 로직을 뷰 함수에서 모델 또는 기타 보조 클래스 또는 모듈로 옮기는 것이 가장 좋습니다.

다음은 관계를 추가 및 제거하기위한 사용자 모델의 변경 사항입니다.

*app / models.py* : 팔로워 추가 및 제거

```python
class User(UserMixin, db.Model):
    #...

    def follow(self, user):
        if not self.is_following(user):
            self.followed.append(user)

    def unfollow(self, user):
        if self.is_following(user):
            self.followed.remove(user)

    def is_following(self, user):
        return self.followed.filter(
            followers.c.followed_id == user.id).count() > 0
```

and 메소드는 위에 표시된대로 관계 오브젝트 의 `follow()`및 `unfollow()`메소드를 사용 하지만 관계를 만지기 전에 지원 메소드를 사용하여 요청 된 조치가 의미가 있는지 확인합니다. 예를 들어, 을 따르 라고 요청 했지만이 다음 관계가 이미 데이터베이스에 존재하는 것으로 판명되면 중복을 추가하고 싶지 않습니다. 팔로우 해제에 동일한 논리를 적용 할 수 있습니다.`append()``remove()``is_following()``user1``user2`

이 `is_following()`메소드는 `followed`관계 에 대한 조회를 발행하여 두 사용자 간의 링크가 이미 존재하는지 확인합니다. `filter_by()`예를 들어 사용자 이름이 지정된 사용자를 찾기 위해 SQLAlchemy 쿼리 객체 의 메소드를 사용하는 것을 보았습니다 . 여기서 `filter()`사용하는 방법은 비슷하지만 더 낮은 수준 `filter_by()`입니다. 상수 값과 같은지 확인하는 것과 달리 임의의 필터링 조건이 포함될 수 있습니다. 내가 사용하는 조건 `is_following()`은 연결 테이블에서 왼쪽 외래 키가 `self`사용자로 설정되고 오른쪽이 `user`인수로 설정된 항목 을 찾습니다 . 쿼리는 `count()`결과 수를 반환 하는 메서드 로 종료 됩니다. 이 쿼리의 결과는 `0`또는`1`따라서 카운트가 1보다 크거나 0보다 큰지 확인하는 것은 실제로 동일합니다. 과거에 내가 사용한 다른 쿼리 종결자는 `all()`and `first()`입니다.

## 팔로우 한 사용자로부터 게시물 얻기

데이터베이스에서 팔로어에 대한 지원은 거의 완료되었지만 실제로 중요한 기능이 하나 없습니다. 응용 프로그램의 색인 페이지에서 로그인 한 사용자가 따르는 모든 사람들이 작성한 블로그 게시물을 표시 하므로이 게시물을 반환하는 데이터베이스 쿼리를 작성해야합니다.

가장 확실한 해결책은 이미 알고 있듯이 팔로우 된 사용자 목록을 반환하는 쿼리를 실행하는 것입니다 `user.followed.all()`. 그런 다음 반환 된 각 사용자에 대해 게시물을 가져 오기 위해 쿼리를 실행할 수 있습니다. 게시물이 모두 있으면 단일 목록으로 병합하여 날짜별로 정렬 할 수 있습니다. 좋은데? 글쎄,별로.

이 접근법에는 몇 가지 문제점이 있습니다. 사용자가 수천 명을 팔로우하면 어떻게 되나요? 모든 게시물을 수집하기 위해 수천 개의 데이터베이스 쿼리를 실행해야합니다. 그런 다음 수천 개의 목록을 메모리에 병합하고 정렬해야합니다. 두 번째 문제는 응용 프로그램의 홈페이지에 페이지 *매김이* 구현되어 있으므로 사용 가능한 모든 게시물을 표시하지 않고 원하는 경우 더 많은 링크를 제공하는 첫 번째 게시물 만 표시 한다는 점을 고려하십시오 . 날짜별로 정렬 된 게시물을 표시하려면 모든 게시물을 가져 와서 먼저 정렬하지 않는 한 어떤 사용자가 가장 최근에 팔로우 한 모든 사용자를 결합했는지 알 수 있습니까? 이것은 실제로 확장 성이 좋지 않은 끔찍한 솔루션입니다.

블로그 게시물의 병합 및 정렬을 피할 수있는 방법은 없지만 응용 프로그램에서 블로그 게시물을 작성하면 매우 비효율적 인 프로세스가됩니다. 이런 종류의 작업은 관계형 데이터베이스의 장점입니다. 데이터베이스에는 쿼리와 정렬을 훨씬 효율적으로 수행 할 수있는 인덱스가 있습니다. 실제로 내가 원하는 것은 얻고 자하는 정보를 정의하는 단일 데이터베이스 쿼리를 만든 다음 데이터베이스가 가장 효율적인 방법으로 해당 정보를 추출하는 방법을 알아내는 것입니다.

아래에서이 쿼리를 볼 수 있습니다.

*app / models.py* : 팔로우 된 게시물 쿼리

```python
class User(UserMixin, db.Model):
    #...
    def followed_posts(self):
        return Post.query.join(
            followers, (followers.c.followed_id == Post.user_id)).filter(
                followers.c.follower_id == self.id).order_by(
                    Post.timestamp.desc())
```

이것은 지금 까지이 응용 프로그램에서 사용한 가장 복잡한 쿼리입니다. 이 쿼리를 한 번에 하나씩 해독하려고합니다. 이 쿼리의 구조를 보면, 당신은 세 가지에 의해 디자인 된 부분이 있다는 것을 통지에 가고 `join()`, `filter()`그리고 `order_by()`SQLAlchemy의 쿼리 개체의 방법 :

```python
Post.query.join(...).filter(...).order_by(...)
```

### 조인

조인 작업이 수행하는 작업을 이해하기 위해 예를 살펴 보겠습니다. `User`다음 내용 이 포함 된 테이블 이 있다고 가정합니다 .

| 신분증 | 사용자 이름 |
| :----- | :---------- |
| 1      | 남자        |
| 2      | 수잔        |
| 삼     | 메리        |
| 4      | 데이비드    |

일을 단순하게 유지하기 위해 사용자 모델의 모든 필드가 아닌이 쿼리에 중요한 필드 만 표시합니다.

의가 있다고 가정 해 봅시다 `followers`연관 테이블은 해당 사용자가 말한다 `john`사용자를 따르고 `susan`하고 `david`, 사용자가 `susan`따르고 `mary`사용자가 `mary`다음입니다 `david`. 위를 나타내는 데이터는 다음과 같습니다.

| follower_id | followed_id |
| :---------- | :---------- |
| 1           | 2           |
| 1           | 4           |
| 2           | 삼          |
| 삼          | 4           |

마지막으로 게시물 테이블에는 각 사용자의 게시물이 하나씩 있습니다.

| 신분증 | 본문              | user_id |
| :----- | :---------------- | :------ |
| 1      | 수잔에서 게시     | 2       |
| 2      | 메리에서 게시     | 삼      |
| 삼     | 데이비드에서 게시 | 4       |
| 4      | 존에서 게시       | 1       |

이 표에는이 토론에 포함되지 않은 일부 필드도 생략되어 있습니다.

`join()`이 쿼리에 대해 다시 정의한 호출 은 다음과 같습니다 .

```python
Post.query.join(followers, (followers.c.followed_id == Post.user_id))
```

게시물 테이블에서 조인 작업을 호출하고 있습니다. 첫 번째 인수는 추종자 연관 테이블이고 두 번째 인수는 조인 *조건* 입니다. 이 호출로 말하는 것은 데이터베이스가 게시물과 추종자 테이블의 데이터를 결합하는 임시 테이블을 만들고 싶다는 것입니다. 인수로 전달한 조건에 따라 데이터가 병합됩니다.

내가 사용한 조건 `followed_id`은 추종자 테이블 의 필드가 `user_id`게시물 테이블 의 필드와 같아야 한다고 말합니다 . 이 병합을 수행하기 위해 데이터베이스는 게시물 테이블 (조인의 왼쪽)에서 각 레코드를 가져 와서 `followers`조건과 일치하는 테이블 (조인의 오른쪽) 에서 모든 레코드를 추가합니다 . 여러 레코드가 `followers`조건과 일치하면 각 게시물에 대해 게시물 입력이 반복됩니다. 특정 게시물에 대해 팔로어에서 일치하는 항목이 없으면 해당 게시물 레코드가 조인의 일부가 아닙니다.

위에서 정의한 예제 데이터에서 결합 작업의 결과는 다음과 같습니다.

| 신분증 | 본문              | user_id | follower_id | followed_id |
| :----- | :---------------- | :------ | :---------- | :---------- |
| 1      | 수잔에서 게시     | 2       | 1           | 2           |
| 2      | 메리에서 게시     | 삼      | 2           | 삼          |
| 삼     | 데이비드에서 게시 | 4       | 1           | 4           |
| 삼     | 데이비드에서 게시 | 4       | 삼          | 4           |

참고 방법 `user_id`및 `followed_id`이이 조건에 가입했다대로 열은, 모든 경우에 동일하다. `john`팔로어 `john`에 팔로우 된 사용자 가있는 항목이 없기 때문에 사용자의 게시물 이 조인 된 테이블에 나타나지 않습니다. 즉, 아무도 john 을 팔로우하지 않습니다 . 그리고 `david`그 사용자 뒤에는 두 명의 다른 사용자가 있기 때문에 님 의 게시물 이 두 번 나타납니다.

이 조인을 생성하여 얻은 내용을 즉시 명확하게 알 수는 없지만 더 큰 쿼리의 일부이므로 계속 읽으십시오.

### 필터

조인 작업을 통해 나에게 어떤 사용자가 따르는 모든 게시물 목록이 표시되었습니다. 이 목록의 하위 집합에만 관심이 있으며 게시물 다음에 단일 사용자가 필요하므로 필요하지 않은 모든 항목을 잘라야 `filter()`전화로 할 수 있습니다 .

다음은 쿼리의 필터 부분입니다.

```python
filter(followers.c.follower_id == self.id)
```

이 쿼리는 class의 메소드에 `User`있으므로 `self.id`표현식은 내가 관심있는 사용자의 사용자 ID를 참조합니다. `filter()`호출은 결합 된 테이블 `follower_id`에서이 사용자로 설정된 열 이있는 항목을 선택합니다 . 즉, 이 사용자를 팔로어로하는 항목 만 유지합니다.

내가 관심있는 사용자 `john`가 `id`필드를 1로 설정 했다고 가정 해 봅시다 . 조인 된 테이블이 필터링을 수행하는 방법은 다음과 같습니다.

| 신분증 | 본문              | user_id | follower_id | followed_id |
| :----- | :---------------- | :------ | :---------- | :---------- |
| 1      | 수잔에서 게시     | 2       | 1           | 2           |
| 삼     | 데이비드에서 게시 | 4       | 1           | 4           |

그리고 이것은 내가 원하는 게시물입니다.

쿼리는 `Post`클래스에서 발행 되었으므로 데이터베이스에서이 쿼리의 일부로 생성 한 임시 테이블로 끝나더라도 결과는 추가 열없이이 임시 테이블에 포함 된 게시물이됩니다. 결합 작업에 의해 추가됩니다.

### 정렬

프로세스의 마지막 단계는 결과를 정렬하는 것입니다. 이를 수행하는 쿼리 부분은 다음과 같습니다.

```
order_by(Post.timestamp.desc())
```

여기서는 게시물의 타임 스탬프 필드를 기준으로 결과를 내림차순으로 정렬하고 싶다고 말하고 있습니다. 이 순서로 첫 번째 결과는 가장 최근의 블로그 게시물입니다.

## 자체 및 팔로우 된 게시물 결합

`followed_posts()`함수 에서 사용하는 쿼리 는 매우 유용하지만 한 가지 제한이 있습니다. 사람들은 자신의 게시물이 팔로우 된 사용자의 타임 라인에 포함되어있을 것으로 예상하며 쿼리에는 해당 기능이 없습니다.

이 검색어를 확장하여 사용자 자신의 게시물을 포함시키는 방법에는 두 가지가 있습니다. 가장 간단한 방법은 쿼리를 그대로두고 모든 사용자가 자신을 따르는 지 확인하는 것입니다. 당신이 당신의 자신의 팔로어라면, 위의 쿼리는 당신이 따르는 모든 사람들의 게시물과 함께 당신의 자신의 게시물을 찾을 것입니다. 이 방법의 단점은 팔로어에 관한 통계에 영향을 미친다는 것입니다. 모든 추종자 수는 1 씩 증가하므로 표시되기 전에 조정해야합니다. 두 번째 방법은 사용자 자신의 게시물을 반환하는 두 번째 쿼리를 만든 다음 "union"연산자를 사용하여 두 쿼리를 단일 쿼리로 결합하는 것입니다.

두 가지 옵션을 모두 고려한 후 두 번째 옵션을 사용하기로 결정했습니다. 다음 `followed_posts()`은 통합을 통해 사용자의 게시물을 포함 하도록 기능이 확장 된 후입니다.

*app / models.py* : 사용자 자신의 게시물이있는 게시물 게시물 조회.

```python
    def followed_posts(self):
        followed = Post.query.join(
            followers, (followers.c.followed_id == Post.user_id)).filter(
                followers.c.follower_id == self.id)
        own = Post.query.filter_by(user_id=self.id)
        return followed.union(own).order_by(Post.timestamp.desc())
```

정렬이 적용되기 전에 `followed`및 `own`쿼리가 하나로 결합되는 방법에 유의하십시오 .

## 사용자 모델 단위 테스트

추종자 구현을 고려하지는 않지만 "복잡한"기능을 구축했지만 사소한 것이 아니라고 생각합니다. 사소한 코드를 작성할 때의 관심사는 응용 프로그램의 다른 부분을 수정함에 따라 앞으로이 코드가 계속 작동하도록하는 것입니다. 이미 작성한 코드가 앞으로도 계속 작동하도록하는 가장 좋은 방법은 변경 될 때마다 다시 실행할 수있는 자동화 된 테스트 모음을 만드는 것입니다.

파이썬에는 `unittest`단위 테스트를 쉽게 작성하고 실행할 수 있는 매우 유용한 패키지가 포함되어 있습니다 . *tests.py* 모듈 `User`에서 클래스 의 기존 메소드에 대한 단위 테스트를 작성해 보겠습니다 .

*tests.py* : 사용자 모델 단위 테스트.

```python
from datetime import datetime, timedelta
import unittest
from app import app, db
from app.models import User, Post

class UserModelCase(unittest.TestCase):
    def setUp(self):
        app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite://'
        db.create_all()

    def tearDown(self):
        db.session.remove()
        db.drop_all()

    def test_password_hashing(self):
        u = User(username='susan')
        u.set_password('cat')
        self.assertFalse(u.check_password('dog'))
        self.assertTrue(u.check_password('cat'))

    def test_avatar(self):
        u = User(username='john', email='john@example.com')
        self.assertEqual(u.avatar(128), ('https://www.gravatar.com/avatar/'
                                         'd4c74594d841139328695756648b6bd6'
                                         '?d=identicon&s=128'))

    def test_follow(self):
        u1 = User(username='john', email='john@example.com')
        u2 = User(username='susan', email='susan@example.com')
        db.session.add(u1)
        db.session.add(u2)
        db.session.commit()
        self.assertEqual(u1.followed.all(), [])
        self.assertEqual(u1.followers.all(), [])

        u1.follow(u2)
        db.session.commit()
        self.assertTrue(u1.is_following(u2))
        self.assertEqual(u1.followed.count(), 1)
        self.assertEqual(u1.followed.first().username, 'susan')
        self.assertEqual(u2.followers.count(), 1)
        self.assertEqual(u2.followers.first().username, 'john')

        u1.unfollow(u2)
        db.session.commit()
        self.assertFalse(u1.is_following(u2))
        self.assertEqual(u1.followed.count(), 0)
        self.assertEqual(u2.followers.count(), 0)

    def test_follow_posts(self):
        # create four users
        u1 = User(username='john', email='john@example.com')
        u2 = User(username='susan', email='susan@example.com')
        u3 = User(username='mary', email='mary@example.com')
        u4 = User(username='david', email='david@example.com')
        db.session.add_all([u1, u2, u3, u4])

        # create four posts
        now = datetime.utcnow()
        p1 = Post(body="post from john", author=u1,
                  timestamp=now + timedelta(seconds=1))
        p2 = Post(body="post from susan", author=u2,
                  timestamp=now + timedelta(seconds=4))
        p3 = Post(body="post from mary", author=u3,
                  timestamp=now + timedelta(seconds=3))
        p4 = Post(body="post from david", author=u4,
                  timestamp=now + timedelta(seconds=2))
        db.session.add_all([p1, p2, p3, p4])
        db.session.commit()

        # setup the followers
        u1.follow(u2)  # john follows susan
        u1.follow(u4)  # john follows david
        u2.follow(u3)  # susan follows mary
        u3.follow(u4)  # mary follows david
        db.session.commit()

        # check the followed posts of each user
        f1 = u1.followed_posts().all()
        f2 = u2.followed_posts().all()
        f3 = u3.followed_posts().all()
        f4 = u4.followed_posts().all()
        self.assertEqual(f1, [p2, p4, p1])
        self.assertEqual(f2, [p2, p3])
        self.assertEqual(f3, [p3, p4])
        self.assertEqual(f4, [p4])

if __name__ == '__main__':
    unittest.main(verbosity=2)
```

사용자 모델에서 암호 해싱, 사용자 아바타 및 팔로어 기능을 시험하는 네 가지 테스트를 추가했습니다. `setUp()`및 `tearDown()`방법은 장치가 각각 각 시험 전후의 프레임 워크가 실행하는 테스트 특별한 방법이다. `setUp()`단위 테스트에서 개발에 사용하는 일반 데이터베이스를 사용하지 못하도록 약간의 해킹을 구현했습니다 . 응용 프로그램 구성을 변경 `sqlite://`하면 테스트 중에 SQLAlchemy가 메모리 내 SQLite 데이터베이스를 사용할 수 있습니다. `db.create_all()`호출은 모든 데이터베이스 테이블을 작성합니다. 이것은 테스트에 유용한 데이터베이스를 처음부터 빠르게 만드는 빠른 방법입니다. 개발 및 프로덕션 사용을 위해 데이터베이스 마이그레이션을 통해 데이터베이스 테이블을 만드는 방법을 이미 보여주었습니다.

다음 명령을 사용하여 전체 테스트 스위트를 실행할 수 있습니다.

```bash
(venv) $ python tests.py
test_avatar (__main__.UserModelCase) ... ok
test_follow (__main__.UserModelCase) ... ok
test_follow_posts (__main__.UserModelCase) ... ok
test_password_hashing (__main__.UserModelCase) ... ok

----------------------------------------------------------------------
Ran 4 tests in 0.494s

OK
```

이제부터 애플리케이션을 변경할 때마다 테스트를 다시 실행하여 테스트중인 기능이 영향을받지 않도록 할 수 있습니다. 또한 응용 프로그램에 다른 기능이 추가 될 때마다 단위 테스트를 작성해야합니다.

## 추종자를 응용 프로그램과 통합

데이터베이스 및 모델에서 팔로어 지원이 완료되었지만이 기능을 응용 프로그램에 통합하지 않았으므로 이제 추가 할 것입니다. 좋은 소식은이 작업을 수행하는 데 큰 어려움이 없으며 이미 배운 개념을 기반으로한다는 것입니다.

사용자를 팔로우하고 팔로우 해제하기 위해 애플리케이션에 두 개의 새로운 경로를 추가해 보겠습니다.

*app / routes.py* : 경로를 따르고 *따르지 않습니다* .

```python
@app.route('/follow/<username>')
@login_required
def follow(username):
    user = User.query.filter_by(username=username).first()
    if user is None:
        flash('User {} not found.'.format(username))
        return redirect(url_for('index'))
    if user == current_user:
        flash('You cannot follow yourself!')
        return redirect(url_for('user', username=username))
    current_user.follow(user)
    db.session.commit()
    flash('You are following {}!'.format(username))
    return redirect(url_for('user', username=username))

@app.route('/unfollow/<username>')
@login_required
def unfollow(username):
    user = User.query.filter_by(username=username).first()
    if user is None:
        flash('User {} not found.'.format(username))
        return redirect(url_for('index'))
    if user == current_user:
        flash('You cannot unfollow yourself!')
        return redirect(url_for('user', username=username))
    current_user.unfollow(user)
    db.session.commit()
    flash('You are not following {}.'.format(username))
    return redirect(url_for('user', username=username))
```

이것들은 설명이 필요하지만 예기치 않은 문제를 방지하기 위해하고있는 모든 오류 검사에주의를 기울이고 문제가 발생했을 때 사용자에게 유용한 메시지를 제공하십시오.

이제 뷰 기능을 사용하면 응용 프로그램의 페이지에서 해당 뷰에 연결할 수 있습니다. 각 사용자의 프로필 페이지에서 사용자를 팔로우하고 팔로우 해제하기위한 링크를 추가하겠습니다.

*app / templates / user.html* : 사용자 프로필 페이지의 링크를 팔로우 및 언 팔로우합니다.

```html
        ...
        <h1>User: {{ user.username }}</h1>
        {% if user.about_me %}<p>{{ user.about_me }}</p>{% endif %}
        {% if user.last_seen %}<p>Last seen on: {{ user.last_seen }}</p>{% endif %}
        <p>{{ user.followers.count() }} followers, {{ user.followed.count() }} following.</p>
        {% if user == current_user %}
        <p><a href="{{ url_for('edit_profile') }}">Edit your profile</a></p>
        {% elif not current_user.is_following(user) %}
        <p><a href="{{ url_for('follow', username=user.username) }}">Follow</a></p>
        {% else %}
        <p><a href="{{ url_for('unfollow', username=user.username) }}">Unfollow</a></p>
        {% endif %}
        ...
```

사용자 프로필 템플릿에 대한 변경 사항은 마지막으로 본 타임 스탬프 아래에이 사용자의 팔로어 및 팔로어 사용자 수를 나타내는 행을 추가합니다. 또한 자신의 프로필을 볼 때 "편집"링크가있는 라인에는 세 가지 가능한 링크 중 하나가있을 수 있습니다.

- 사용자가 자신의 프로필을보고있는 경우 "편집"링크가 이전과 같이 표시됩니다.
- 사용자가 현재 팔로우하지 않은 사용자를보고있는 경우 "팔로우"링크가 표시됩니다.
- 사용자가 현재 팔로우중인 사용자를보고있는 경우 "팔로우 취소"링크가 표시됩니다.

이 시점에서 응용 프로그램을 실행하고 몇 명의 사용자를 만들고 팔로우 및 팔로우하지 않는 사용자와 함께 플레이 할 수 있습니다. 기억해야 할 것은 현재 사용자 목록을 볼 수있는 방법이 없기 때문에 팔로우하거나 팔로우를 취소하려는 사용자의 프로필 페이지 URL을 입력하는 것입니다. 예를 들어, 사용자 `susan`이름 으로 사용자를 팔로우하려면 브라우저의 주소 표시 줄에 *http : // localhost : 5000 / user / susan* 을 입력하여 해당 사용자의 프로필 페이지에 액세스해야합니다. 팔로어 또는 팔로어를 발행 할 때 팔로어 및 팔로어 사용자 수가 어떻게 변경되는지 확인하십시오.

응용 프로그램의 색인 페이지에 팔로우 된 게시물 목록을 표시해야하지만 사용자가 아직 블로그 게시물을 작성할 수 없으므로 아직 모든 게시물이 없습니다. 따라서 해당 기능이 적용될 때까지이 변경을 지연하겠습니다.



## [Part IX: Pagination](https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-ix-pagination)

Flask Mega-Tutorial 시리즈의 아홉 번째 버전으로, 데이터베이스 항목 목록을 페이지 매김하는 방법을 알려 드리겠습니다.

이 장의 GitHub 링크는 *[Browse](https://github.com/miguelgrinberg/microblog/tree/v0.9), [Zip](https://github.com/miguelgrinberg/microblog/archive/v0.9.zip), [Diff](https://github.com/miguelgrinberg/microblog/compare/v0.8...v0.9).*입니다.

## 블로그 게시물 제출

간단한 것부터 시작합시다. 홈페이지에는 사용자가 새 게시물을 입력 할 수있는 양식이 있어야합니다. 먼저 폼 클래스를 만듭니다.

*app / forms.py* : 블로그 제출 양식.

```python
class PostForm(FlaskForm):
    post = TextAreaField('Say something', validators=[
        DataRequired(), Length(min=1, max=140)])
    submit = SubmitField('Submit')
```

다음으로이 양식을 응용 프로그램의 기본 페이지 템플릿에 추가 할 수 있습니다.

*app / templates / index.html* : 색인 템플릿으로 제출 양식 게시

```html
{% extends "base.html" %}

{% block content %}
    <h1>Hi, {{ current_user.username }}!</h1>
    <form action="" method="post">
        {{ form.hidden_tag() }}
        <p>
            {{ form.post.label }}<br>
            {{ form.post(cols=32, rows=4) }}<br>
            {% for error in form.post.errors %}
            <span style="color: red;">[{{ error }}]</span>
            {% endfor %}
        </p>
        <p>{{ form.submit() }}</p>
    </form>
    {% for post in posts %}
    <p>
    {{ post.author.username }} says: <b>{{ post.body }}</b>
    </p>
    {% endfor %}
{% endblock %}
```

이 템플릿의 변경 사항은 이전 양식을 처리 한 방식과 유사합니다. 마지막 부분은 뷰 함수에서 폼 생성 및 처리를 추가하는 것입니다.

*app / routes.py* : 인덱스보기 기능으로 제출 양식을 게시합니다.

```python
from app.forms import PostForm
from app.models import Post

@app.route('/', methods=['GET', 'POST'])
@app.route('/index', methods=['GET', 'POST'])
@login_required
def index():
    form = PostForm()
    if form.validate_on_submit():
        post = Post(body=form.post.data, author=current_user)
        db.session.add(post)
        db.session.commit()
        flash('Your post is now live!')
        return redirect(url_for('index'))
    posts = [
        {
            'author': {'username': 'John'},
            'body': 'Beautiful day in Portland!'
        },
        {
            'author': {'username': 'Susan'},
            'body': 'The Avengers movie was so cool!'
        }
    ]
    return render_template("index.html", title='Home Page', form=form,
                           posts=posts)
```

이 뷰 함수의 변경 사항을 하나씩 검토해 보겠습니다.

- 이제 `Post`와 `PostForm`클래스를 가져오고 있습니다
- 이 뷰 함수는 이제 양식 데이터를 수신하므로 요청 외에도 뷰 함수 `POST`와 관련된 두 경로의 요청을 수락 합니다 .`index``GET`
- 양식 처리 논리 `Post`는 데이터베이스에 새 레코드를 삽입 합니다.
- 템플릿 `form`은 텍스트 필드를 렌더링 할 수 있도록 개체를 추가 인수로 받습니다 .

계속하기 전에 웹 양식 처리와 관련하여 중요한 것을 언급하고 싶었습니다. 양식 데이터를 처리 한 후 홈 페이지로 리디렉션하여 요청을 종료하는 방법에 주목하십시오. 리디렉션을 쉽게 건너 뛰고 함수가 템플릿 렌더링 부분으로 계속 내려갈 수있게했습니다. 이것은 이미 색인보기 기능이기 때문입니다.

왜 리디렉션이 필요한가요? `POST`리디렉션으로 웹 양식 제출로 생성 된 요청 에 응답하는 것이 표준 관행 입니다. 이렇게하면 웹 브라우저에서 refresh 명령이 구현되는 방식에 대한 성가심을 완화 할 수 있습니다. 새로 고침 키를 눌렀을 때 모든 웹 브라우저는 마지막 요청을 다시 발행하는 것입니다. 경우 `POST`양식 제출에 요청이 정기적으로 응답을 반환하고 새로 고침 양식을 다시 제출합니다. 이것은 예기치 않은 일이므로 브라우저는 사용자에게 중복 제출을 확인하도록 요청하지만 대부분의 사용자는 브라우저가 요구하는 내용을 이해하지 못합니다. 그러나 `POST`요청이 리디렉션으로 응답되면 브라우저는 이제 `GET`리디렉션에 표시된 페이지를 가져 오기 위해 요청을 보내도록 지시 받으므로 이제 마지막 요청은`POST` 더 이상 요청하면 refresh 명령이 더 예측 가능한 방식으로 작동합니다.

이 간단한 트릭을 [Post / Redirect / Get](https://en.wikipedia.org/wiki/Post/Redirect/Get) 패턴 이라고합니다 . 웹 양식을 제출 한 후 사용자가 실수로 페이지를 새로 고칠 때 중복 게시물을 삽입하지 않습니다.

## 블로그 게시물 표시

당신이 기억한다면, 나는 홈 페이지에 오랫동안 표시해 온 두 개의 가짜 블로그 게시물을 만들었습니다. 이 가짜 객체는 `index`뷰 함수에서 간단한 파이썬리스트로 명시 적으로 생성 됩니다.

```json
    posts = [
        { 
            'author': {'username': 'John'}, 
            'body': 'Beautiful day in Portland!' 
        },
        { 
            'author': {'username': 'Susan'}, 
            'body': 'The Avengers movie was so cool!' 
        }
    ]
```

그러나 이제 주어진 사용자 가보고 싶은 게시물에 대한 쿼리를 반환하는 `followed_posts()`메소드가 `User`모델에 있습니다. 이제 가짜 게시물을 실제 게시물로 바꿀 수 있습니다.

*app / routes.py* : 홈페이지에 실제 게시물을 표시합니다.

```python
@app.route('/', methods=['GET', 'POST'])
@app.route('/index', methods=['GET', 'POST'])
@login_required
def index():
    # ...
    posts = current_user.followed_posts().all()
    return render_template("index.html", title='Home Page', form=form,
                           posts=posts)
```

클래스 의 `followed_posts`메소드는 `User`사용자가 데이터베이스에서 관심있는 게시물을 가져 오도록 구성된 SQLAlchemy 쿼리 오브젝트를 리턴합니다. `all()`이 쿼리를 호출 하면 실행이 트리거되고 반환 값은 모든 결과가 포함 된 목록입니다. 그래서 나는 지금까지 사용했던 가짜 게시물이있는 것과 매우 유사한 구조로 끝납니다. 템플릿이 변경 될 필요가 없을 정도로 가깝습니다.

## 따라 가기 쉬운 사용자 찾기

당신이 알다시피, 응용 프로그램은 사용자가 다른 사용자를 따르게하는 데 큰 도움이되지 않습니다. 실제로 다른 사용자가 무엇인지 전혀 볼 수있는 방법이 없습니다. 몇 가지 간단한 변경 사항으로 해결하겠습니다.

"탐색"페이지를 호출 할 새 페이지를 작성하겠습니다. 이 페이지는 홈페이지처럼 작동하지만 팔로우 된 사용자의 게시물 만 표시하는 대신 모든 사용자의 전체 게시물 스트림을 표시합니다. 새로운 탐색보기 기능은 다음과 같습니다.

*app / routes.py* : 탐색 기능을 탐색하십시오.

```python
@app.route('/explore')
@login_required
def explore():
    posts = Post.query.order_by(Post.timestamp.desc()).all()
    return render_template('index.html', title='Explore', posts=posts)
```

이 뷰 기능에 이상한 점이 있습니까? 이 `render_template()`호출 은 응용 프로그램의 기본 페이지에서 사용 하는 *index.html* 템플릿을 참조합니다 . 이 페이지는 메인 페이지와 매우 유사하므로 템플릿을 재사용하기로 결정했습니다. 그러나 메인 페이지와의 한 가지 차이점은 탐색 페이지에서 블로그 게시물을 작성하는 양식을 원하지 않기 때문에이 뷰 기능 `form`에서 템플릿 호출에 인수를 포함시키지 않았다는 것 입니다.

존재하지 않는 웹 양식을 렌더링하려고 할 때 *index.html* 템플리트가 중단되는 것을 방지하기 위해 양식이 정의 된 경우에만 양식을 렌더링하는 조건부를 추가합니다.

*app / templates / index.html* : 블로그 게시물 제출 양식을 선택 사항으로 만듭니다.

```html
{% extends "base.html" %}

{% block content %}
    <h1>Hi, {{ current_user.username }}!</h1>
    {% if form %}
    <form action="" method="post">
        ...
    </form>
    {% endif %}
    ...
{% endblock %}
```

또한 탐색 모음에서이 새 페이지에 대한 링크를 추가하겠습니다.

*app / templates / base.html* : 탐색 모음에서 탐색 페이지로 링크합니다.

```html
        <a href="{{ url_for('explore') }}">Explore</a>
```

사용자 프로필 페이지에서 블로그 게시물을 렌더링하기 위해 [6 장](https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-vi-profile-page-and-avatars) 에서 소개 한 *_post.html* 하위 템플릿을 기억 하십니까? 이 파일은 사용자 프로필 페이지 템플릿에 포함 된 작은 템플릿이며 다른 템플릿에서도 사용할 수 있도록 분리되었습니다. 이제 블로그 게시물 작성자의 사용자 이름을 링크로 표시하는 기능을 약간 개선하겠습니다.

*app / templates / _post.html* : 블로그 게시물에 작성자 링크를 표시합니다.

```html
    <table>
        <tr valign="top">
            <td><img src="{{ post.author.avatar(36) }}"></td>
            <td>
                <a href="{{ url_for('user', username=post.author.username) }}">
                    {{ post.author.username }}
                </a>
                says:<br>{{ post.body }}
            </td>
        </tr>
    </table>
```

이제이 서브 템플릿을 사용하여 홈에서 블로그 게시물을 렌더링하고 페이지를 탐색 할 수 있습니다.

*app / templates / index.html* : 블로그 게시물 하위 템플릿을 사용합니다.

```html
    ...
    {% for post in posts %}
        {% include '_post.html' %}
    {% endfor %}
    ...
```

하위 `post`템플릿은 이름이 지정된 변수가 존재하기를 기대하며 이것이 인덱스 템플릿의 루프 변수가 명명 된 방식이므로 완벽하게 작동합니다.

이러한 작은 변경으로 응용 프로그램의 유용성이 크게 향상되었습니다. 이제 사용자는 탐색 페이지를 방문하여 알 수없는 사용자의 블로그 게시물을 읽을 수 있으며 해당 게시물을 기반으로 따라야 할 새 사용자를 찾을 수 있습니다. 사용자 이름을 클릭하면 프로필 페이지에 액세스하기 만하면됩니다. 놀랍지 않나요?

이 시점에서 응용 프로그램을 다시 한 번 시도하여 마지막 사용자 인터페이스 향상을 경험하는 것이 좋습니다.

![블로그 게시물](.\images\mega-tutorial/ch09-explore.png)

## 블로그 게시물의 페이지 매김

응용 프로그램은 그 어느 때보 다 좋아 보이지만 홈 페이지에 팔로우되는 모든 게시물을 표시하는 것이 나중에보다 빨리 문제가 될 것입니다. 사용자가 수천 개의 게시물을 팔로우하면 어떻게 되나요? 아니면 백만? 당신이 상상할 수 있듯이, 그러한 많은 게시물 목록을 관리하는 것은 매우 느리고 비효율적입니다.

이 문제를 해결하기 위해 글 목록 에 *페이지* 를 *매길* 것 입니다. 즉, 처음에는 한 번에 제한된 수의 게시물 만 표시하고 전체 게시물 목록을 탐색 할 수있는 링크가 포함됩니다. Flask-SQLAlchemy는 기본적으로 `paginate()`쿼리 방법 으로 페이지 매김을 지원합니다 . 예를 들어, 사용자의 처음 20 개의 게시물을 가져 오려면 `all()`쿼리를 종료하는 호출을 다음과 같이 바꿀 수 있습니다 .

```bash
>>> user.followed_posts().paginate(1, 20, False).items
```

`paginate`방법은 플라스크-SQLAlchemy의 어떠한 질의 개체에서 호출 할 수 있습니다. 세 가지 인수가 필요합니다.

- 1부터 시작하는 페이지 번호
- 페이지 당 항목 수
- 에러 플래그. 인 경우 `True`범위를 벗어난 페이지가 요청되면 404 오류가 자동으로 클라이언트에 반환됩니다. 인 경우 `False`범위를 벗어난 페이지에 대해 빈 목록이 반환됩니다.

의 반환 값 `paginate`은 `Pagination`객체입니다. `items`이 개체 의 속성에는 요청 된 페이지의 항목 목록이 포함됩니다. `Pagination`나중에 논의 할 다른 유용한 것들이 있습니다.

이제 `index()`뷰 함수 에서 페이지 매김을 구현하는 방법에 대해 생각해 봅시다 . 페이지 당 표시 할 항목 수를 결정하는 구성 항목을 응용 프로그램에 추가하여 시작할 수 있습니다.

*config.py* : 페이지 당 게시물 구성.

```python
class Config(object):
    # ...
    POSTS_PER_PAGE = 3
```

구성 파일의 동작을 변경할 수있는 이러한 응용 프로그램 전체의 "손잡이"를 사용하는 것이 좋습니다. 그런 다음 한 곳으로 이동하여 조정할 수 있기 때문입니다. 최종 응용 프로그램에서는 물론 페이지 당 3 개보다 많은 항목을 사용하지만 테스트를 위해 작은 숫자로 작업하는 것이 유용합니다.

다음으로, 페이지 번호가 어떻게 애플리케이션 URL에 통합 될 것인지 결정해야합니다. 상당히 일반적인 방법은 *쿼리 문자열* 인수를 사용하여 선택적 페이지 번호를 지정하는 것입니다 (제공되지 않은 경우 기본값은 페이지 1). 다음은 구현 방법을 보여주는 몇 가지 URL 예입니다.

- 1 페이지, 암시 적 : *http : // localhost : 5000 / index*
- 페이지 1, 명시 적 : *http : // localhost : 5000 / index? page = 1*
- 페이지 3 : *http : // localhost : 5000 / index? page = 3*

쿼리 문자열에 주어진 인수에 액세스하기 위해 Flask의 `request.args`객체를 사용할 수 있습니다 . 쿼리 문자열 인수를 포함 할 수있는 Flask-Login의 사용자 로그인 URL을 구현 한 [5 장](https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-v-user-logins) 에서 이미 이것을 보았습니다 `next`.

아래에서 집에 페이지 매김을 추가하고보기 기능을 탐색하는 방법을 볼 수 있습니다.

*app / routes.py* : 추종자 연관 테이블

```python
@app.route('/', methods=['GET', 'POST'])
@app.route('/index', methods=['GET', 'POST'])
@login_required
def index():
    # ...
    page = request.args.get('page', 1, type=int)
    posts = current_user.followed_posts().paginate(
        page, app.config['POSTS_PER_PAGE'], False)
    return render_template('index.html', title='Home', form=form,
                           posts=posts.items)

@app.route('/explore')
@login_required
def explore():
    page = request.args.get('page', 1, type=int)
    posts = Post.query.order_by(Post.timestamp.desc()).paginate(
        page, app.config['POSTS_PER_PAGE'], False)
    return render_template("index.html", title='Explore', posts=posts.items)
```

이러한 변경으로 두 경로는 `page`쿼리 문자열 인수 또는 기본값 1 에서 표시 할 페이지 번호를 결정한 다음이 `paginate()`방법을 사용 하여 원하는 결과 페이지 만 검색합니다. `POSTS_PER_PAGE`페이지 크기를 결정하는 설정 항목이 통해 액세스 `app.config`개체.

이러한 변경이 얼마나 쉬운 지, 그리고 변경 될 때마다 영향을받는 코드의 양이 적습니다. 다른 부분의 작동 방식에 대한 가정없이 응용 프로그램의 각 부분을 작성하려고하는데 확장 및 테스트가 쉽고 실패하거나 버그가 적은 모듈 식의 강력한 응용 프로그램을 작성할 수 있습니다.

계속해서 페이지 매김 지원을 시도하십시오. 먼저 블로그 게시물이 3 개 이상 있는지 확인하십시오. 탐색 페이지에서보다 쉽게 볼 수 있으며 모든 사용자의 게시물이 표시됩니다. 이제 가장 최근의 3 개의 게시물 만 볼 수 있습니다. 다음 세 가지를 보려면 브라우저의 주소 표시 줄에 *http : // localhost : 5000 / explore? page = 2* 를 입력하십시오.

## 페이지 탐색

다음 변경 사항은 블로그 게시물 목록의 맨 아래에 사용자가 다음 및 / 또는 이전 페이지로 이동할 수있는 링크를 추가하는 것입니다. `paginate()`호출 의 반환 값 `Pagination`은 Flask-SQLAlchemy 의 클래스 개체 라고 언급 했습니까? 지금까지 `items`선택한 페이지에 대해 검색된 항목 목록이 포함 된이 개체 의 속성을 사용했습니다 . 그러나이 객체에는 페이지 매김 링크를 만들 때 유용한 몇 가지 속성이 있습니다.

- `has_next`: 현재 페이지 다음에 하나 이상의 페이지가 더 있으면 참
- `has_prev`: 현재 페이지보다 하나 이상의 페이지가 더 있으면 참
- `next_num`: 다음 페이지의 페이지 번호
- `prev_num`: 이전 페이지의 페이지 번호

이 네 가지 요소를 사용하여 다음 및 이전 페이지 링크를 생성하고 렌더링을 위해 템플릿으로 전달할 수 있습니다.

*app / routes.py* : 다음 및 이전 페이지 링크.

```
@app.route('/', methods=['GET', 'POST'])
@app.route('/index', methods=['GET', 'POST'])
@login_required
def index():
    # ...
    page = request.args.get('page', 1, type=int)
    posts = current_user.followed_posts().paginate(
        page, app.config['POSTS_PER_PAGE'], False)
    next_url = url_for('index', page=posts.next_num) \
        if posts.has_next else None
    prev_url = url_for('index', page=posts.prev_num) \
        if posts.has_prev else None
    return render_template('index.html', title='Home', form=form,
                           posts=posts.items, next_url=next_url,
                           prev_url=prev_url)

 @app.route('/explore')
 @login_required
 def explore():
    page = request.args.get('page', 1, type=int)
    posts = Post.query.order_by(Post.timestamp.desc()).paginate(
        page, app.config['POSTS_PER_PAGE'], False)
    next_url = url_for('explore', page=posts.next_num) \
        if posts.has_next else None
    prev_url = url_for('explore', page=posts.prev_num) \
        if posts.has_prev else None
    return render_template("index.html", title='Explore', \
              posts=posts.items,next_url=next_url, prev_url=prev_url)
```
`next_url`및 `prev_url`이 두 뷰 기능에 의해 반환 된 URL로 설정하려고하는 `url_for()`그 방향으로 페이지가있는 경우에만. 현재 페이지가 게시물 모음의 끝에 있으면 객체의 속성 `has_next`또는 `has_prev`속성 이이고이 경우 해당 방향의 링크는로 설정됩니다 .`Pagination``False``None


`url_for()`이전에 논의하지 않은 함수 의 흥미로운 측면 중 하나 는 키워드 인수를 추가 할 수 있으며 해당 인수의 이름이 URL에서 직접 참조되지 않으면 Flask는이를 URL을 쿼리 인수로 포함시킵니다. .

페이지 매김 링크가 *index.html* 템플리트 로 설정 되었으므로 이제 게시물 목록 바로 아래의 페이지에서 렌더링하십시오.

*app / templates / index.html* : *템플릿에서* 페이지 매김 링크를 렌더링합니다.

```html
    ...
    {% for post in posts %}
        {% include '_post.html' %}
    {% endfor %}
    {% if prev_url %}
    <a href="{{ prev_url }}">Newer posts</a>
    {% endif %}
    {% if next_url %}
    <a href="{{ next_url }}">Older posts</a>
    {% endif %}
    ...
```

이 변경 사항은 인덱스 페이지와 탐색 페이지에서 게시물 목록 아래에 링크를 추가합니다. 첫 번째 링크에는 "최신 게시물"이라는 레이블이 붙어 있으며 이전 페이지를 가리 킵니다 (최신순으로 정렬 된 게시물을 표시한다는 점을 명심하십시오. 따라서 첫 번째 페이지는 최신 내용의 링크입니다). 두 번째 링크에는 "이전 게시물"이라는 레이블이 붙어 있으며 다음 페이지의 게시물을 가리 킵니다. 이 두 링크 중 하나가 `None`이면 조건부를 통해 페이지에서 생략됩니다.

![쪽수 매기기](.\images\mega-tutorial/ch09-pagination.png)

## 사용자 프로필 페이지의 페이지 매김

색인 페이지를 변경하면 충분합니다. 그러나 사용자 프로필 페이지에는 프로필 소유자의 게시물 만 표시하는 게시물 목록도 있습니다. 일관성을 유지하려면 사용자 프로필 페이지를 인덱스 페이지의 페이지 매김 스타일과 일치하도록 변경해야합니다.

나는 여전히 가짜 게시물 객체 목록이있는 사용자 프로필보기 기능을 업데이트하여 시작합니다.

*app / routes.py* : 사용자 프로필보기 기능의 페이지 매김.

```python
@app.route('/user/<username>')
@login_required
def user(username):
    user = User.query.filter_by(username=username).first_or_404()
    page = request.args.get('page', 1, type=int)
    posts = user.posts.order_by(Post.timestamp.desc()).paginate(
        page, app.config['POSTS_PER_PAGE'], False)
    next_url = url_for('user', username=user.username, page=posts.next_num) \
        if posts.has_next else None
    prev_url = url_for('user', username=user.username, page=posts.prev_num) \
        if posts.has_prev else None
    return render_template('user.html', user=user, posts=posts.items,
                           next_url=next_url, prev_url=prev_url)
```

사용자로부터 게시물 목록을 얻으려면 `user.posts`관계가 모델 `db.relationship()`정의 의 결과로 SQLAlchemy에 의해 이미 설정된 쿼리 라는 사실을 이용합니다 `User`. 이 쿼리를 가져 와서 `order_by()`조항을 추가 하여 최신 게시물을 먼저 얻은 다음 색인의 게시물에 대해 한 것처럼 페이지 매김을 수행하고 페이지를 탐색합니다. `url_for()`함수에 의해 생성 된 페이지 매김 링크 `username`는이 사용자 이름이 URL의 동적 구성 요소 인 사용자 프로필 페이지를 다시 가리 키기 때문에 추가 인수 가 필요합니다 .

마지막으로 *user.html* 템플릿 의 변경 사항 은 색인 페이지 에서 변경 한 내용 과 동일합니다.

*app / templates / user.html* : 사용자 프로필 템플릿의 페이지 매김 링크.

```html
    ...
    {% for post in posts %}
        {% include '_post.html' %}
    {% endfor %}
    {% if prev_url %}
    <a href="{{ prev_url }}">Newer posts</a>
    {% endif %}
    {% if next_url %}
    <a href="{{ next_url }}">Older posts</a>
    {% endif %}
```

페이지 매김 기능을 실험 한 후에는 `POSTS_PER_PAGE`구성 항목을보다 합리적인 값으로 설정할 수 있습니다 .

*config.py* : 페이지 당 게시물 구성.

```python
class Config(object):
    # ...
    POSTS_PER_PAGE = 25
```



## [Part X: Email Support](https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-x-email-support)

Flask Mega-Tutorial 시리즈의 10 번째 버전으로, 애플리케이션에서 사용자에게 이메일을 보내는 방법과 이메일 지원 위에 비밀번호 복구 기능을 구축하는 방법에 대해 설명합니다.

이 응용 프로그램은 그래서이 장에서 나는 그 주제에서 출발하고 이메일로 보내는 대부분의 웹 응용 프로그램이 필요로하는 또 다른 중요한 부분을 추가 할, 이제 데이터베이스의 전면에 꽤 잘하고있다.

왜 응용 프로그램은 사용자 이메일로 필요합니까? 이 많은 이유가 있지만 하나의 공통된 하나의 인증 관련 문제를 해결하는 것입니다. 이 장에서 나는 그들의 암호를 잊어 버린 사용자 암호 재설정 기능을 추가하겠습니다. 사용자가 암호 재설정을 요청하면 응용 프로그램이 특수하게 조작 된 링크가 포함 된 이메일을 보내드립니다. 사용자는 새 비밀번호를 설정할 수있는 양식에 액세스 할 수 있도록 링크를 클릭 할 필요가있다.

*이 장의 GitHub 링크는 [Browse](https://github.com/miguelgrinberg/microblog/tree/v0.10) , [Zip](https://github.com/miguelgrinberg/microblog/archive/v0.10.zip) , [Diff](https://github.com/miguelgrinberg/microblog/compare/v0.9...v0.10) 입니다.*

## 플라스크 메일 소개

마찬가지로 지금까지 실제와 같은 이메일의 전송, 플라스크라는 인기 확장명이 [플라스크 메일](https://pythonhosted.org/Flask-Mail/) 매우 쉽게 작업을 할 수 있습니다. 항상 그렇듯이,이 확장은 핍과 함께 설치됩니다 :

```
(venv) $ pip install flask-mail
```

이 토큰을 생성하려면, 내가 사용하는거야 [JSON 웹 토큰](https://jwt.io/) 도 인기 파이썬 패키지가있는 :

```
(venv) $ pip install pyjwt
```

플라스크 메일 확장은에서 구성되는 `app.config`객체입니다. 에 때 기억 [7 장](https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-vii-error-handling) 나는 오류가 생산에서 발생 때마다 자신에게 이메일을 보내는 전자 메일 구성을 추가? 나는 당신에게 이것을 말하지 않았지만, 구성 변수의 선택은 Flask-Mail의 요구 사항을 모델로 했으므로 실제로 필요한 추가 작업이 없으며 구성 변수는 이미 응용 프로그램에 있습니다.

대부분의 플라스크 확장과 마찬가지로, 당신은 플라스크 응용 프로그램을 만든 후 인스턴스 권리를 작성해야합니다. 이 경우이 클래스의 목적은 `Mail`:

*응용 프로그램 / __ init__.py* : 플라스크 메일 인스턴스입니다.

```
# ...
from flask_mail import Mail

app = Flask(__name__)
# ...
mail = Mail(app)
```

당신이 이메일의 전송 테스트를 계획하고 있다면 당신은 내가 언급 같은 두 가지 옵션이 [제 7 장](https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-vii-error-handling) . 당신이 에뮬레이트 이메일 서버를 사용하려는 경우, 파이썬은 다음과 같은 명령으로 제 2 터미널에서 시작할 수 있습니다 매우 편리 하나를 제공합니다 :

```
(venv) $ python -m smtpd -n -c DebuggingServer localhost:8025
```

이 서버에 대한 구성하는 두 개의 환경 변수를 설정해야합니다 :

```
(venv) $ export MAIL_SERVER=localhost
(venv) $ export MAIL_PORT=8025
```

당신이 진짜 보낸 이메일을 선호하는 경우, 당신은 실제 이메일 서버를 사용해야합니다. 당신이 하나를 가지고 있다면, 당신은 단지 설정해야합니다 `MAIL_SERVER`, `MAIL_PORT`, `MAIL_USE_TLS`, `MAIL_USERNAME`그리고 `MAIL_PASSWORD`그것을 위해 환경 변수를. 짧은 솔루션을 원한다면, 당신은 다음과 같은 설정으로 이메일을 보내 Gmail 계정을 사용할 수 있습니다 :

```
(venv) $ export MAIL_SERVER=smtp.googlemail.com
(venv) $ export MAIL_PORT=587
(venv) $ export MAIL_USE_TLS=1
(venv) $ export MAIL_USERNAME=<your-gmail-username>
(venv) $ export MAIL_PASSWORD=<your-gmail-password>
```

Microsoft Windows를 사용하는 경우에는 교체해야 `export`와 `set`의 각 `export`위의 문장.

Gmail 계정에 대한 "보안 수준이 낮은 앱"액세스를 명시 적으로 허용하지 않으면 Gmail 계정의 보안 기능으로 인해 애플리케이션이 이메일을 통해 이메일을 보내지 못할 수 있습니다. [여기](https://support.google.com/accounts/answer/6010255?hl=en) 에서이 내용을 읽을 수 있으며 계정의 보안이 걱정되는 경우 이메일 테스트만을 위해 구성하는 보조 계정을 만들거나 보안이 취약한 앱을 일시적으로 만 테스트를 실행 한 다음 되돌릴 수 있습니다 보다 안전한 기본값으로.

## 플라스크 메일 사용

플라스크 메일 작동 방법에 대한 자세한 내용은, 내가 어떻게 파이썬 쉘에서 이메일을 보내하는 방법을 보여 드리겠습니다. 화재 파이썬 위로 그래서 `flask shell`, 다음, 다음 명령을 실행합니다 :

```
>>> from flask_mail import Message
>>> from app import mail
>>> msg = Message('test subject', sender=app.config['ADMINS'][0],
... recipients=['your-email@example.com'])
>>> msg.body = 'text body'
>>> msg.html = '<h1>HTML body</h1>'
>>> mail.send(msg)
```

위의 코드의 조각은 당신이에 넣어 이메일 주소 목록에 이메일을 보내드립니다 `recipients`인수입니다. 내가 처음 구성 관리자 (내가 추가 한으로 보낸 사람을 넣어 `ADMINS`의 구성 변수 [7 장](https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-vii-error-handling) ). 이메일은 그래서 당신의 이메일 클라이언트가 구성 방식에 따라 하나 또는 다른를 볼 수 있습니다, 일반 텍스트 및 HTML 버전이있을 것이다.

당신이 볼 수 있도록, 이것은 아주 간단합니다. 이제 응용 프로그램에 전자 우편을 통합 할 수 있습니다.

## 간단한 이메일 프레임 워크

전자 메일을 보내는 도우미 함수를 작성하는 것으로 시작하겠습니다. 기본적으로 이전 섹션의 일반적인 셸 연습 버전입니다. 나는라는 새로운 모듈에이 기능을 넣을 것입니다 `app/email.py`:

*응용 프로그램 / email.py* : 이메일 래퍼 함수를 전송.

```
from flask_mail import Message
from app import mail

def send_email(subject, sender, recipients, text_body, html_body):
    msg = Message(subject, sender=sender, recipients=recipients)
    msg.body = text_body
    msg.html = html_body
    mail.send(msg)
```

Flask-Mail은 Cc 및 Bcc 목록과 같이 여기서 사용하지 않는 일부 기능을 지원합니다. 해당 옵션에 관심이있는 경우 [Flask-Mail 설명서](https://pythonhosted.org/Flask-Mail/) 를 확인하십시오 .

## 비밀번호 재설정 요청

위에서 언급했듯이 사용자에게 비밀번호 재설정을 요청할 수있는 옵션이 필요합니다. 이를 위해 로그인 페이지에 링크를 추가하겠습니다.

*app / templates / login.html* : 로그인 양식의 비밀번호 재설정 링크.

```
    <p>
        Forgot Your Password?
        <a href="{{ url_for('reset_password_request') }}">Click to Reset It</a>
    </p>
```

사용자가 링크를 클릭하면 비밀번호 재설정 프로세스를 시작하는 방법으로 사용자의 이메일 주소를 요청하는 새 웹 양식이 나타납니다. 폼 클래스는 다음과 같습니다.

*app / forms.py* : 비밀번호 요청 양식을 재설정합니다.

```
class ResetPasswordRequestForm(FlaskForm):
    email = StringField('Email', validators=[DataRequired(), Email()])
    submit = SubmitField('Request Password Reset')
```

다음은 해당 HTML 템플릿입니다.

*app / templates / reset_password_request.html* : 비밀번호 요청 템플릿을 재설정합니다.

```
{% extends "base.html" %}

{% block content %}
    <h1>Reset Password</h1>
    <form action="" method="post">
        {{ form.hidden_tag() }}
        <p>
            {{ form.email.label }}<br>
            {{ form.email(size=64) }}<br>
            {% for error in form.email.errors %}
            <span style="color: red;">[{{ error }}]</span>
            {% endfor %}
        </p>
        <p>{{ form.submit() }}</p>
    </form>
{% endblock %}
```

이 양식을 처리하려면 뷰 함수가 필요합니다.

*app / routes.py* : 비밀번호 요청보기 기능을 재설정합니다.

```
from app.forms import ResetPasswordRequestForm
from app.email import send_password_reset_email

@app.route('/reset_password_request', methods=['GET', 'POST'])
def reset_password_request():
    if current_user.is_authenticated:
        return redirect(url_for('index'))
    form = ResetPasswordRequestForm()
    if form.validate_on_submit():
        user = User.query.filter_by(email=form.email.data).first()
        if user:
            send_password_reset_email(user)
        flash('Check your email for the instructions to reset your password')
        return redirect(url_for('login'))
    return render_template('reset_password_request.html',
                           title='Reset Password', form=form)
```

이보기 기능은 양식을 처리하는 다른 기능과 상당히 유사합니다. 사용자가 로그인하지 않은 상태에서 시작합니다. 사용자가 로그인 한 경우 비밀번호 재설정 기능을 사용할 필요가 없으므로 색인 페이지로 리디렉션됩니다.

양식이 제출 및 유효 때, 나는 형태로 사용자가 제공 한 이메일로 사용자를 찾아보십시오. 사용자를 찾으면 비밀번호 재설정 이메일을 보냅니다. 이를 위해 `send_password_reset_email()`도우미 기능을 사용하고 있습니다. 아래에서이 기능을 보여 드리겠습니다.

이메일을 보낸 후 사용자에게 이메일을 찾아서 추가 지침을 찾도록 지시 한 다음 로그인 페이지로 다시 리디렉션하라는 메시지를 표시합니다. 당신은 플래싱이 메시지는 사용자가 제공 한 이메일을 알 수없는 경우에도 표시되는 것을 알 수 있습니다. 이것은 클라이언트가 특정 사용자가 회원인지 아닌지 알아 내기 위해이 기능을 사용하지 수 있도록합니다.

## 비밀번호 재설정 토큰

내가 구현하기 전에 `send_password_reset_email()`기능을, 나는 암호 요청 링크를 생성 할 수있는 방법이 필요합니다. 이것은 이메일을 통해 사용자에게 전송되는 링크가 될 것입니다. 링크를 클릭하면 새로운 암호를 설정할 수있는 페이지가 사용자에게 제공됩니다. 이 계획의 까다로운 부분은 계정의 비밀번호를 재설정하는 데 유효한 재설정 링크 만 사용할 수 있도록하는 것입니다.

링크는 *token* 으로 프로비저닝되며 ,이 토큰은 이메일을 요청한 사용자가 계정의 이메일 주소에 액세스 할 수 있음을 증명하기 위해 비밀번호 변경을 허용하기 전에 유효성 검증됩니다. 이 유형의 프로세스에 가장 널리 사용되는 토큰 표준은 JSON 웹 토큰 또는 JWT입니다. JWT의 장점은 자체 포함되어 있다는 것입니다. 전자 메일로 사용자에게 토큰을 보낼 수 있으며 사용자가 토큰을 응용 프로그램으로 다시 공급하는 링크를 클릭하면 자체적으로 확인할 수 있습니다.

JWT는 어떻게 작동합니까? 그것들을 이해하는 빠른 파이썬 쉘 세션보다 나은 것은 없습니다.

```
>>> import jwt
>>> token = jwt.encode({'a': 'b'}, 'my-secret', algorithm='HS256')
>>> token
b'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJhIjoiYiJ9.dvOo58OBDHiuSHD4uW88nfJikhYAXc_sfUHq1mDi4G0'
>>> jwt.decode(token, 'my-secret', algorithms=['HS256'])
{'a': 'b'}
```

`{'a': 'b'}`사전은 토큰에 기록 될 것입니다 예 페이로드입니다. 토큰은 보안을 위해 비밀 키의 요구는 암호화 서명을 만드는 데 사용되는 제공한다. 이 예를 들어 나는 문자열을 사용하고 `'my-secret'`있지만, 응용 프로그램과 함께 난을 사용하는거야 `SECRET_KEY`구성에서. `algorithm`토큰이 얼마나 인수 지정이 발생합니다. `HS256`알고리즘은 가장 널리 이용되고있다.

보시다시피 결과 토큰은 긴 문자 시퀀스입니다. 그러나 이것이 암호화 된 토큰이라고 생각하지 마십시오. 페이로드를 포함한 토큰의 내용은, 누구나 쉽게 디코딩 할 수있다 (저를 믿지 않는?를에 입력 한 후 토큰 위를 복사 [JWT 디버거](https://jwt.io/#debugger-io) 의 내용을 볼 수). 토큰을 안전하게 만드는 것은 페이로드가 *서명* 된다는 것 입니다. 누군가가 토큰의 페이로드를 위조하거나 변조하려고 시도하면 서명이 무효화되고 새 서명을 생성하려면 비밀 키가 필요합니다. 토큰이 확인되면 페이로드의 내용이 해독되어 호출자에게 다시 반환됩니다. 토큰의 서명이 검증 된 경우 페이로드를 진본으로 신뢰할 수 있습니다.

비밀번호 재설정 토큰에 사용할 페이로드의 형식은입니다 `{'reset_password': user_id, 'exp': token_expiration}`. 이 `exp`필드는 JWT의 표준이며, 존재하는 경우 토큰의 만료 시간을 나타냅니다. 토큰에 유효한 서명이 있지만 만료 시간 소인이 지났 으면 유효하지 않은 것으로 간주됩니다. 비밀번호 재설정 기능을 위해이 토큰에 10 분의 수명을 부여합니다.

이메일로 보낸 링크를 사용자가 클릭이 토큰은 URL의 일부가 제일 먼저로 다시 응용 프로그램 URL을 할 것 핸들을 확인하는 것입니다 뷰 기능을 전송하려고합니다. 서명이 유효하면 페이로드에 저장된 ID로 사용자를 식별 할 수 있습니다. 사용자의 신원이 알려지면 응용 프로그램은 새 암호를 요청하여 사용자 계정에 설정할 수 있습니다.

이 토큰은 사용자에 속하기 때문에, 나는의 방법으로 토큰 생성 및 검증 기능을 쓸거야 `User`모델 :

*app / models.py* : 비밀번호 토큰 메소드를 재설정합니다.

```
from time import time
import jwt
from app import app

class User(UserMixin, db.Model):
    # ...

    def get_reset_password_token(self, expires_in=600):
        return jwt.encode(
            {'reset_password': self.id, 'exp': time() + expires_in},
            app.config['SECRET_KEY'], algorithm='HS256').decode('utf-8')

    @staticmethod
    def verify_reset_password_token(token):
        try:
            id = jwt.decode(token, app.config['SECRET_KEY'],
                            algorithms=['HS256'])['reset_password']
        except:
            return
        return User.query.get(id)
```

이 `get_reset_password_token()`함수는 JWT 토큰을 문자열로 생성합니다. (가) 있습니다 `decode('utf-8')`때문에 필요한 `jwt.encode()`함수는 바이트 순서로 토큰을 반환하지만 응용 프로그램에서 문자열로 토큰을 가지고 더 편리합니다.

는 `verify_reset_password_token()`이 클래스로부터 직접 호출 될 수 있다는 것을 의미 정적 메소드이다. 정적 메소드는 클래스 메소드와 유사하지만 정적 메소드가 클래스를 첫 번째 인수로받지 않는다는 점만 다릅니다. 이 메소드는 토큰을 가져 와서 PyJWT의 `jwt.decode()`함수 를 호출하여 토큰을 해독하려고 시도 합니다. 토큰을 확인할 수 없거나 만료되면 예외가 발생하며,이 경우 오류를 방지하기 위해 토큰을 잡고 `None`호출자에게 돌아갑니다 . 토큰이 유효 `reset_password`하면 토큰 페이로드 의 키 값이 사용자의 ID이므로 사용자를로드하고 반환 할 수 있습니다.

## 암호 재설정 이메일 보내기

지금은 토큰을 가지고, 비밀번호 재설정 이메일을 생성 할 수 있습니다. `send_password_reset_email()`기능은에 의존 `send_email()`내가 위에 쓴 기능.

*app / email.py* : 비밀번호 재설정 이메일 기능을 보냅니다.

```
from flask import render_template
from app import app

# ...

def send_password_reset_email(user):
    token = user.get_reset_password_token()
    send_email('[Microblog] Reset Your Password',
               sender=app.config['ADMINS'][0],
               recipients=[user.email],
               text_body=render_template('email/reset_password.txt',
                                         user=user, token=token),
               html_body=render_template('email/reset_password.html',
                                         user=user, token=token))
```

이 기능의 흥미로운 부분은 이메일의 텍스트 및 HTML 컨텐츠가 익숙한 `render_template()`기능을 사용하여 템플리트에서 생성된다는 것 입니다. 템플릿은 사용자와 토큰을 인수로 받아 개인화 된 전자 메일 메시지를 생성 할 수 있습니다. 비밀번호 재설정 이메일의 텍스트 템플릿은 다음과 같습니다.

*app / templates / email / reset_password.txt* : 비밀번호 재설정 이메일의 텍스트

```
Dear {{ user.username }},

To reset your password click on the following link:

{{ url_for('reset_password', token=token, _external=True) }}

If you have not requested a password reset simply ignore this message.

Sincerely,

The Microblog Team
```

다음은 동일한 이메일의 더 나은 HTML 버전입니다.

*app / templates / email / reset_password.html* : 비밀번호 재설정 이메일을위한 HTML

```
<p>Dear {{ user.username }},</p>
<p>
    To reset your password
    <a href="{{ url_for('reset_password', token=token, _external=True) }}">
        click here
    </a>.
</p>
<p>Alternatively, you can paste the following link in your browser's address bar:</p>
<p>{{ url_for('reset_password', token=token, _external=True) }}</p>
<p>If you have not requested a password reset simply ignore this message.</p>
<p>Sincerely,</p>
<p>The Microblog Team</p>
```

이 두 전자 메일 템플릿 `reset_password`의 `url_for()`통화에서 참조 되는 경로는 아직 존재하지 않으며 다음 섹션에서 추가됩니다. `_external=True`나는에 포함 된 주장 `url_for()`을 모두 템플릿 통화도 새로운 기능입니다. `url_for()`기본적으로 생성되는 URL은 상대 URL이므로 예를 들어 `url_for('user', username='susan')`호출은 */ user / susan을* 반환 합니다. 웹 브라우저는 현재 페이지에서 URL의 나머지 부분을 가져 오기 때문에 일반적으로 웹 페이지에서 생성 된 링크에 충분합니다. 그러나 이메일로 URL을 보낼 때 해당 컨텍스트가 존재하지 않으므로 완전한 URL을 사용해야합니다. 때 `_external=True`인수로 전달됩니다 앞의 예에서 반환 할 수 있도록, 완전한 URL이 생성된다 *// localhost를 : 5000 / 사용자 / 수잔 HTTP를*또는 애플리케이션이 도메인 이름에 배포 된 경우 적절한 URL입니다.

## 사용자 비밀번호 재설정

사용자가 이메일 링크를 클릭하면이 기능과 관련된 두 번째 경로가 트리거됩니다. 여기에 암호 요청보기 기능은 다음과 같습니다

*응용 프로그램 / routes.py* : 비밀번호 재설정보기 기능.

```
from app.forms import ResetPasswordForm

@app.route('/reset_password/<token>', methods=['GET', 'POST'])
def reset_password(token):
    if current_user.is_authenticated:
        return redirect(url_for('index'))
    user = User.verify_reset_password_token(token)
    if not user:
        return redirect(url_for('index'))
    form = ResetPasswordForm()
    if form.validate_on_submit():
        user.set_password(form.password.data)
        db.session.commit()
        flash('Your password has been reset.')
        return redirect(url_for('login'))
    return render_template('reset_password.html', form=form)
```

이 뷰 기능에서 먼저 사용자가 로그인하지 않았는지 확인한 다음 `User`클래스 에서 토큰 확인 방법을 호출하여 사용자가 누구인지 확인합니다 . 이 메소드는 토큰이 유효하거나 유효 `None`하지 않은 경우 사용자를 리턴합니다 . 토큰이 유효하지 않으면 홈페이지로 리디렉션됩니다.

토큰이 유효하면 새 비밀번호를 요청하는 두 번째 양식을 사용자에게 제시합니다. 이 양식은 이전 양식과 비슷한 방식으로 처리되며 유효한 양식 제출의 결과로 비밀번호를 변경하는 `set_password()`방법을 호출 `User`한 다음 사용자가 로그인 할 수있는 로그인 페이지로 리디렉션합니다.

`ResetPasswordForm`수업 은 다음과 같습니다 .

*app / forms.py* : 비밀번호 재설정 양식.

```
class ResetPasswordForm(FlaskForm):
    password = PasswordField('Password', validators=[DataRequired()])
    password2 = PasswordField(
        'Repeat Password', validators=[DataRequired(), EqualTo('password')])
    submit = SubmitField('Request Password Reset')
```

다음은 해당 HTML 템플릿입니다.

*응용 프로그램 / 템플릿 / reset_password.html* : 비밀번호 재설정 양식 서식.

```
{% extends "base.html" %}

{% block content %}
    <h1>Reset Your Password</h1>
    <form action="" method="post">
        {{ form.hidden_tag() }}
        <p>
            {{ form.password.label }}<br>
            {{ form.password(size=32) }}<br>
            {% for error in form.password.errors %}
            <span style="color: red;">[{{ error }}]</span>
            {% endfor %}
        </p>
        <p>
            {{ form.password2.label }}<br>
            {{ form.password2(size=32) }}<br>
            {% for error in form.password2.errors %}
            <span style="color: red;">[{{ error }}]</span>
            {% endfor %}
        </p>
        <p>{{ form.submit() }}</p>
    </form>
{% endblock %}
```

암호 재설정 기능은 그래서 당신이 그것을 시도 할, 완료되었습니다.

## 비동기식 이메일

Python에서 제공하는 시뮬레이션 된 전자 메일 서버를 사용하는 경우이를 알지 못했을 수도 있지만 전자 메일을 보내면 응용 프로그램 속도가 상당히 느려집니다. 전자 메일을 보낼 때 발생하는 모든 상호 작용으로 인해 작업이 느려지고 전자 메일을 꺼내는 데 몇 초가 걸리며, 수신자의 전자 메일 서버가 느리거나 여러 수신자가있는 경우 더 걸릴 수 있습니다.

내가 정말로 원하는 것은 `send_email()`함수가 *비동기적인 것* 입니다. 그게 무슨 뜻이야? 즉,이 기능이 호출되면 이메일 전송 작업이 백그라운드에서 발생하도록 예약되어 `send_email()`애플리케이션이 전송되는 이메일과 동시에 애플리케이션을 계속 실행할 수 있도록 즉시 리턴 할 수 있습니다.

파이썬은 실제로 여러 가지 방법으로 비동기 작업을 실행하도록 지원합니다. `threading`및 `multiprocessing`모듈은 모두이 작업을 수행 할 수 있습니다. 새로운 프로세스를 시작하는 것보다 이메일을 보내기위한 백그라운드 스레드를 시작하는 것이 리소스를 덜 사용하므로이 방법을 사용하겠습니다.

*app / email.py* : 이메일을 비동기 적으로 보냅니다.

```
from threading import Thread
# ...

def send_async_email(app, msg):
    with app.app_context():
        mail.send(msg)


def send_email(subject, sender, recipients, text_body, html_body):
    msg = Message(subject, sender=sender, recipients=recipients)
    msg.body = text_body
    msg.html = html_body
    Thread(target=send_async_email, args=(app, msg)).start()
```

이 `send_async_email`함수는 이제 백그라운드 스레드에서 실행되며 `Thread()`의 마지막 행에서 클래스를 통해 호출됩니다 `send_email()`. 이 변경으로 이메일 전송이 스레드에서 실행되며 프로세스가 완료되면 스레드가 종료되고 자체 정리됩니다. 실제 이메일 서버를 구성한 경우 비밀번호 재설정 요청 양식에서 제출 단추를 누르면 속도가 확실히 향상됩니다.

아마도 `msg`인수 만 스레드로 전송 될 것으로 예상 했지만 코드에서 볼 수 있듯이 응용 프로그램 인스턴스도 전송합니다. 나사산 작업시 Flask의 중요한 설계 측면이 염두에 두어야합니다. 플라스크는 사용 *컨텍스트* 기능을 통해 인수를 전달하는 것을 방지 할 수 있습니다. 이에 대해서는 자세히 다루지 않겠지 만 두 가지 유형의 컨텍스트 ( *응용 프로그램 컨텍스트* 와 *요청 컨텍스트)* 가 있다는 것을 알고 있습니다 . 대부분의 경우 이러한 컨텍스트는 프레임 워크에서 자동으로 관리하지만 애플리케이션이 사용자 정의 스레드를 시작할 때 해당 스레드에 대한 컨텍스트를 수동으로 작성해야 할 수 있습니다.

즉 그들이이 인수로 전달되지 않고 플라스크 응용 프로그램 인스턴스를 찾을 수 있기 때문에 작업을 대신 할 응용 프로그램 컨텍스트를 필요로하는 많은 확장 기능이 있습니다. 이유는 많은 확장 그들의 구성이 저장했기 때문에 응용 프로그램 인스턴스가 알아야 할 `app.config`객체입니다. 이것은 Flask-Mail의 상황입니다. 이 `mail.send()`방법은 전자 메일 서버의 구성 값에 액세스해야하며 응용 프로그램이 무엇인지 알아야만 가능합니다. `with app.app_context()`호출 로 생성 된 응용 프로그램 컨텍스트를 통해 `current_app`Flask 의 변수를 통해 응용 프로그램 인스턴스에 액세스 할 수 있습니다 .



## [Part XI: Facelift](https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-xi-facelift)

Flask Mega-Tutorial 시리즈의 11 번째 버전으로, 기본 HTML 템플릿을 Bootstrap 사용자 인터페이스 프레임 워크를 기반으로하는 새로운 세트로 바꾸는 방법을 알려 드리겠습니다.

당신은 지금 내 Microblog 애플리케이션을 가지고 놀았 기 때문에, 나는 그것을 좋아 보이게 만드는 데 너무 많은 시간을 소비하지 않았거나 더 잘 말했다는 것을 알게되었습니다. 내가 만든 템플릿은 사용자 정의 스타일이 전혀없는 매우 기본적입니다. 보기 좋은 HTML과 CSS를 작성하는 데 방해가되지 않고 응용 프로그램의 실제 논리에 집중하는 것이 유용했습니다.

그러나 나는이 응용 프로그램의 백엔드 부분에 잠시 집중했습니다. 그래서이 장에서 나는 이것에서 잠시 벗어나서 좀 더 세련되고 전문적으로 보이도록 할 수있는 것을 보여줄 시간을 가질 것입니다.

이 장은 이전 장과 조금 다를 것입니다. 필자는 일반적으로 Python 측에 대해 자세히 설명하지는 않기 때문에이 자습서의 주요 주제입니다. 멋진 웹 페이지를 만드는 것은 Python 웹 개발과 관련이없는 방대한 주제이지만, 작업에 접근하는 방법에 대한 몇 가지 기본 지침과 아이디어를 논의하고 재 설계된 응용 프로그램을 사용하여 공부하고 배우게됩니다. .

*이 장의 GitHub 링크는 [Browse](https://github.com/miguelgrinberg/microblog/tree/v0.11) , [Zip](https://github.com/miguelgrinberg/microblog/archive/v0.11.zip) , [Diff](https://github.com/miguelgrinberg/microblog/compare/v0.10...v0.11) 입니다.*

## CSS 프레임 워크

우리는 코딩이 어렵다고 주장 할 수 있지만 웹 브라우저 목록에서 멋지고 일관된 모양의 템플릿을 작성해야하는 웹 디자이너와 비교할 때 우리의 고통은 아무것도 아닙니다. 최근 몇 년 동안 더 나아졌지 만 일부 브라우저에는 여전히 모호한 웹 페이지 디자인 작업을 매우 어렵게 만드는 버그 또는 단점이 여전히 모호합니다. 태블릿 및 스마트 폰의 리소스 및 화면 제한 브라우저를 대상으로해야하는 경우 훨씬 더 어렵습니다.

나처럼 괜찮은 웹 페이지를 만들고 싶지만 원시 HTML과 CSS를 작성하여 효과적으로 달성하기위한 낮은 수준의 메커니즘을 배울 시간이없는 개발자라면, 유일한 실용적인 해결책은 다음과 같습니다. 사용하는 *CSS 프레임 워크를* 작업을 단순화 할 수 있습니다. 이 길을 택하면 창의적인 자유를 잃을 수 있지만 다른 한편으로는 많은 노력을 기울이지 않고도 모든 브라우저에서 웹 페이지가 좋아 보일 것입니다. CSS 프레임 워크는 일반적인 유형의 사용자 인터페이스 요소를 위해 사전 작성된 스타일을 가진 고급 CSS 클래스 모음을 제공합니다. 이러한 프레임 워크의 대부분은 HTML 및 CSS로 엄격하게 수행 할 수없는 작업을위한 JavaScript 추가 기능도 제공합니다.

## 부트 스트랩 소개

가장 널리 사용되는 CSS 프레임 워크 중 하나는 Twitter에서 만든 [Bootstrap](http://getbootstrap.com/) 입니다. 이 프레임 워크로 디자인 할 수있는 페이지 종류를 보려면 설명서에 몇 가지 [예가](https://getbootstrap.com/docs/3.3/getting-started/#examples) 있습니다.

웹 페이지 스타일을 지정하기 위해 Bootstrap을 사용하면 다음과 같은 이점이 있습니다.

- 모든 주요 웹 브라우저에서 비슷한 모양
- 데스크탑, 태블릿 및 전화 화면 크기 처리
- 맞춤형 레이아웃
- 멋지게 스타일이 지정된 탐색 모음, 양식, 버튼, 알림, 팝업 등

Bootstrap을 사용하는 가장 직접적인 방법은 기본 템플릿에서 *bootstrap.min.css* 파일을 가져 오는 것 입니다. 이 파일의 사본을 다운로드하여 프로젝트에 추가하거나 [CDN](https://en.wikipedia.org/wiki/Content_delivery_network) 에서 직접 가져올 수 있습니다 . 그런 다음 [documentation](https://getbootstrap.com/docs/3.3/getting-started/) 에 따르면 제공하는 범용 CSS 클래스를 사용할 수 있습니다 . 또한 프레임 워크의 JavaScript 코드가 포함 된 *bootstrap.min.js* 파일 을 가져 와서 가장 고급 기능을 사용할 수도 있습니다.

다행히도 [Flask-Bootstrap](https://pythonhosted.org/Flask-Bootstrap/) 이라는 Flask 확장 이있어 Bootstrap 프레임 워크가 설치된 기본 템플릿을 사용할 수 있습니다. 이 확장을 설치하자 :

```
(venv) $ pip install flask-bootstrap
```

## 플라스크 부트 스트랩 사용

Flask-Bootstrap은 대부분의 다른 Flask 확장과 같이 초기화해야합니다.

*app / __ init__.py* : Flask-Bootstrap 인스턴스.

```
# ...
from flask_bootstrap import Bootstrap

app = Flask(__name__)
# ...
bootstrap = Bootstrap(app)
```

확장명이 초기화되면 *bootstrap / base.html* 템플릿을 사용할 수있게 *되며이*`extends` 절을 사용하여 응용 프로그램 템플릿에서 참조 할 수 있습니다 .

그러나 당신이 기억하는 것처럼, 나는 이미 `extends`자신의 기본 템플릿과 함께 조항을 사용하고 있어서 한 페이지에서 페이지의 공통 부분을 가질 수 있습니다. 내 *base.html* 템플릿은 몇 개의 링크가 포함 된 탐색 모음을 정의하고 `content`블록을 내보냈습니다 . 내 응용 프로그램의 다른 모든 템플릿은 기본 템플릿에서 상속되어 `content`페이지의 주요 내용을 블록에 제공합니다 .

그렇다면 Bootstrap 기본 템플릿을 어떻게 맞출 수 있습니까? 아이디어는 단지 2 개가 아닌 3 단계 계층 구조를 사용하는 것입니다. *부트 스트랩 / base.html의* 템플릿은 부트 스트랩 프레임 워크 파일이 포함 된 페이지의 기본 구조를 제공합니다. 이 템플릿은 같은 파생 된 템플릿 몇 블록을 수출 `title`, `navbar`그리고 `content`(블록의 전체 목록을 보려면 [여기](https://pythonhosted.org/Flask-Bootstrap/basic-usage.html#available-blocks) ). *bootstrap / base.html* 에서 파생되도록 *base.html* 템플릿 을 변경 하고 , 및 블록에 대한 구현을 제공 하겠습니다 . 또한 *base.html* 은 파생 된 템플릿에 대한 자체 블록을 내보내 페이지 내용을 정의합니다.`title``navbar``content``app_content`

아래에서 *base.html* 이 Bootstrap 기본 템플릿에서 상속되도록 수정 한 후의 모습을 볼 수 있습니다 . 이 목록에는 탐색 모음의 전체 HTML이 포함되어 있지 않지만 GitHub에서 전체 구현을 보거나이 장의 코드를 다운로드하여 볼 수 있습니다.

*app / templates / base.html* : 재 설계된 기본 템플릿.

```
{% extends 'bootstrap/base.html' %}

{% block title %}
    {% if title %}{{ title }} - Microblog{% else %}Welcome to Microblog{% endif %}
{% endblock %}

{% block navbar %}
    <nav class="navbar navbar-default">
        ... navigation bar here (see complete code on GitHub) ...
    </nav>
{% endblock %}

{% block content %}
    <div class="container">
        {% with messages = get_flashed_messages() %}
        {% if messages %}
            {% for message in messages %}
            <div class="alert alert-info" role="alert">{{ message }}</div>
            {% endfor %}
        {% endif %}
        {% endwith %}

        {# application content needs to be provided in the app_content block #}
        {% block app_content %}{% endblock %}
    </div>
{% endblock %}
```

여기에서 *bootstrap / base.html* 에서이 템플릿을 파생 시키는 방법과 페이지 제목, 탐색 모음 및 페이지 내용을 각각 구현하는 세 개의 블록 이 어떻게 *나오는지 알* 수 있습니다.

`title`블록은 함께, 페이지 제목에 사용되는 텍스트를 정의 할 필요가 ``태그를. 이 블록 ``에서는 원래 기본 템플릿 의 태그 내부에있는 로직을 이동했습니다 .

`navbar`블록은 탐색 줄을 정의하는 데 사용할 수있는 임의의 블록이다. 이 블록에서는 Bootstrap 탐색 모음 설명서의 예제를 왼쪽 끝에 사이트 브랜딩과 홈 및 탐색 링크가 포함되도록 수정했습니다. 그런 다음 페이지의 오른쪽 테두리에 맞춰 프로필 및 로그인 또는 로그 아웃 링크를 추가했습니다. 위에서 언급했듯이 위 예제에서 HTML을 생략했지만 이 장의 다운로드 패키지에서 전체 *base.html* 템플릿을 얻을 수 있습니다 .

마지막으로, `content`블록 에서 최상위 컨테이너를 정의하고 내부에 플래시 메시지를 렌더링하는 로직이 있으며, 이제 부트 스트랩 경고로 스타일이 표시됩니다. 그런 다음 `app_content`파생 된 템플릿이 자체 컨텐츠를 정의 할 수 있도록 정의 된 새 블록 이 이어 집니다.

모든 페이지 템플릿의 원래 버전은이라는 블록에 내용을 정의했습니다 `content`. 위에서 본 것처럼 이름 `content`이 지정된 블록 은 Flask-Bootstrap에서 사용되므로 내용 블록의 이름을로 변경했습니다 `app_content`. 따라서 모든 템플릿의 이름을 `app_content`콘텐츠 블록 으로 사용하도록 이름을 바꿔야합니다 . 예를 들어 *404.html* 템플릿 의 수정 된 버전은 다음과 같습니다.

*app / templates / 404.html* : 404 오류 템플릿이 재 설계되었습니다.

```
{% extends "base.html" %}

{% block app_content %}
    <h1>File Not Found</h1>
    <p><a href="{{ url_for('index') }}">Back</a></p>
{% endblock %}
```

## 부트 스트랩 양식 렌더링

Flask-Bootstrap이 환상적인 작업을 수행하는 영역은 양식을 렌더링하는 것입니다. Flask-Bootstrap은 양식 필드를 하나씩 스타일링하는 대신 Flask-WTF 양식 객체를 인수로 허용하고 Bootstrap 스타일을 사용하여 완전한 양식을 렌더링하는 매크로와 함께 제공됩니다.

아래에서 재 설계된 *register.html* 템플릿을 예로 볼 수 있습니다 .

*app / templates / register.html* : 사용자 등록 템플릿.

```
{% extends "base.html" %}
{% import 'bootstrap/wtf.html' as wtf %}

{% block app_content %}
    <h1>Register</h1>
    <div class="row">
        <div class="col-md-4">
            {{ wtf.quick_form(form) }}
        </div>
    </div>
{% endblock %}
```

대단하지 않습니까? `import`상단 근처 의 문장은 템플릿 측의 Python 가져 오기와 유사하게 작동합니다. 이는 `wtf.quick_form()`한 줄의 코드로 디스플레이 유효성 검사 오류에 대한 지원을 포함하여 Bootstrap 프레임 워크에 적합한 모든 스타일을 제공 하는 매크로를 추가합니다 .

다시 한 번, 응용 프로그램의 다른 양식에 대해 수행 한 모든 변경 사항을 표시하지는 않지만 이러한 변경 사항은 모두 GitHub에서 다운로드하거나 검사 할 수있는 코드에서 이루어집니다.

## 블로그 게시물의 렌더링

단일 블로그 게시물을 렌더링하는 프리젠 테이션 로직은 *_post.html* 이라는 서브 템플릿으로 추상화되었습니다 . 이 템플릿과 관련하여 필요한 것은 약간 조정하여 Bootstrap에서 잘 보이도록하는 것입니다.

*app / templates / _post.html* : 재 설계된 게시물 하위 템플릿.

```
    <table class="table table-hover">
        <tr>
            <td width="70px">
                <a href="{{ url_for('user', username=post.author.username) }}">
                    <img src="{{ post.author.avatar(70) }}" />
                </a>
            </td>
            <td>
                <a href="{{ url_for('user', username=post.author.username) }}">
                    {{ post.author.username }}
                </a>
                says:
                <br>
                {{ post.body }}
            </td>
        </tr>
    </table>
```

## 렌더링 페이지 매김 링크

페이지 매김 링크는 Bootstrap이 직접 지원하는 또 다른 영역입니다. 이를 위해 Bootstrap [문서](https://getbootstrap.com/docs/3.3/components/#optional-disabled-state) 를 한 번 더 보았고 예제 중 하나를 수정했습니다. *index.html* 페이지 에서 다음과 같이 보입니다 .

*app / templates / index.html* : 재 설계된 페이지 매김 링크.

```
    ...
    <nav aria-label="...">
        <ul class="pager">
            <li class="previous{% if not prev_url %} disabled{% endif %}">
                <a href="{{ prev_url or '#' }}">
                    <span aria-hidden="true">&larr;</span> Newer posts
                </a>
            </li>
            <li class="next{% if not next_url %} disabled{% endif %}">
                <a href="{{ next_url or '#' }}">
                    Older posts <span aria-hidden="true">&rarr;</span>
                </a>
            </li>
        </ul>
    </nav>
```

이 구현에서는 해당 방향에 더 이상 내용이없는 경우 다음 또는 이전 링크를 숨기지 않고 비활성화 된 상태를 적용하여 링크가 회색으로 나타납니다.

여기에 표시하지는 않지만 비슷한 변경 사항을 *user.html에* 적용해야 *합니다* . 이 장의 다운로드 패키지에는 이러한 변경 사항이 포함되어 있습니다.

## 이전과 이후

이러한 변경 사항으로 응용 프로그램을 업데이트하려면이 장의 zip 파일을 다운로드하고 그에 따라 템플릿을 업데이트하십시오.

아래에서 몇 가지 전후 그림을보고 변형을 볼 수 있습니다. 이 변경은 한 줄의 응용 프로그램 논리를 변경하지 않고 달성되었습니다!

![로그인](.\images\mega-tutorial/ch12-login.png) 
![홈페이지](.\images\mega-tutorial/ch12-index.png)



## [Part XII: Dates and Times](https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-xii-dates-and-times)

Flask Mega-Tutorial 시리즈의 12 번째 작품으로, 거주지에 관계없이 모든 사용자가 사용할 수있는 방식으로 날짜와 시간을 다루는 방법을 알려 드리겠습니다.

오랫동안 무시한 마이크로 블로그 응용 프로그램의 측면 중 하나는 날짜와 시간을 표시하는 것입니다. 지금까지는 Python이 User 모델에서 datetime 객체를 렌더링하도록하고 Post 모델에서 datetime 객체를 완전히 무시했습니다.

이 장의 GitHub 링크는 *[Browse](https://github.com/miguelgrinberg/microblog/tree/v0.12), [Zip](https://github.com/miguelgrinberg/microblog/archive/v0.12.zip), [Diff](https://github.com/miguelgrinberg/microblog/compare/v0.11...v0.12).*입니다.



## 시간대 지옥

서버에서 Python을 사용하여 웹 브라우저에서 사용자에게 표시되는 날짜와 시간을 렌더링하는 것은 실제로 좋은 생각이 아닙니다. 다음 예를 고려하십시오. 2017 년 9 월 28 일 오후 4시 06 분에이 글을 쓰고 있습니다.이 글을 쓰는 시점의 시간대는 PDT (또는 원하는 경우 UTC-7)입니다. 파이썬 인터프리터에서 실행하면 다음과 같은 결과를 얻습니다.

```
>>> from datetime import datetime
>>> str(datetime.now())
'2017-09-28 16:06:30.439388'
>>> str(datetime.utcnow())
'2017-09-28 23:06:51.406499'
```

`datetime.now()`그동안 호출은, 내 위치에 대한 올바른 시간을 반환 `datetime.utcnow()`호출은 UTC 시간대의 시간을 반환합니다. 전 세계 다른 지역에 사는 많은 사람들에게 위의 코드를 동시에 실행하도록 요청할 수 있다면 `datetime.now()`기능은 각 사람마다 다른 결과를 `datetime.utcnow()`반환 하지만 위치에 관계없이 항상 같은 시간을 반환합니다. 그렇다면 전 세계에 사용자를 배치 할 가능성이 높은 웹 응용 프로그램에서 사용하는 것이 더 낫다고 생각하는 것은 무엇입니까?

서버는 위치와 일관성이 있고 독립적 인 시간을 관리해야한다는 것이 분명합니다. 이 응용 프로그램이 전 세계의 다른 지역에 여러 프로덕션 서버가 필요한 수준으로 증가하면 각 서버가 다른 시간대의 데이터베이스에 타임 스탬프를 쓰지 않기를 원합니다. UTC가 가장 많이 사용되는 표준 시간대이며 `datetime`클래스 에서 지원되므로 이것이 내가 사용할 것입니다.

그러나이 방법에는 중요한 문제가 있습니다. 시간대가 다른 사용자의 경우 UTC 시간대로 시간이 표시되는 경우 게시 시점을 파악하기가 매우 어렵습니다. 시간을 UTC로 설정하여 시간을 정신적으로 자신의 시간대로 조정할 수 있다는 것을 미리 알아야합니다. PDT 시간대의 사용자가 오후 3시에 무언가를 게시하고 즉시 오후 10시 (UTC) 오후 2시 또는 더 정확한 오후 2 시가 표시되는 것을 보게됩니다. 그것은 매우 혼란 스러울 것입니다.

타임 스탬프를 UTC로 표준화하는 것은 서버의 관점에서 많은 의미가 있지만, 이는 사용자에게 유용성 문제를 일으 킵니다. 이 장의 목표는 서버에서 모든 타임 스탬프를 UTC로 관리하면서이 문제를 해결하는 것입니다.

## 시간대 변환

문제에 대한 확실한 해결책은 모든 타임 스탬프를 저장된 UTC 단위에서 각 사용자의 현지 시간으로 변환하는 것입니다. 이를 통해 서버는 일관성을 위해 UTC를 계속 사용할 수 있으며 각 사용자에 맞게 즉시 변환하여 사용성 문제를 해결할 수 있습니다. 이 솔루션의 까다로운 부분은 각 사용자의 위치를 아는 것입니다.

많은 웹 사이트에는 사용자가 시간대를 지정할 수있는 구성 페이지가 있습니다. 이를 위해서는 시간대 목록이있는 드롭 다운을 사용자에게 표시하는 양식이있는 새 페이지를 추가해야합니다. 사용자는 등록의 일부로 사이트에 처음 액세스 할 때 시간대를 입력하라는 요청을받을 수 있습니다.

이것은 문제를 해결하는 적절한 솔루션이지만 사용자에게 운영 체제에서 이미 구성한 정보를 입력하도록 요구하는 것은 약간 이상합니다. 컴퓨터에서 시간대 설정을 가져올 수 있다면 더 효율적일 것 같습니다.

결과적으로 웹 브라우저는 사용자의 시간대를 알고 표준 날짜 및 시간 JavaScript API를 통해 노출합니다. JavaScript를 통해 사용 가능한 시간대 정보를 활용하는 방법에는 실제로 두 가지가 있습니다.

- "구식"접근 방식은 사용자가 처음 응용 프로그램에 로그온 할 때 웹 브라우저가 시간대 정보를 서버에 보내도록하는 것입니다. 이 작업은 [Ajax](http://en.wikipedia.org/wiki/Ajax_(programming)) 호출 또는 [메타 새로 고침 태그](http://en.wikipedia.org/wiki/Meta_refresh) 를 사용하여 수행 할 수 있습니다 . 서버가 시간대를 알면 사용자의 세션에 유지하거나 데이터베이스의 사용자 항목에 기록한 다음 템플릿이 렌더링 될 때 모든 타임 스탬프를 조정할 수 있습니다.
- "새로운 학교"접근 방식은 서버의 것을 변경하지 않고 JavaScript를 사용하여 클라이언트에서 UTC에서 현지 시간대로의 변환을 수행하는 것입니다.

두 옵션 모두 유효하지만 두 번째 옵션은 큰 이점이 있습니다. 사용자의 시간대를 아는 것만으로는 항상 사용자가 예상 한 형식으로 날짜와 시간을 제시 할 수 없습니다. 브라우저는 또한 시스템 로케일 구성에 액세스 할 수 있으며 AM / PM vs. 24 시간 시계, DD / MM / YYYY vs. MM / DD / YYYY 및 기타 여러 문화 또는 지역 스타일을 지정합니다.

그리고 이것으로 충분하지 않다면, 새로운 학교 접근 방식에 대한 또 다른 이점이 있습니다. 이 모든 작업을 수행하는 오픈 소스 라이브러리가 있습니다!

## Moment.js 및 Flask-Moment 소개

[Moment.js](http://momentjs.com/) 는 작은 오픈 소스 JavaScript 라이브러리로, 날짜 및 시간 렌더링을 상상할 수있는 모든 형식 지정 옵션을 제공하므로 다른 수준으로 렌더링합니다. 그리고 얼마 전에 나는 작은 Flask 확장 인 Flask-Moment를 만들었습니다. 이로 인해 moment.js를 응용 프로그램에 매우 쉽게 통합 할 수 있습니다.

Flask-Moment를 설치하여 시작해 봅시다.

```
(venv) $ pip install flask-moment
```

이 확장은 일반적인 방법으로 Flask 응용 프로그램에 추가됩니다.

*app / __ init__.py* : 플라스크-모멘트 인스턴스.

```
# ...
from flask_moment import Moment

app = Flask(__name__)
# ...
moment = Moment(app)
```

다른 확장과 달리 Flask-Moment는 *moment.js* 와 함께 작동 하므로 응용 프로그램의 모든 템플릿에이 라이브러리가 포함되어야합니다. 이 라이브러리를 항상 사용할 수 있도록 기본 템플릿에 추가하겠습니다. 이것은 두 가지 방법으로 수행 할 수 있습니다. 가장 직접적인 방법은 ``라이브러리를 가져 오는 태그 를 명시 적으로 추가하는 것이지만 태그 `moment.include_moment()`를 생성 하는 함수를 노출시켜 Flask-Moment를 사용하면보다 쉽게 만들 수 있습니다 ``.

*app / templates / base.html* : 기본 템플릿에 moment.js 포함

```
...

{% block scripts %}
    {{ super() }}
    {{ moment.include_moment() }}
{% endblock %}
```

`scripts`내가 여기에 추가 한 블록은 플라스크 - 부트 스트랩의 기본 템플릿 내 보낸 다른 블록이다. 이것은 JavaScript 가져 오기가 포함되는 곳입니다. 이 블록은 기본 템플릿에 정의 된 일부 내용이 이미 포함되어 있다는 점에서 이전 블록과 다릅니다. 기본 내용을 잃지 않고 moment.js 라이브러리를 추가하기 만하면됩니다. 그리고 이것은 `super()`기본 템플릿의 내용을 유지하는 명령문 으로 달성됩니다 . 을 사용하지 않고 템플릿에서 블록을 `super()`정의하면 기본 템플릿에서이 블록에 대해 정의 된 내용이 손실됩니다.

## Moment.js 사용

Moment.js는 `moment`브라우저 에서 클래스를 사용할 수있게합니다. 타임 스탬프를 렌더링하는 첫 번째 단계는 [ISO 8601](http://en.wikipedia.org/wiki/ISO_8601) 형식으로 원하는 타임 스탬프를 전달하여이 클래스의 객체를 만드는 것 입니다. 예를 들면 다음과 같습니다.

```
t = moment('2017-09-28T21:45:23Z')
```

날짜 및 시간에 대한 ISO 8601 표준 형식에 익숙하지 않은 경우 형식은 다음과 같습니다 `{{ year }}-{{ month }}-{{ day }}T{{ hour }}:{{ minute }}:{{ second }}{{ timezone }}`.. 나는 이미 UTC 시간 대로만 작업하기로 결정했기 때문에 마지막 부분은 항상 `Z`ISO 8601 표준의 UTC를 나타내는입니다.

이 `moment`객체는 다양한 렌더링 옵션에 대한 몇 가지 방법을 제공합니다. 다음은 가장 일반적인 옵션 중 일부입니다.

```
moment('2017-09-28T21:45:23Z').format('L')
"09/28/2017"
moment('2017-09-28T21:45:23Z').format('LL')
"September 28, 2017"
moment('2017-09-28T21:45:23Z').format('LLL')
"September 28, 2017 2:45 PM"
moment('2017-09-28T21:45:23Z').format('LLLL')
"Thursday, September 28, 2017 2:45 PM"
moment('2017-09-28T21:45:23Z').format('dddd')
"Thursday"
moment('2017-09-28T21:45:23Z').fromNow()
"7 hours ago"
moment('2017-09-28T21:45:23Z').calendar()
"Today at 2:45 PM"
```

이 예는 2017 년 9 월 28 일 UTC 9:45에 초기화 된 모멘트 객체를 만듭니다. 위에서 시도한 모든 옵션이 내 컴퓨터에 구성된 표준 시간대 인 UTC-7로 렌더링되는 것을 볼 수 있습니다. 브라우저의 콘솔에 위의 명령을 입력하여 콘솔을 여는 페이지에 moment.js가 포함되어 있는지 확인하십시오. moment.js 또는 *https://momentjs.com/* 을 포함하도록 위의 내용을 변경 한 경우 마이크로 블로그에서이를 수행 할 수 있습니다 .

다른 방법으로 다른 표현을 만드는 방법에 유의하십시오. 으로 `format()`당신에게 유사한 형식의 문자열로 출력 형식 제어 [의 strftime의](https://docs.python.org/3.6/library/time.html#time.strftime) 파이썬에서 기능을. `fromNow()`과 `calendar()`그들이 현재 시간을 기준으로 한 타임 스탬프를 렌더링 때문에 "2 시간"과 같은 "분 전에"로 출력을 얻을 정도 방법 등, 흥미

JavaScript에서 직접 작업하는 경우 위의 호출은 렌더링 된 타임 스탬프가있는 문자열을 반환합니다. 그러면이 텍스트를 페이지의 적절한 위치에 삽입하는 것은 사용자의 몫입니다. 불행히도 [DOM](https://en.wikipedia.org/wiki/Document_Object_Model) 작업을 위해서는 JavaScript가 필요합니다 . Flask-Moment 확장 `moment`은 템플릿에서 JavaScript와 유사한 객체 를 활성화하여 moment.js의 사용을 크게 단순화합니다 .

프로필 페이지에 나타나는 타임 스탬프를 살펴 보겠습니다. 현재 *user.html* 템플릿을 사용하면 Python에서 시간의 문자열 표현을 생성 할 수 있습니다. 이제 Flask-Moment를 사용하여 다음과 같이이 타임 스탬프를 렌더링 할 수 있습니다.

*app / templates / user.html* : moment.js로 타임 스탬프를 렌더링합니다.

```
                {% if user.last_seen %}
                <p>Last seen on: {{ moment(user.last_seen).format('LLL') }}</p>
                {% endif %}
```

보시다시피, Flask-Moment는 JavaScript 라이브러리의 구문과 유사한 구문을 사용하지만 한 가지 차이점은 인수 `moment()`가 이제 `datetime`ISO 8601 문자열이 아닌 Python 객체라는 점입니다. `moment()`템플릿에서 실행 된 호출은 또한 필요한 JavaScript 코드를 자동으로 생성하여 렌더링 된 타임 스탬프를 DOM의 적절한 위치에 삽입합니다.

Flask-Moment와 moment.js를 활용할 수있는 두 번째 장소 는 색인 및 사용자 페이지에서 호출되는 *_post.html* 하위 템플릿에 있습니다. 현재 버전의 템플릿에서 각 게시물 앞에는 "username says :"행이 있습니다. 이제 `fromNow()`다음으로 렌더링 된 타임 스탬프를 추가 할 수 있습니다 .

*app / templates / _post.html* : 포스트 서브 템플릿에서 타임 스탬프를 렌더링합니다.

```
                <a href="{{ url_for('user', username=post.author.username) }}">
                    {{ post.author.username }}
                </a>
                said {{ moment(post.timestamp).fromNow() }}:
                <br>
                {{ post.body }}
```

아래에서 Flask-Moment 및 moment.js로 렌더링 할 때 이러한 타임 스탬프가 어떻게 보이는지 확인할 수 있습니다.

![플라스크 순간](.\images\mega-tutorial/ch13-moment.png)





## [Part XIII: I18n and L10n](https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-xiii-i18n-and-l10n)

Flask Mega-Tutorial 시리즈의 13 번째 버전으로, 여러 언어를 지원하기 위해 Microblog를 확장하는 방법을 알려 드리겠습니다. 이러한 노력의 일환으로 flask 명령에 대한 자체 CLI 확장을 만드는 방법도 배웁니다.

이 장의 주제는 국제화 및 현지화이며, 일반적으로 I18n 및 L10n으로 축약됩니다. 영어를 못하는 사람들에게 친숙한 응용 프로그램을 만들기 위해 언어 번역가의 도움으로 선택한 언어로 사용자에게 응용 프로그램을 제공 할 수있는 번역 워크 플로를 구현하겠습니다.

이 장의 GitHub 링크는 *[Browse](https://github.com/miguelgrinberg/microblog/tree/v0.13), [Zip](https://github.com/miguelgrinberg/microblog/archive/v0.13.zip), [Diff](https://github.com/miguelgrinberg/microblog/compare/v0.12...v0.13).* 입니다.



## 플라스크 바벨 소개

짐작할 수 있듯이 번역 작업을 매우 쉽게 수행 할 수있는 Flask 확장이 있습니다. 확장명은 [Flask-Babel](https://pythonhosted.org/Flask-Babel/) 이며 pip와 함께 설치됩니다.

```
(venv) $ pip install flask-babel
```

Flask-Babel은 대부분의 다른 Flask 확장과 같이 초기화됩니다.

*app / __ init__.py* : Flask-Babel 인스턴스.

```
# ...
from flask_babel import Babel

app = Flask(__name__)
# ...
babel = Babel(app)
```

이 장의 일부로, 나는 그 언어를 말할 때 응용 프로그램을 스페인어로 번역하는 방법을 보여줄 것입니다. 또한 다른 언어를 알고 그 언어를 지원하는 번역가들과도 일할 수있었습니다. 지원되는 언어 목록을 추적하기 위해 구성 변수를 추가하겠습니다.

*config.py* : 지원되는 언어 목록.

```
class Config(object):
    # ...
    LANGUAGES = ['en', 'es']
```

이 응용 프로그램에 두 문자 언어 코드를 사용하고 있지만 더 구체적으로 설정해야하는 경우 국가 코드도 추가 할 수 있습니다. 예를 들어, 사용할 수있는 `en-US`, `en-GB`그리고 `en-CA`다른 언어로 미국, 영국과 캐나다 영어를 지원합니다.

`Babel`인스턴스가 제공 `localeselector`장식합니다. 각 요청에 대해 데코 레이팅 된 함수가 호출되어 해당 요청에 사용할 언어 변환을 선택합니다.

*app / __ init__.py* : 가장 적합한 언어를 선택하십시오.

```
from flask import request

# ...

@babel.localeselector
def get_locale():
    return request.accept_languages.best_match(app.config['LANGUAGES'])
```

여기서는 Flask의 `request`객체 속성을 사용하고 `accept_languages`있습니다. 이 오브젝트는 클라이언트가 요청과 함께 전송 하는 [Accept-Language](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Language) 헤더에 대해 작업하기위한 고급 인터페이스를 제공합니다 . 이 헤더는 클라이언트 언어 및 로캘 환경 설정을 가중치 목록으로 지정합니다. 이 헤더의 내용은 브라우저의 환경 설정 페이지에서 구성 할 수 있으며 기본값은 일반적으로 컴퓨터 운영 체제의 언어 설정에서 가져옵니다. 대부분의 사람들은 그러한 설정이 존재한다는 것을 알지 못하지만 사용자가 각각 선호하는 언어 목록을 가중치로 제공 할 수 있으므로 유용합니다. 궁금한 경우 복잡한 `Accept-Languages`헤더 의 예는 다음과 같습니다.

```
Accept-Language: da, en-gb;q=0.8, en;q=0.7
```

이것은 덴마크어 ( `da`)가 선호하는 언어 (기본 가중치 = 1.0)이고 영국 영어 ( `en-GB`)가 0.8이며, 마지막 옵션으로 일반 영어 ( `en`)가 0.7입니다.

최상의 언어를 선택하려면 클라이언트가 요청한 언어 목록을 응용 프로그램이 지원하는 언어와 비교하고 클라이언트 제공 가중치를 사용하여 최상의 언어를 찾으십시오. 이를 수행하는 논리는 다소 복잡하지만 `best_match()`메소드 에서 모두 캡슐화되어 애플리케이션에서 제공하는 언어 목록을 인수로 사용하여 최상의 선택을 리턴합니다.

## 파이썬 소스 코드에서 번역 할 텍스트 표시

좋아, 이제 나쁜 소식이 온다. 응용 프로그램을 여러 언어로 제공 할 때 일반적인 작업 과정은 소스 코드에서 번역이 필요한 모든 텍스트를 표시하는 것입니다. 텍스트가 표시된 후 Flask-Babel은 모든 파일을 스캔하고 [gettext](https://www.gnu.org/software/gettext/) 도구를 사용하여 해당 텍스트를 별도의 번역 파일로 추출합니다 . 불행히도 이것은 번역을 가능하게하기 위해 수행해야하는 지루한 작업입니다.

여기에이 표시의 몇 가지 예를 보여 드리겠습니다. 그러나이 장의 [다운로드 패키지](https://github.com/miguelgrinberg/microblog/tree/v0.13) 또는 GitHub 리포지토리 에서 전체 변경 사항을 얻을 수 있습니다 .

텍스트가 번역 용으로 표시되는 방식은 규칙이 호출 `_()`되는 밑줄 만있는 함수 호출로 텍스트를 래핑하는 것입니다 . 가장 간단한 경우는 리터럴 문자열이 소스 코드에 나타나는 경우입니다. 예제 `flash()`문장 은 다음과 같습니다 .

```
from flask_babel import _
# ...
flash(_('Your post is now live!'))
```

아이디어는 `_()`함수가 텍스트를 기본 언어 (이 경우 영어)로 줄 바꿈 한다는 것입니다 . 이 기능은 `localeselector`주어진 클라이언트에 대한 올바른 번역을 찾기 위해 기능으로 장식 된 기능에 의해 선택된 최상의 언어를 사용합니다 . `_()`그런 다음 이 함수는 번역 된 텍스트를 반환합니다.이 경우이 인수는의 인수가됩니다 `flash()`.

불행히도 모든 경우가 그렇게 간단한 것은 아닙니다. `flash()`응용 프로그램의 다른 호출을 고려하십시오 .

```
flash('User {} not found.'.format(username))
```

이 텍스트에는 정적 텍스트의 중간에 삽입 된 동적 구성 요소가 있습니다. `_()`기능은 텍스트의 유형을 지원하는 문법을 가지고 있지만 기존의 문자열 대체 구문을 기반으로합니다 :

```
flash(_('User %(username)s not found.', username=username))
```

다루기가 더 어려운 경우가 있습니다. 일부 문자열 리터럴은 일반적으로 응용 프로그램을 시작할 때 요청 외부에 할당되므로 이러한 텍스트를 평가할 때 사용할 언어를 알 수있는 방법이 없습니다. 이에 대한 예로 양식 필드와 관련된 레이블이 있습니다. 이러한 텍스트를 처리하는 유일한 솔루션은 실제 요청에 따라 사용될 때까지 문자열 평가를 지연시키는 방법을 찾는 것입니다. 플라스크 - 바벨은 제공 *게으른 평가* 버전 `_()`즉라고 `lazy_gettext()`:

```
from flask_babel import lazy_gettext as _l

class LoginForm(FlaskForm):
    username = StringField(_l('Username'), validators=[DataRequired()])
    # ...
```

여기서는이 대체 번역 함수를 가져오고 `_l()`원래 이름 과 비슷하게 이름을 바꿉니다 `_()`. 이 새로운 기능은 문자열을 사용할 때 번역이 나중에 수행되도록 트리거하는 특수 객체로 텍스트를 감 쌉니다.

Flask-Login 확장 프로그램은 사용자를 로그인 페이지로 리디렉션 할 때마다 메시지를 깜박입니다. 이 메시지는 영어로 제공되며 확장 프로그램 자체에서 제공됩니다. 이 메시지가 번역되도록하기 위해 기본 메시지를 무시하고 `_l()`지연 처리를위한 함수를 내 래퍼에 제공합니다 .

```
login = LoginManager(app)
login.login_view = 'login'
login.login_message = _l('Please log in to access this page.')
```

## 템플릿에서 번역 할 텍스트 표시

이전 섹션에서는 파이썬 소스 코드에서 번역 가능한 텍스트를 표시하는 방법을 보았지만 템플릿 파일에도 텍스트가 있기 때문에이 과정의 일부일뿐입니다. 이 `_()`기능은 템플릿에서도 사용할 수 있으므로 프로세스가 상당히 유사합니다. 예를 들어 *404.html* 의이 HTML 스 니펫을 고려하십시오 .

```
<h1>File Not Found</h1>
```

번역 가능 버전은 다음과 같습니다.

```
<h1>{{ _('File Not Found') }}</h1>
```

참고로 여기에 텍스트를 배치하는 것이 또한 `_()`상기 `{{ ... }}`요구에 추가 될 상기 강제하는 `_()`대신 템플릿 리터럴 간주되는 평가한다.

동적 구성 요소가있는 더 복잡한 문구의 경우 인수를 사용할 수도 있습니다.

```
<h1>{{ _('Hi, %(username)s!', username=current_user.username) }}</h1>
```

*_post.html* 에는 특히 까다로운 사례가 있습니다 .

```
        {% set user_link %}
            <a href="{{ url_for('user', username=post.author.username) }}">
                {{ post.author.username }}
            </a>
        {% endset %}
        {{ _('%(username)s said %(when)s',
            username=user_link, when=moment(post.timestamp).fromNow()) }}
```

여기서 문제 `username`는 이름뿐만 아니라 사용자의 프로필 페이지를 가리키는 링크가 되기를 원했기 때문에 and template 지시문을 `user_link`사용하여 호출되는 중간 변수를 만든 다음 인수로 전달해야한다는 것입니다. 번역 기능.`set``endset`

위에서 언급했듯이 파이썬 소스 코드의 번역 가능한 모든 텍스트와 템플릿이 표시된 응용 프로그램 버전을 [다운로드](https://github.com/miguelgrinberg/microblog/tree/v0.13) 할 수 있습니다 .

## 번역 할 텍스트 추출

모든 사용하여 응용 프로그램을 가지고 일단 `_()`및 `_l()`장소에서, 당신이 사용할 수있는 `pybabel`A를 압축을 풉니 명령을 *.POT의* 의미 파일, *휴대용 객체 템플릿* . 이것은 번역이 필요한 것으로 표시된 모든 텍스트를 포함하는 텍스트 파일입니다. 이 파일의 목적은 각 언어에 대한 번역 파일을 작성하기위한 템플리트 역할을합니다.

추출 프로세스에는 번역 가능한 텍스트를 위해 어떤 파일을 스캔해야하는지 pybabel에 알려주는 작은 구성 파일이 필요합니다. 아래 에서이 응용 프로그램을 위해 만든 *babel.cfg* 를 볼 수 있습니다 .

*babel.cfg* : PyBabel 구성 파일.

```
[python: app/**.py]
[jinja2: app/templates/**.html]
extensions=jinja2.ext.autoescape,jinja2.ext.with_
```

처음 두 줄은 각각 Python 및 Jinja2 템플릿 파일의 파일 이름 패턴을 정의합니다. 세 번째 줄은 Flask-Babel이 템플릿 파일을 올바르게 구문 분석하는 데 도움이되는 Jinja2 템플릿 엔진에서 제공하는 두 가지 확장을 정의합니다.

모든 텍스트를 *.pot* 파일 로 추출하려면 다음 명령을 사용하십시오.

```
(venv) $ pybabel extract -F babel.cfg -k _l -o messages.pot .
```

`pybabel extract`명령에 지정된 구성 파일을 읽고 `-F`다음, 옵션을 명령에 지정된 디렉토리에서 (현재 디렉토리 또는 구성된 소스를 일치 시작 디렉토리에있는 모든 코드와 템플릿 파일 검색 `.`이 경우 참조). 기본적으로 `pybabel`찾습니다 `_()`텍스트 마커, 그러나 나는 또한 내가로 가져 게으른 버전을 사용하고 `_l()`내가 너무 가진 사람을 찾기 위해 도구를 알려줄 필요가 그래서 `-k _l`. 이 `-o`옵션은 출력 파일의 이름을 제공합니다.

나는 점에 유의해야한다 *messages.pot의* 파일이 프로젝트에 통합 될 필요가있는 파일이 아닙니다. 이 파일은 필요할 때마다 쉽게 위의 명령을 다시 실행하여 쉽게 재생성 할 수있는 파일입니다. 따라서이 파일을 소스 제어에 커밋 할 필요가 없습니다.

## 언어 카탈로그 생성

프로세스의 다음 단계는 기본 언어 (이 경우 영어) 외에 지원 될 각 언어에 대한 번역을 작성하는 것입니다. 나는 스페인어 (언어 코드 `es`) 를 추가하여 시작하겠다고 말 했으므로 이것이 그렇게하는 명령입니다.

```
(venv) $ pybabel init -i messages.pot -d app/translations -l es
creating catalog app/translations/es/LC_MESSAGES/messages.po based on messages.pot
```

이 `pybabel init`명령은 *messages.pot* 파일을 입력으로 가져 와서 `-d`옵션에 지정된 언어 옵션에 지정된 디렉토리에 새 언어 카탈로그를 작성합니다 `-l`. Flask-Babel은 기본적으로 번역 파일이 있어야하기 때문에 *app / translations* 디렉토리 에 모든 번역을 설치하려고합니다 . 이 명령은 이 디렉토리 내에 스페인어 데이터 파일에 대한 *es* 서브 디렉토리 를 작성 합니다. 특히 *app / translations / es / LC_MESSAGES / messages.po* 라는 새 파일 이 있으며 여기에서 번역해야합니다.

다른 언어를 지원하려면 원하는 각 언어 코드로 위의 명령을 반복하여 각 언어가 *messages.po* 파일 과 함께 자체 저장소를 갖도록 하십시오.

`messages.po`각 언어 저장소에서 작성된 이 파일은 언어 변환의 사실상 표준 인 형식, [gettext](http://www.gnu.org/software/gettext/) 유틸리티가 사용하는 형식을 사용 합니다. 다음은 스페인 *메시지* 의 시작부터 몇 줄입니다 *.po* :

```
# Spanish translations for PROJECT.
# Copyright (C) 2017 ORGANIZATION
# This file is distributed under the same license as the PROJECT project.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: PROJECT VERSION\n"
"Report-Msgid-Bugs-To: EMAIL@ADDRESS\n"
"POT-Creation-Date: 2017-09-29 23:23-0700\n"
"PO-Revision-Date: 2017-09-29 23:25-0700\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: es\n"
"Language-Team: es <LL@li.org>\n"
"Plural-Forms: nplurals=2; plural=(n != 1)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.5.1\n"

#: app/email.py:21
msgid "[Microblog] Reset Your Password"
msgstr ""

#: app/forms.py:12 app/forms.py:19 app/forms.py:50
msgid "Username"
msgstr ""

#: app/forms.py:13 app/forms.py:21 app/forms.py:43
msgid "Password"
msgstr ""
```

헤더를 건너 뛰면 다음에 나오는 것이 `_()`및 `_l()`호출 에서 추출 된 문자열 목록임을 알 수 있습니다 . 각 텍스트에 대해 응용 프로그램에서 텍스트의 위치에 대한 참조를 얻습니다. 그런 다음 `msgid`줄에는 기본 언어의 텍스트가 포함되고 `msgstr`그 뒤에 나오는 줄에는 빈 문자열이 포함됩니다. 빈 문자열은 대상 언어로 텍스트 버전을 갖도록 편집해야합니다.

`.po`파일로 작동하는 많은 번역 응용 프로그램이 있습니다. 텍스트 파일을 편하게 편집 할 수 있으면 충분하지만 큰 프로젝트로 작업하는 경우 전문 편집기를 사용하는 것이 좋습니다. 가장 많이 사용되는 번역 응용 프로그램은 모든 주요 운영 체제에서 사용할 수 있는 오픈 소스 [poedit](http://www.poedit.net/) 입니다. vim에 익숙한 경우 [po.vim](https://vim.sourceforge.io/scripts/script.php?script_id=695) 플러그인은 이러한 파일을보다 쉽게 사용할 수있는 몇 가지 키 매핑을 제공합니다.

아래 에 번역을 추가 한 후 스페인어 *messages.po* 의 일부를 볼 수 있습니다 .

```
#: app/email.py:21
msgid "[Microblog] Reset Your Password"
msgstr "[Microblog] Nueva Contraseña"

#: app/forms.py:12 app/forms.py:19 app/forms.py:50
msgid "Username"
msgstr "Nombre de usuario"

#: app/forms.py:13 app/forms.py:21 app/forms.py:43
msgid "Password"
msgstr "Contraseña"
```

[다운로드 패키지](https://github.com/miguelgrinberg/microblog/tree/v0.13) 이 장 대한은 또한이 응용 프로그램에 대한 그 부분에 대해 걱정할 필요가 없습니다 그래서, 장소에 번역 모든이 파일이 포함되어 있습니다.

*messages.po의* 파일 변환에 대한 소스 파일의 일종이다. 번역 된 텍스트를 사용하려면이 파일 을 런타임에 응용 프로그램에서 사용하기에 적합한 형식 으로 *컴파일* 해야합니다 . 응용 프로그램에 대한 모든 번역을 컴파일하려면 `pybabel compile`다음과 같이 명령을 사용할 수 있습니다 .

```
(venv) $ pybabel compile -d app/translations
compiling catalog app/translations/es/LC_MESSAGES/messages.po to
app/translations/es/LC_MESSAGES/messages.mo
```

이 작업은 추가 *messages.mo의* 옆에 파일을 *messages.po* 각 언어 저장소에. *.mo의* 파일은 플라스크 - 바벨이 응용 프로그램에 대한 번역을로드 할 때 사용하는 파일입니다.

스페인어 또는 프로젝트에 추가 한 다른 언어에 대한 *messages.mo* 파일을 작성하면 이 언어를 응용 프로그램에서 사용할 수 있습니다. 응용 프로그램이 스페인어로 어떻게 보이는지 보려면 웹 브라우저에서 언어 구성을 편집하여 스페인어를 기본 언어로 사용할 수 있습니다. Chrome의 경우 설정 페이지의 고급 부분입니다.

![크롬 언어 옵션](.\images\mega-tutorial/ch14-language-options.png)

브라우저 설정을 변경하지 않으려면 다른 대안은 `localeselector`함수가 항상 언어를 반환 하도록하여 언어를 강제 실행하는 것입니다. 스페인어의 경우 다음과 같이하십시오.

*app / __ init__.py* : 가장 적합한 언어를 선택하십시오.

```
@babel.localeselector
def get_locale():
    # return request.accept_languages.best_match(app.config['LANGUAGES'])
    return 'es'
```

스페인어 용으로 구성된 브라우저에서 응용 프로그램을 실행하거나 `localeselector`함수를 반환 `es`하면 응용 프로그램을 사용할 때 모든 텍스트가 스페인어로 표시됩니다.

## 번역 업데이트

번역 작업시 한 가지 일반적인 상황은 번역 파일이 불완전하더라도 번역 파일 사용을 시작할 수 있다는 것입니다. 불완전한 *messages.po* 파일을 컴파일 할 수 있으며 사용 가능한 모든 번역이 사용되며 누락 된 파일은 기본 언어를 사용합니다. 그런 다음 번역 작업을 계속하고 다시 컴파일 하여 진행 하면서 *messages.mo* 파일 을 업데이트 할 수 있습니다.

`_()`랩퍼 를 추가 할 때 일부 텍스트를 놓친 경우 다른 일반적인 시나리오가 발생합니다 . 이 경우 Flask-Babel은 그에 대해 아무것도 모르기 때문에 놓친 텍스트가 영어로 남아 있음을 알 수 있습니다. 이 상황에서는 텍스트가없는 텍스트를 감지 할 때 `_()`또는 `_l()`래퍼 를 추가 한 다음 업데이트 절차를 수행해야합니다. 여기에는 두 단계가 포함됩니다.

```
(venv) $ pybabel extract -F babel.cfg -k _l -o messages.pot .
(venv) $ pybabel update -i messages.pot -d app/translations
```

`extract`명령은 앞서 발행 한 동일하지만 지금은 새로운 버전이 생성됩니다 *messages.pot* 최근에 싸여 있다는 새로운 이전의 모든 텍스트 플러스 아무것도를 `_()`하거나 `_l()`. `update`호출은 새 걸리는 `messages.pot`파일을 모든으로 병합 *messages.po의* 프로젝트와 관련된 파일을 저장합니다. 이는 현존하는 텍스트는 그대로 남겨두고 *messages.pot* 에서 추가 또는 제거 된 항목 만 영향을 주는 지능적인 병합이 될 것입니다.

*messages.po* 가 업데이트 된 후에 는 계속해서 새로운 테스트를 번역 한 다음 메시지를 한 번 더 컴파일하여 응용 프로그램에서 사용할 수있게합니다.

## 날짜와 시간 번역

이제 파이썬 코드 및 템플릿의 모든 텍스트에 대한 완벽한 스페인어 번역이 있지만, 스페인어로 응용 프로그램을 실행하고 좋은 관찰자 인 경우 영어로 나타나는 몇 가지 사항이 여전히 있음을 알 수 있습니다. Flask-Moment와 moment.js에 의해 생성 된 타임 스탬프를 언급하고 있는데,이 패키지들에 의해 생성 된 텍스트가 애플리케이션의 소스 코드 나 템플릿의 일부가 아니기 때문에 번역 작업에 포함되지 않은 것 같습니다.

moment.js 라이브러리는 현지화 및 국제화를 지원하므로 올바른 언어를 구성하기 만하면됩니다. Flask-Babel은 `get_locale()`함수 를 통해 주어진 요청에 대해 선택된 언어와 로케일을 반환 하므로 내가 할 일은 `g`객체에 로케일을 추가 하여 기본 템플릿에서 액세스 할 수 있습니다.

*app / routes.py* : 선택된 언어를 flask.g에 저장합니다.

```
# ...
from flask import g
from flask_babel import get_locale

# ...

@app.before_request
def before_request():
    # ...
    g.locale = str(get_locale())
```

`get_locale()`플라스크 - 바벨에서 함수는 로케일 객체를 반환하지만 난 그냥 객체를 문자열로 변환하여 얻을 수있는 언어 코드를 갖고 싶어. 이제 `g.locale`기본 템플릿에서 액세스하여 올바른 언어로 moment.js를 구성 할 수 있습니다.

*app / templates / base.html* : moment.js의 로케일을 설정하십시오.

```
...
{% block scripts %}
    {{ super() }}
    {{ moment.include_moment() }}
    {{ moment.lang(g.locale) }}
{% endblock %}
```

이제 모든 날짜와 시간이 텍스트와 동일한 언어로 표시되어야합니다. 아래에서 응용 프로그램이 스페인어로 어떻게 보이는지 확인할 수 있습니다.

![Español의 마이크로 블로그](.\images\mega-tutorial/ch14-spanish.png)

이 시점에서 블로그 게시물 또는 프로필 설명에서 사용자가 제공 한 텍스트를 제외한 모든 텍스트는 다른 언어로 번역 가능해야합니다.

## 명령 줄 향상

`pybabel`명령이 약간 길고 기억하기 어렵다는 것에 동의 할 것입니다 . 이 기회를 사용하여 `flask`명령 과 통합 된 사용자 정의 명령을 작성하는 방법을 보여 드리겠습니다 . 지금까지 당신은 내가 사용하는 본 적이 `flask run`, `flask shell`그리고 여러 `flask db`하위 명령은 플라스크 - 마이그레이션 확장에 의해 제공. 실제로 응용 프로그램 별 명령을 쉽게 추가 할 수 있습니다 `flask`. 이제 제가 `pybabel`하려는 것은이 응용 프로그램과 관련된 모든 인수로 명령을 트리거하는 몇 가지 간단한 명령을 만드는 것 입니다. 추가 할 명령은 다음과 같습니다.

- `flask translate init LANG` 새로운 언어를 추가
- `flask translate update` 모든 언어 리포지토리를 업데이트
- `flask translate compile` 모든 언어 리포지토리를 컴파일

`babel extract`발생하기 때문에 단계는 명령 될 수 없습니다 *messages.pot의* 파일 것은 항상 중 하나를 실행하기위한 전제 조건이다 `init`또는 `update`이러한 명령의 구현은 임시 파일로 변환 템플릿 파일을 생성 할 수 있도록, 명령을.

Flask 는 모든 명령 줄 작업 에 [Click](http://click.pocoo.org/5/) 을 사용합니다. 데코레이터 `translate`를 통해 여러 하위 명령의 루트 인과 같은 명령이 생성됩니다 `app.cli.group()`. 이 명령을 *app / cli.py* 라는 새 모듈에 *넣겠습니다* .

*app / cli.py* : 명령 그룹을 번역하십시오.

```
from app import app

@app.cli.group()
def translate():
    """Translation and localization commands."""
    pass
```

명령 이름은 데코 레이팅 된 함수의 이름에서오고 도움말 메시지는 docstring에서옵니다. 이것은 하위 명령의 기본을 제공하기 위해서만 존재하는 상위 명령이므로 기능 자체는 아무것도 할 필요가 없습니다.

`update`과 `compile`그들이 어떤 인수를 사용하지 않기 때문에, 쉽게 구현할 수 있습니다 :

*app / cli.py* : 하위 명령을 업데이트하고 컴파일합니다.

```
import os

# ...

@translate.command()
def update():
    """Update all languages."""
    if os.system('pybabel extract -F babel.cfg -k _l -o messages.pot .'):
        raise RuntimeError('extract command failed')
    if os.system('pybabel update -i messages.pot -d app/translations'):
        raise RuntimeError('update command failed')
    os.remove('messages.pot')

@translate.command()
def compile():
    """Compile all languages."""
    if os.system('pybabel compile -d app/translations'):
        raise RuntimeError('compile command failed')
```

이 함수의 데코레이터가 `translate`부모 함수 에서 파생 된 방법에 유의하십시오 . `translate()`함수 이므로 혼동스러워 보일 수 있지만 Click이 명령 그룹을 작성하는 표준 방법입니다. `translate()`함수 와 마찬가지로 이러한 함수에 대한 docstring은 `--help`출력 에서 도움말 메시지로 사용됩니다 .

모든 명령에 대해 명령을 실행하고 반환 값이 0인지 확인하면 명령이 오류를 반환하지 않았 음을 나타냅니다. 명령 오류가 발생하면를 올리면 `RuntimeError`스크립트가 중지됩니다. 이 `update()`함수는 동일한 명령에서 `extract`및 `update`단계를 결합하고 모든 것이 성공 하면 업데이트가 완료된 후 *messages.pot* 파일을 삭제합니다. 이 파일은 필요할 때 쉽게 다시 생성 할 수 있기 때문입니다.

`init`명령은 인수로 새로운 언어 코드를합니다. 구현은 다음과 같습니다.

*app / cli.py* : 초기화 하위 명령.

```
import click

@translate.command()
@click.argument('lang')
def init(lang):
    """Initialize a new language."""
    if os.system('pybabel extract -F babel.cfg -k _l -o messages.pot .'):
        raise RuntimeError('extract command failed')
    if os.system(
            'pybabel init -i messages.pot -d app/translations -l ' + lang):
        raise RuntimeError('init command failed')
    os.remove('messages.pot')
```

이 명령은 `@click.argument`데코레이터를 사용하여 언어 코드를 정의합니다. Click은 명령에 제공된 값을 인수로 핸들러 함수에 전달한 다음 인수를 `init`명령에 통합합니다 .

이 명령이 작동하게하는 마지막 단계는 명령이 등록되도록 명령을 가져 오는 것입니다. 최상위 디렉토리 의 *microblog.py* 파일 에서이 작업을 수행하기로 결정했습니다 .

*microblog.py* : 명령 줄 명령을 등록합니다.

```
from app import cli
```

여기서 내가해야 할 유일한 것은 새로운 *cli.py* 모듈을 가져 오는 것입니다. 가져 오기로 인해 명령 데코레이터가 명령을 실행하고 등록하기 때문에 아무것도 할 필요가 없습니다.

이 시점에서 running `flask --help`은 `translate`명령을 옵션으로 나열합니다 . 그리고 `flask translate --help`내가 정의한 세 가지 하위 명령을 보여줍니다.

```
(venv) $ flask translate --help
Usage: flask translate [OPTIONS] COMMAND [ARGS]...

  Translation and localization commands.

Options:
  --help  Show this message and exit.

Commands:
  compile  Compile all languages.
  init     Initialize a new language.
  update   Update all languages.
```

이제 워크 플로우가 훨씬 간단 해졌으며 길고 복잡한 명령을 기억할 필요가 없습니다. 새로운 언어를 추가하려면 다음을 사용하십시오.

```
(venv) $ flask translate init <language-code>
```

`_()`및 `_l()`언어 표시기를 변경 한 후 모든 언어를 업데이트하려면

```
(venv) $ flask translate update
```

번역 파일을 업데이트 한 후 모든 언어를 컴파일하려면 :

```
(venv) $ flask translate compile
```



## [Part XIV: Ajax](https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-xiv-ajax)

Flask Mega-Tutorial 시리즈의 14 번째 버전으로, Microsoft 번역 서비스와 약간의 JavaScript를 사용하여 라이브 언어 번역 기능을 추가 할 예정입니다.

이 기사에서는 서버 측 개발의 '안전 영역'에서 벗어나 서버와 클라이언트 측 구성 요소가 동일한 기능을 수행 할 것입니다. 일부 사이트가 사용자 생성 콘텐츠 옆에 표시하는 '번역'링크를 보셨습니까? 링크는 사용자의 모국어가 아닌 컨텐츠의 실시간 자동 번역을 트리거하는 링크입니다. 번역 된 내용은 일반적으로 원본 버전 아래에 삽입됩니다. Google은 외국어로 검색 결과를 표시합니다. 페이스 북은 게시물을 위해 그것을합니다. 트위터는 트윗을 위해 그것을한다. 오늘은 마이크로 블로그에 동일한 기능을 추가하는 방법을 보여 드리겠습니다!

이 장의 GitHub 링크는 *[Browse](https://github.com/miguelgrinberg/microblog/tree/v0.14), [Zip](https://github.com/miguelgrinberg/microblog/archive/v0.14.zip), [Diff](https://github.com/miguelgrinberg/microblog/compare/v0.13...v0.14).*입니다.

## 서버 측과 클라이언트 측

지금까지 살펴본 전통적인 서버 측 모델에는 애플리케이션 서버에 HTTP 요청을하는 클라이언트 (사용자가 명령 한 웹 브라우저)가 있습니다. 요청은 "프로필"링크를 클릭 할 때와 같이 단순히 HTML 페이지를 요청하거나 프로필 정보를 편집 한 후 제출 버튼을 클릭 할 때와 같은 동작을 트리거 할 수 있습니다. 두 가지 유형의 요청에서 서버는 직접 또는 리디렉션을 실행하여 클라이언트에 새 웹 페이지를 보내 요청을 완료합니다. 그런 다음 클라이언트는 현재 페이지를 새 페이지로 바꿉니다. 이주기는 사용자가 응용 프로그램의 웹 사이트에 머무르는 동안 반복됩니다. 이 모델에서 서버는 모든 작업을 수행하는 반면 클라이언트는 웹 페이지 만 표시하고 사용자 입력을 승인합니다.

클라이언트가보다 적극적인 역할을 수행하는 다른 모델이 있습니다. 이 모델에서 클라이언트는 서버에 요청을 발행하고 서버는 웹 페이지로 응답하지만 이전의 경우와 달리 모든 페이지 데이터가 HTML 인 것은 아니며 일반적으로 Javascript로 작성된 코드가있는 페이지 섹션도 있습니다. 클라이언트가 페이지를 받으면 HTML 부분을 표시하고 코드를 실행합니다. 그때부터 서버와의 접촉이 거의 없거나 전혀없이 자체적으로 작업 할 수있는 활성 클라이언트가 있습니다. 엄격한 클라이언트 측 응용 프로그램에서 전체 응용 프로그램은 초기 페이지 요청으로 클라이언트에 다운로드 된 다음 응용 프로그램이 완전히 클라이언트에서 실행되므로 서버에 연결하여 데이터를 검색하거나 저장하고 첫 번째 모양을 동적으로 변경합니다. 그리고 웹 페이지 만. 이 유형의 응용 프로그램을[단일 페이지 응용 프로그램](http://en.wikipedia.org/wiki/Single-page_application) 또는 SPA.

대부분의 응용 프로그램은 두 모델 간의 하이브리드이며 두 기술을 결합합니다. 내 마이크로 블로그 응용 프로그램은 주로 서버 측 응용 프로그램이지만 오늘은 약간의 클라이언트 측 작업을 추가 할 것입니다. 사용자 게시물의 실시간 번역을 수행하기 위해 클라이언트 브라우저는 서버에 페이지를 새로 고치지 않고 응답 할 *비동기 요청* 을 서버에 보냅니다 . 클라이언트는 번역을 현재 페이지에 동적으로 삽입합니다. 이 기술은 [Ajax](http://en.wikipedia.org/wiki/Ajax_(programming)) 라고하며 비동기 JavaScript 및 XML의 약자입니다 (요즘 XML이 종종 JSON으로 대체 됨에도 불구하고).

## 라이브 번역 워크 플로우

이 응용 프로그램은 Flask-Babel 덕분에 외국어를 제대로 지원하므로 번역기를 찾을 수있는 한 많은 언어를 지원할 수 있습니다. 그러나 물론 하나의 요소가 누락되었습니다. 사용자는 자신의 언어로 블로그 게시물을 작성하려고하므로 사용자가 알 수없는 언어로 작성된 게시물을 보게 될 가능성이 있습니다. 자동 번역의 품질이 항상 좋은 것은 아니지만 대부분의 경우 다른 언어로 된 텍스트가 무엇을 의미하는지에 대한 기본 아이디어를 갖고 있다면 충분합니다.

이것은 Ajax 서비스로 구현하기에 이상적인 기능입니다. 색인 또는 탐색 페이지에 여러 개의 게시물이 표시 될 수 있으며 그 중 일부는 외국어 일 수 있습니다. 기존의 서버 측 기술을 사용하여 번역을 구현하면 번역 요청으로 인해 원본 페이지가 새 페이지로 대체됩니다. 사실 많은 블로그 게시물 중 하나에 대한 번역을 요청하는 것이 전체 페이지 업데이트를 요구하기에 충분한 조치가 아니기 때문에이 기능은 번역 된 텍스트가 원본 텍스트 아래에 동적으로 삽입되고 나머지는 그대로두면 훨씬 더 잘 작동합니다. 페이지를 그대로 유지하십시오.

실시간 자동 번역을 구현하려면 몇 가지 단계가 필요합니다. 먼저 번역 할 텍스트의 소스 언어를 식별 할 수있는 방법이 필요합니다. 또한 다른 언어로 작성된 게시물에 대해서만 "번역"링크를 표시하려고하기 때문에 각 사용자의 선호 언어를 알아야합니다. 번역 링크가 제공되고 사용자가 클릭하면 Ajax 요청을 서버로 보내야하며 서버는 타사 번역 API에 접속합니다. 서버가 번역 된 텍스트로 응답을 보내면 클라이언트 측 자바 스크립트 코드가이 텍스트를 페이지에 동적으로 삽입합니다. 분명히 알 수 있듯이 여기에는 사소한 문제가 몇 가지 있습니다. 나는 이것들을 하나씩 볼 것입니다.

## 언어 식별

첫 번째 문제는 게시물이 작성된 언어를 식별하는 것입니다. 언어를 명확하게 감지하는 것이 항상 가능하지는 않지만 대부분의 경우 자동 감지는 상당히 잘 작동하므로 정확한 과학은 아닙니다. 파이썬에는이라는 좋은 언어 감지 라이브러리가 `guess_language`있습니다. 이 패키지의 원래 버전은 상당히 오래되었고 파이썬 3으로 포팅되지 않았으므로 파이썬 2와 3을 지원하는 파생 버전을 설치하겠습니다.

```
(venv) $ pip install guess_language-spirit
```

계획은 언어를 결정하기 위해 각 블로그 게시물을이 패키지에 제공하는 것입니다. 이 분석을 수행하는 데 다소 시간이 걸리므로 게시물이 페이지에 렌더링 될 때마다이 작업을 반복하고 싶지 않습니다. 내가 할 일은 게시물을 제출 할 때 게시물의 소스 언어를 설정하는 것입니다. 그런 다음 감지 된 언어가 게시물 테이블에 저장됩니다.

첫 번째 단계는 모델에 `language`필드를 추가하는 것 입니다 `Post`.

*app / models.py* : Post 모델에 감지 된 언어를 추가합니다.

```
class Post(db.Model):
    # ...
    language = db.Column(db.String(5))
```

데이터베이스 모델이 변경 될 때마다 데이터베이스 마이그레이션을 실행해야합니다.

```
(venv) $ flask db migrate -m "add language to posts"
INFO  [alembic.runtime.migration] Context impl SQLiteImpl.
INFO  [alembic.runtime.migration] Will assume non-transactional DDL.
INFO  [alembic.autogenerate.compare] Detected added column 'post.language'
  Generating migrations/versions/2b017edaa91f_add_language_to_posts.py ... done
```

그런 다음 데이터베이스에 마이그레이션을 적용해야합니다.

```
(venv) $ flask db upgrade
INFO  [alembic.runtime.migration] Context impl SQLiteImpl.
INFO  [alembic.runtime.migration] Will assume non-transactional DDL.
INFO  [alembic.runtime.migration] Upgrade ae346256b650 -> 2b017edaa91f, add language to posts
```

게시물을 제출할 때 언어를 감지하고 저장할 수 있습니다.

*app / routes.py* : 새 게시물의 언어를 저장합니다.

```
from guess_language import guess_language

@app.route('/', methods=['GET', 'POST'])
@app.route('/index', methods=['GET', 'POST'])
@login_required
def index():
    form = PostForm()
    if form.validate_on_submit():
        language = guess_language(form.post.data)
        if language == 'UNKNOWN' or len(language) > 5:
            language = ''
        post = Post(body=form.post.data, author=current_user,
                    language=language)
        # ...
```

이 변경으로 게시물을 제출할 때마다 `guess_language`언어를 결정하기 위해 함수를 통해 텍스트를 실행합니다 . 언어가 알려지지 않은 상태로 돌아 오거나 예기치 않게 긴 결과를 얻는 경우, 언어를 안전하게 재생하고 빈 문자열을 데이터베이스에 저장합니다. 언어를 빈 문자열로 설정 한 모든 게시물에 알 수없는 언어가 있다고 가정합니다.

## "번역"링크 표시

두 번째 단계는 쉽습니다. 내가 지금 할 것은 현재 사용자에게 활성화 된 언어가 아닌 게시물 옆에 "번역"링크를 추가하는 것입니다.

*app / templates / _post.html* : 게시물에 대한 번역 링크를 추가합니다.

```
                {% if post.language and post.language != g.locale %}
                <br><br>
                <a href="#">{{ _('Translate') }}</a>
                {% endif %}
```

`_post.html`하위 템플릿 에서이 작업을 수행 하므로 블로그 게시물을 표시하는 모든 페이지 에이 기능이 나타납니다. 번역 링크는 언어가 감지 된 게시물에만 표시되며이 언어는 Flask-Babel의 `localeselector`데코레이터로 장식 된 함수로 선택한 언어와 일치하지 않습니다 . 선택한 로케일이로 저장되어 있다는 것을 [13 장](https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-xiii-i18n-and-l10n) 에서 기억하십시오 `g.locale`. 링크의 텍스트는 Flask-Babel에 의해 번역 될 수있는 방식으로 추가되어야하므로 `_()`정의 할 때 함수를 사용 했습니다.

아직이 링크와 관련된 작업이 없습니다. 먼저 실제 번역을 수행하는 방법을 알고 싶습니다.

## 타사 번역 서비스 사용

두 가지 주요 번역 서비스는 [Google Cloud Translation API](https://developers.google.com/translate/) 및 [Microsoft Translator Text API](https://www.microsoft.com/en-us/translator/business/) 입니다. 둘 다 유료 서비스이지만 Microsoft 오퍼링은 적은 양의 번역을위한 엔트리 레벨 옵션을 무료로 제공합니다. Google은 과거에 무료 번역 서비스를 제공했지만 현재는 가장 낮은 서비스 계층 만 지불합니다. 비용을 들이지 않고 번역을 실험하고 싶기 때문에 Microsoft 솔루션을 구현할 것입니다.

Microsoft Translator API를 사용하려면 Microsoft 클라우드 서비스 인 [Azure](https://azure.com/) 계정을 얻어야합니다 . 프리 티어를 선택할 수 있지만 가입 과정에서 신용 카드 번호를 제공하라는 메시지가 표시되지만 해당 서비스 수준을 유지하는 동안 카드에 요금이 청구되지 않습니다.

Azure 계정이 있으면 Azure Portal로 이동하여 왼쪽 상단의 "새로 만들기"단추를 클릭 한 다음 "번역기 텍스트 API"를 입력하거나 선택하십시오. "만들기"버튼을 클릭하면 계정에 추가 될 새로운 번역기 리소스를 정의하는 양식이 나타납니다. 양식을 어떻게 작성했는지 아래에서 확인할 수 있습니다.

![Azure 번역기](.\images\mega-tutorial/ch15-azure-translator.png)

"만들기"버튼을 다시 클릭하면 번역기 API 리소스가 계정에 추가됩니다. 몇 초를 원하면 상단 표시 줄에 번역기 리소스가 배포되었다는 알림이 표시됩니다. 알림에서 "자원으로 이동"버튼을 클릭 한 다음 왼쪽 사이드 바에서 "키"옵션을 클릭하십시오. 이제 "Key 1"과 "Key 2"라는 두 개의 키가 표시됩니다. (교체, Microsoft Windows를 사용하는 경우 터미널에서 환경 변수에 입력 한 후 클립 보드에 키 중 하나를 복사 `export`하여 `set`) :

```
(venv) $ export MS_TRANSLATOR_KEY=<paste-your-key-here>
```

이 키는 번역 서비스를 인증하는 데 사용되므로 응용 프로그램 구성에 추가해야합니다.

*config.py* : Microsoft Translator API 키를 구성에 추가하십시오.

```
class Config(object):
    # ...
    MS_TRANSLATOR_KEY = os.environ.get('MS_TRANSLATOR_KEY')
```

항상 구성 값과 마찬가지로 환경 변수에 설치하고 플라스크 구성으로 가져 오는 것을 선호합니다. 이는 타사 서비스에 액세스 할 수있는 키 또는 비밀번호와 같은 민감한 정보에서 특히 중요합니다. 분명히 코드에 명시 적으로 작성하고 싶지 않습니다.

Microsoft Translator API는 HTTP 요청을 수락하는 웹 서비스입니다. 파이썬에는 몇 개의 HTTP 클라이언트가 있지만 가장 인기 있고 사용하기 `requests`쉬운 패키지입니다. 가상 환경에 설치해 봅시다 :

```
(venv) $ pip install requests
```

아래에서는 Microsoft Translator API를 사용하여 텍스트를 번역하도록 코딩 한 기능을 볼 수 있습니다. 새로운 *app / translate.py* 모듈을 넣었습니다 :

*app / translate.py* : 텍스트 번역 기능.

```
import json
import requests
from flask_babel import _
from app import app

def translate(text, source_language, dest_language):
    if 'MS_TRANSLATOR_KEY' not in app.config or \
            not app.config['MS_TRANSLATOR_KEY']:
        return _('Error: the translation service is not configured.')
    auth = {'Ocp-Apim-Subscription-Key': app.config['MS_TRANSLATOR_KEY']}
    r = requests.get('https://api.microsofttranslator.com/v2/Ajax.svc'
                     '/Translate?text={}&from={}&to={}'.format(
                         text, source_language, dest_language),
                     headers=auth)
    if r.status_code != 200:
        return _('Error: the translation service failed.')
    return json.loads(r.content.decode('utf-8-sig'))
```

이 함수는 번역 할 텍스트와 소스 및 대상 언어 코드를 인수로 사용하여 번역 된 텍스트가 포함 된 문자열을 반환합니다. 구성에 변환 서비스에 대한 키가 있는지 확인하여 시작하고,없는 경우 오류를 리턴합니다. 오류도 문자열이므로 외부에서 번역 된 텍스트처럼 보입니다. 이를 통해 오류가 발생하면 사용자에게 의미있는 오류 메시지가 표시됩니다.

`get()`로부터 방법 `requests`패키지는 가진 HTTP 요청을 보내는 `GET`첫 번째 인수로 주어진 URL에 방법을. 번역을 JSON 페이로드로 반환하는 번역 서비스의 끝점 인 */v2/Ajax.svc/Translate* URL을 사용하고 있습니다. 텍스트, 소스 및 대상 언어, URL에 쿼리 문자열 인수로 주어진 이름이 될 필요가 `text`, `from`그리고 `to`각각. 서비스로 인증하려면 구성에 추가 한 키를 전달해야합니다. 이 키는 이름이있는 사용자 정의 HTTP 헤더에 제공되어야합니다 `Ocp-Apim-Subscription-Key`. 내가 만든 `auth`이 헤더와 사전을 다음에 전달 `requests`에 `headers`인수.

이 `requests.get()`메소드는 서비스가 제공하는 모든 세부 사항을 포함하는 응답 오브젝트를 리턴합니다. 먼저 상태 코드가 200인지 확인해야합니다. 이는 성공적인 요청을위한 코드입니다. 다른 코드가 있으면 오류가 있음을 알고 있으므로 오류 문자열을 반환합니다. 상태 코드가 200 인 경우 응답 본문에 번역이 포함 된 JSON 인코딩 문자열이 있으므로 `json.loads()`Python 표준 라이브러리 의 함수를 사용 하여 JSON을 사용할 수있는 Python 문자열로 디코딩하기 만하면됩니다. `content`응답 오브젝트 의 속성은 응답의 원시 본문을 바이트 오브젝트로 포함하며 UTF-8 문자열로 변환되어로 전송됩니다 `json.loads()`.

아래에서 새로운 `translate()`기능을 사용하는 Python 콘솔 세션을 볼 수 있습니다 .

```
>>> from app.translate import translate
>>> translate('Hi, how are you today?', 'en', 'es')  # English to Spanish
'Hola, ¿cómo estás hoy?'
>>> translate('Hi, how are you today?', 'en', 'de')  # English to German
'Are Hallo, how you heute?'
>>> translate('Hi, how are you today?', 'en', 'it')  # English to Italian
'Ciao, come stai oggi?'
>>> translate('Hi, how are you today?', 'en', 'fr')  # English to French
"Salut, comment allez-vous aujourd'hui ?"
```

멋지다? 이제이 기능을 응용 프로그램과 통합 할 차례입니다.

## 서버에서 Ajax

서버 측 부분을 구현하여 시작하겠습니다. 사용자가 게시물 아래에 나타나는 번역 링크를 클릭하면 서버에 비동기 HTTP 요청이 발행됩니다. 다음 세션에서이 작업을 수행하는 방법을 보여 드리겠습니다. 지금은 서버에서이 요청을 처리하는 데 집중할 것입니다.

비동기 (또는 Ajax) 요청은 HTML 또는 리디렉션을 반환하는 대신 [XML](http://en.wikipedia.org/wiki/XML) 또는보다 일반적으로 [JSON](http://en.wikipedia.org/wiki/JSON) 형식의 데이터 만 반환한다는 점만 제외하면 응용 프로그램에서 만든 경로 및보기 함수와 유사합니다 . 아래에서 번역보기 기능을 볼 수 있습니다.이 기능은 Microsoft Translator API를 호출 한 다음 번역 된 텍스트를 JSON 형식으로 반환합니다.

*app / routes.py* : 텍스트 번역보기 기능.

```
from flask import jsonify
from app.translate import translate

@app.route('/translate', methods=['POST'])
@login_required
def translate_text():
    return jsonify({'text': translate(request.form['text'],
                                      request.form['source_language'],
                                      request.form['dest_language'])})
```

보다시피, 이것은 간단합니다. 이 경로를 `POST`요청 으로 구현했습니다 . t `GET`또는 언제 `POST`(또는 아직 보지 못한 다른 요청 방법)을 사용 하는지에 대한 절대 규칙 은 없습니다. 클라이언트가 데이터를 보낼 것이기 때문에 `POST`양식 데이터를 제출하는 요청과 비슷한 요청 을 사용하기로 결정했습니다 . 이 `request.form`속성은 플라스크가 제출에 포함 된 모든 데이터로 노출하는 사전입니다. 웹 양식으로 작업 할 때 `request.form`Flask-WTF가 모든 작업을 수행하기 때문에 살펴볼 필요가 없었지만이 경우에는 웹 양식이 없으므로 데이터에 직접 액세스해야합니다.

그래서이 함수에서하고있는 일은 `translate()`이전 섹션에서 함수와 함께 호출 하여 요청과 함께 제출 된 데이터에서 세 개의 인수를 직접 전달하는 것입니다. 결과는 키 아래의 단일 키 사전에 통합되며 `text`사전은 Flask의 `jsonify()`함수에 인수로 전달되어 사전을 JSON 형식의 페이로드로 변환합니다. 의 반환 값 `jsonify()`은 클라이언트로 다시 전송 될 HTTP 응답입니다.

예를 들어, 클라이언트가 문자열 `Hello, World!`을 스페인어 로 변환하려는 경우이 요청의 응답에는 다음 페이로드가 있습니다.

```
{ "text": "Hola, Mundo!" }
```

## 클라이언트의 Ajax

이제 서버가 */ translate* URL을 통해 번역을 제공 할 수있게되었으므로 사용자가 위에서 추가 한 "번역"링크를 클릭하여 번역 할 텍스트와 소스 및 대상 언어를 전달할 때이 URL을 호출해야합니다. 브라우저에서 JavaScript를 사용하는 것에 익숙하지 않다면 이것은 좋은 학습 경험이 될 것입니다.

브라우저에서 JavaScript로 작업 할 때 현재 표시중인 페이지는 내부적으로 문서 오브젝트 모델 또는 DOM으로 표시됩니다. 이것은 페이지에 존재하는 모든 요소를 참조하는 계층 구조입니다. 이 컨텍스트에서 실행되는 JavaScript 코드는 DOM을 변경하여 페이지에서 변경을 트리거 할 수 있습니다.

먼저 브라우저에서 실행되는 JavaScript 코드가 서버에서 실행되는 변환 함수로 보내야하는 세 가지 인수를 얻는 방법에 대해 설명하겠습니다. 텍스트를 얻으려면 블로그 게시물 본문이 포함 된 DOM 내에서 노드를 찾아 내용을 읽어야합니다. 블로그 게시물이 포함 된 DOM 노드를 쉽게 식별 할 수 있도록 고유 한 ID를 첨부하겠습니다. *_post.html* 템플릿 을 보면 포스트 본문을 렌더링하는 행은 다음과 같습니다 `{{ post.body }}`. 내가 할 것은이 내용을 ``요소로 감싸는 것 입니다. 이것은 시각적으로 아무것도 변경하지 않지만 식별자를 삽입 할 수있는 장소를 제공합니다.

*app / templates / _post.html* : 각 블로그 게시물에 ID를 추가하십시오.

```
                <span id="post{{ post.id }}">{{ post.body }}</span>
```

이것은 각 블로그 게시물에 고유 한 식별자를 형식으로 `post1`등 `post2`으로 지정합니다. 여기서 번호는 각 게시물의 데이터베이스 식별자와 일치합니다. 각 블로그 게시물에는 고유 식별자가 있으므로 ID 값이 주어지면 jQuery를 사용 ``하여 해당 게시물 의 요소 를 찾고 텍스트를 추출 할 수 있습니다. 예를 들어 ID가 123 인 게시물의 텍스트를 얻으려면 다음과 같이하십시오.

```
$('#post123').text()
```

여기서 `$`부호는 jQuery 라이브러리가 제공하는 함수의 이름입니다. 이 라이브러리는 Bootstrap에서 사용되므로 Flask-Bootstrap에 이미 포함되어 있습니다. 는 `#`어떤 것이 다음 요소의 ID임을 의미 jQuery를 사용하여 "선택"의 구문의 일부이다.

또한 번역 된 텍스트를 서버에서 받으면 삽입 할 장소를 원할 것입니다. 내가 할 일은 "번역"링크를 번역 된 텍스트로 바꾸는 것이므로 해당 노드의 고유 식별자도 필요합니다.

*app / templates / _post.html* : 번역 링크에 ID를 추가하십시오.

```
                <span id="translation{{ post.id }}">
                    <a href="#">{{ _('Translate') }}</a>
                </span>
```

이제 주어진 게시물 ID `post`에 대해 블로그 게시물에 대한 `translation`노드와 번역 링크가 있으면 번역 링크로 바꾸어야 하는 해당 노드가 있습니다.

다음 단계는 모든 번역 작업을 수행 할 수있는 함수를 작성하는 것입니다. 이 함수는 입력 및 출력 DOM 노드와 소스 및 대상 언어를 가져 와서 필요한 세 개의 인수로 서버에 비동기 요청을 발행 한 다음 서버가 응답하면 번역 링크를 번역 된 텍스트로 바꿉니다. 이것은 많은 작업처럼 들리지만 구현은 매우 간단합니다.

*app / templates / base.html* : 클라이언트 측 번역 기능.

```
{% block scripts %}
    ...
    <script>
        function translate(sourceElem, destElem, sourceLang, destLang) {
            $(destElem).html('<img src="{{ url_for('static', filename='loading.gif') }}">');
            $.post('/translate', {
                text: $(sourceElem).text(),
                source_language: sourceLang,
                dest_language: destLang
            }).done(function(response) {
                $(destElem).text(response['text'])
            }).fail(function() {
                $(destElem).text("{{ _('Error: Could not contact server.') }}");
            });
        }
    </script>
{% endblock %}
```

처음 두 인수는 게시물 및 변환 링크 노드의 고유 ID입니다. 마지막 두 인수는 소스 및 대상 언어 코드입니다.

이 기능은 멋진 터치로 시작 합니다. 번역 링크를 대체 하는 *스피너* 를 추가 하여 사용자가 번역이 진행 중임을 알 수 있습니다. 이는 jQuery를 사용 `$(destElem).html()`하여 변환 링크를 정의한 원래 HTML을 링크를 기반으로하는 새 HTML 컨텐츠로 바꾸는 기능을 사용하여 수행됩니다 ``. 스피너의 경우 Flask가 정적 파일을 위해 예약 한 *app / static / loading.gif* 디렉토리에 추가 한 작은 애니메이션 GIF를 사용 합니다. 이 이미지를 참조하는 URL을 생성하기 위해 `url_for()`함수를 사용 하여 특수 경로 이름을 전달 `static`하고 이미지의 파일 이름을 인수로 제공합니다. 이 장의 [다운로드 패키지](https://github.com/miguelgrinberg/microblog/tree/v0.14) 에서 *loading.gif* 이미지를 찾을 수 있습니다 .

이제 번역 링크를 대신 한 멋진 스피너가 있으므로 사용자는 번역이 나타날 때까지 기다리는 것을 알고 있습니다. 다음 단계는 이전 섹션에서 정의한 */ translate* URL로 `POST`요청 을 보내는 것 입니다. 이를 위해 jQuery,이 경우에는 함수 를 사용하겠습니다 . 이 함수는 브라우저가 웹 양식을 제출하는 방식과 유사한 형식으로 서버에 데이터를 제출합니다. 이는 Flask가이 데이터를 사전에 통합 할 수 있기 때문에 편리합니다 . 인수 는 두 개입니다. 먼저 요청을 보낼 URL과 서버에서 예상하는 세 가지 데이터 항목이 포함 된 사전 (또는 JavaScript에서 호출되는 객체)입니다.`$.post()``request.form``$.post()`

JavaScript는 콜백 함수 나 *promises* 라는 고급 콜백과 함께 많이 작동한다는 것을 알고있을 것입니다 . 내가 지금하고 싶은 것은이 요청이 완료되고 브라우저가 응답을 받으면 원하는 것을 나타냅니다. JavaScript에는 무언가를 기다리는 것과 같은 것이 없으며 모든 것이 *비동기 적* 입니다. 대신 내가해야 할 일은 응답을받을 때 브라우저가 호출하는 콜백 함수를 제공하는 것입니다. 또한 모든 것을 가능한 한 강력하게 만드는 방법으로 오류가 발생한 경우 수행 할 작업을 표시하고 싶습니다. 따라서 오류를 처리하는 두 번째 콜백 함수입니다. 이러한 콜백을 지정하는 몇 가지 방법이 있지만이 경우 약속을 사용하면 코드가 명확 해집니다. 구문은 다음과 같습니다.

```
$.post(<url>, <data>).done(function(response) {
    // success callback
}).fail(function() {
    // error callback
})
```

promise 구문을 사용하면 기본적으로 콜백을 콜의 반환 값에 "연결"할 수 있습니다 `$.post()`. 성공 콜백에서 내가해야 할 일은 `$(destElem).text()`번역 된 텍스트로 호출하는 것 입니다. 번역 된 텍스트는 `text`키 아래 사전에 있습니다. 오류의 경우 동일한 작업을 수행하지만 표시하는 텍스트는 일반 오류 메시지이므로 기본 템플릿에 번역 가능한 텍스트로 입력됩니다.

이제 남은 것은 `translate()`사용자가 번역 링크를 클릭 한 결과 올바른 인수로 함수 를 트리거하는 것입니다. 이 작업을 수행하는 몇 가지 방법도 있습니다. 내가하려는 것은 `href`링크 의 속성에 함수에 대한 호출을 포함시키는 것입니다.

*app / templates / _post.html* : 링크 핸들러를 번역하십시오.

```
                <span id="translation{{ post.id }}">
                    <a href="javascript:translate(
                                '#post{{ post.id }}',
                                '#translation{{ post.id }}',
                                '{{ post.language }}',
                                '{{ g.locale }}');">{{ _('Translate') }}</a>
                </span>
```

`href`가로 시작되는 경우 링크의 요소는 자바 스크립트 코드를 받아 들일 수 `javascript:`즉 변환 함수에 전화를 걸 수있는 편리한 방법입니다 그래서. 이 링크는 클라이언트가 페이지를 요청할 때 서버에서 렌더링되므로 `{{ }}`표현식을 사용 하여 함수에 대한 4 개의 인수를 생성 할 수 있습니다 . 각 게시물에는 고유하게 생성 된 인수와 함께 자체 번역 링크가 있습니다. `#`당신이 접두사로 표시되는지 `post`및 `translation`요소는 무엇 다음 것은 요소 ID 있음을 나타냅니다.

이제 라이브 번역 기능이 완성되었습니다! 사용자 환경에서 유효한 Microsoft Translator API 키를 설정 한 경우 이제 번역을 트리거 할 수 있습니다. 브라우저가 영어를 선호하도록 설정되어 있다고 가정하면 "번역"링크를 보려면 다른 언어로 게시물을 작성해야합니다. 아래에서 예를 볼 수 있습니다.

![번역](.\images\mega-tutorial/ch15-translate.png)

이 장에서는 응용 프로그램에서 지원하는 모든 언어로 번역해야하는 몇 가지 새로운 텍스트를 소개 했으므로 번역 카탈로그를 업데이트해야합니다.

```
(venv) $ flask translate update
```

자체 프로젝트의 경우 각 언어 저장소에서 *messages.po* 파일 을 편집하여 이러한 새 테스트에 대한 번역을 포함시켜야하지만이 장의 다운로드 패키지 또는 GitHub 저장소에서 스페인어 번역을 이미 작성했습니다.

새 번역을 게시하려면 다음을 컴파일해야합니다.

```
(venv) $ flask translate compile
```



## [Part XV: A Better Application Structure](https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-xv-a-better-application-structure)

Flask Mega-Tutorial 시리즈의 15 번째 작품으로, 대규모 응용 프로그램에 적합한 스타일을 사용하여 응용 프로그램을 재구성 할 것입니다.

마이크로 블로그는 이미 적절한 크기의 응용 프로그램이므로 Flask 응용 프로그램이 복잡하거나 관리하기 어려워지지 않고 어떻게 성장할 수 있는지 논의 할 수있는 좋은 기회라고 생각했습니다. Flask는 원하는 방식으로 프로젝트를 구성 할 수있는 옵션을 제공하도록 설계된 프레임 워크이며,이 철학의 일부로 응용 프로그램의 구조가 커지거나 변경 될 때 응용 프로그램의 구조를 변경하거나 조정할 수 있습니다. 필요 또는 경험 수준의 변화.

이 장에서는 대규모 응용 프로그램에 적용되는 몇 가지 패턴에 대해 설명하고이를 보여주기 위해 코드를보다 유지 관리 가능하고 체계적으로 만들기 위해 Microblog 프로젝트의 구성 방식을 일부 변경하려고합니다. . 물론, 진정한 플라스크 정신으로, 나는 당신이 당신의 자신의 프로젝트를 조직하는 방법을 결정할 때 권장 사항으로 이러한 변화를 취하는 것이 좋습니다.

이 장의 GitHub 링크는 *[Browse](https://github.com/miguelgrinberg/microblog/tree/v0.15), [Zip](https://github.com/miguelgrinberg/microblog/archive/v0.15.zip), [Diff](https://github.com/miguelgrinberg/microblog/compare/v0.14...v0.15).* 입니다.



## 현재의 제한점

현재 상태의 응용 프로그램에는 두 가지 기본 문제가 있습니다. 응용 프로그램이 어떻게 구성되어 있는지 살펴보면 식별 할 수있는 몇 가지 다른 하위 시스템이 있지만이를 지원하는 코드가 명확한 경계없이 모두 혼합되어 있음을 알 수 있습니다. 해당 서브 시스템이 무엇인지 검토하십시오.

- *app / routes.py의* 일부보기 기능 , *app / forms.py의* 일부 양식, *app / templates* 의 일부 *템플리트* 및 *app / email.py* 의 이메일 지원 이 포함 된 사용자 인증 서브 시스템 .
- 에 오류 핸들러를 정의하는 오류 서브 시스템 */ errors.py 응용 프로그램* 및 템플릿 *응용 프로그램 / 템플릿* .
- 핵심 게시물 기능은 블로그 게시물, 사용자 프로필 및 팔로 잉 표시 및 쓰기, 블로그 게시물의 실시간 번역을 포함하며 대부분의 응용 프로그램 모듈 및 템플릿을 통해 배포됩니다.

내가 확인한이 세 가지 하위 시스템과 그 구성 방식을 생각하면 패턴을 알 수 있습니다. 지금까지 내가 따르는 조직 논리는 다른 응용 프로그램 기능 전용 모듈을 기반으로합니다. 보기 기능 용 모듈, 웹 양식 용, 오류 용, 전자 메일 용, HTML 템플릿 용 디렉토리 등의 모듈이 있습니다. 이것은 소규모 프로젝트에 적합한 구조이지만 프로젝트가 성장하기 시작하면 이러한 모듈 중 일부를 실제로 크고 복잡하게 만드는 경향이 있습니다.

문제를 명확하게 파악하는 한 가지 방법은이 프로젝트에서 최대한 많이 재사용하여 두 번째 프로젝트를 시작하는 방법을 고려하는 것입니다. 예를 들어, 사용자 인증 부분은 다른 응용 프로그램에서 잘 작동하지만 해당 코드를 그대로 사용하려면 여러 모듈로 이동하여 관련 섹션을 새 프로젝트의 새 파일로 복사 / 붙여 넣기해야합니다. 그것이 얼마나 불편한지 봅니까? 이 프로젝트에 모든 인증 관련 파일이 나머지 응용 프로그램과 분리되어 있으면 더 좋지 않습니까? Flask 의 *청사진* 기능은 코드를보다 쉽게 재사용 할 수있는보다 실용적인 조직을 달성하는 데 도움이됩니다.

분명하지 않은 두 번째 문제가 있습니다. Flask 응용 프로그램 인스턴스는 *app / __ init__.py* 에 전역 변수로 생성 된 다음 많은 응용 프로그램 모듈에서 가져 *옵니다* . 이것은 그 자체로는 문제가되지 않지만 응용 프로그램을 전역 변수로 사용하면 특정 시나리오, 특히 테스트와 관련된 시나리오가 복잡해질 수 있습니다. 이 구성을 다른 구성으로 테스트하려고한다고 가정하십시오. 응용 프로그램은 전역 변수로 정의되므로 다른 구성 변수를 사용하는 두 응용 프로그램을 인스턴스화 할 수있는 방법이 없습니다. 이상적이지 않은 또 다른 상황은 모든 테스트가 동일한 애플리케이션을 사용하므로 테스트가 나중에 실행되는 다른 테스트에 영향을주는 애플리케이션을 변경할 수 있다는 것입니다. 이상적으로는 모든 테스트가 깨끗한 응용 프로그램 인스턴스에서 실행되기를 원합니다.

실제로 *tests.py* 모듈에서 응용 프로그램에서 설정 후 구성을 수정하는 트릭을 사용하여 디스크를 기반으로하는 기본 SQLite 데이터베이스 대신 메모리 내 데이터베이스를 사용하도록 테스트를 수행하고 있음을 알 수 있습니다. 테스트가 시작될 때 응용 프로그램이 만들어지고 구성 되었기 때문에 구성된 데이터베이스를 변경할 다른 방법이 없습니다. 이 특정 상황에서 응용 프로그램에 적용된 후 구성을 변경하면 제대로 작동하는 것처럼 보이지만 다른 경우에는 구성이 좋지 않을 수 있으며, 어쨌든 모호하고 버그를 찾기 어려울 수 있습니다.

더 나은 솔루션은 애플리케이션에 글로벌 변수를 사용하지 않고 대신 *애플리케이션 팩토리* 함수를 사용하여 런타임에 함수를 작성하는 것입니다. 이것은 구성 객체를 인수로 받아들이고 해당 설정으로 구성된 Flask 응용 프로그램 인스턴스를 반환하는 함수입니다. 응용 프로그램 팩토리 기능과 함께 작동하도록 응용 프로그램을 수정할 수 있으면 각 테스트마다 자체 응용 프로그램을 만들 수 있기 때문에 특별한 구성이 필요한 테스트를 작성하는 것이 쉬워집니다.

이 장에서는 위에서 식별 한 세 개의 하위 시스템에 대한 청사진과 응용 프로그램 팩토리 기능을 소개하기 위해 응용 프로그램을 리팩터링합니다. 응용 프로그램의 일부인 거의 모든 파일에는 거의 변경 사항이 없으므로 리팩토링을 수행하기 위해 수행 한 단계에 대해 논의 할 것이므로 변경 사항에 대한 자세한 목록을 표시하는 것은 실용적이지 않습니다. 그런 다음 이러한 변경 사항으로 응용 프로그램 을 [다운로드](https://github.com/miguelgrinberg/microblog/archive/v0.15.zip) 하십시오.

## 청사진

Flask에서 블루 프린트는 애플리케이션의 서브 세트를 나타내는 논리적 구조입니다. 블루 프린트에는 경로,보기 기능, 양식, 템플릿 및 정적 파일과 같은 요소가 포함될 수 있습니다. 청사진을 별도의 Python 패키지로 작성하면 애플리케이션의 특정 기능과 관련된 요소를 캡슐화하는 구성 요소가 있습니다.

청사진의 내용은 초기에 휴면 상태입니다. 이러한 요소를 연관 시키려면 블루 프린트를 애플리케이션에 등록해야합니다. 등록하는 동안 블루 프린트에 추가 된 모든 요소가 애플리케이션으로 전달됩니다. 따라서 청사진을 코드 구성에 도움이되는 응용 프로그램 기능을위한 임시 저장소로 생각할 수 있습니다.

### 오류 처리 청사진

내가 만든 첫 번째 청사진은 오류 처리기 지원을 캡슐화 한 것입니다. 이 청사진의 구조는 다음과 같습니다.

```
app/
    errors/                             <-- blueprint package
        __init__.py                     <-- blueprint creation
        handlers.py                     <-- error handlers
    templates/
        errors/                         <-- error templates
            404.html
            500.html
    __init__.py                         <-- blueprint registration
```

본질적으로, 내가 한 것은 *app / errors.py* 모듈을 *app / errors / handlers.py* 로 옮기고 두 오류 템플릿을 *app / templates / errors* 로 옮기면 다른 템플릿과 분리됩니다. 또한 `render_template()`새 *오류* 템플리트 서브 디렉토리 를 사용하도록 두 오류 핸들러 모두 에서 호출 을 변경해야했습니다 . 그 후 애플리케이션 인스턴스가 작성된 후 청사진 작성을 *app / errors / __ init__.py* 모듈에 추가하고 청사진 등록을 *app / __ init__.py* 에 추가했습니다.

Flask 블루 프린트는 템플릿 또는 정적 파일을위한 별도의 디렉토리를 갖도록 구성 할 수 있습니다. 템플릿을 응용 프로그램 템플릿 디렉토리의 하위 디렉토리로 이동하여 모든 템플릿이 단일 계층 구조에 있도록하기로 결정했습니다. 그러나 블루 프린트 패키지 내에 블루 프린트에 속하는 템플리트가있는 경우 지원됩니다. 예를 들어 생성자에 `template_folder='templates'`인수를 추가 `Blueprint()`하면 청사진 템플릿을 *app / errors / templates* 에 저장할 수 있습니다 .

블루 프린트 작성은 응용 프로그램 작성과 상당히 유사합니다. 블루 프린트 패키지의 ___init__.py 모듈에서 수행됩니다.

*app / errors / __ init__.py* : 오류 청사진.

```
from flask import Blueprint

bp = Blueprint('errors', __name__)

from app.errors import handlers
```

`Blueprint`클래스는 청사진의 이름을 사용, 기본 모듈의 이름 (일반적으로 설정 `__name__`플라스크 어플리케이션 인스턴스에서 같은),이 경우에 내가 필요하지 않은 몇 가지 선택적 인수. 블루 프린트 객체가 생성 된 후, *handlers.py* 모듈을 가져 와서 에러 핸들러가 블루 프린트에 등록되도록합니다. 이 가져 오기는 순환 종속성을 피하기 위해 맨 아래에 있습니다.

에서 *handlers.py* 대신하여 응용 프로그램에 오류 처리기를 부착 모듈, `@app.errorhandler`장식, 나는 청사진의 사용 `@bp.app_errorhandler`장식합니다. 두 데코레이터는 동일한 최종 결과를 달성하지만, 더 이식성이 좋도록 블루 프린트를 애플리케이션과 독립적으로 만들려고합니다. 또한 새 *오류* 서브 디렉토리가 이동 된 두 개의 오류 템플리트에 대한 경로를 수정해야합니다 .

오류 핸들러 리팩토링을 완료하는 마지막 단계는 애플리케이션에 블루 프린트를 등록하는 것입니다.

*app / __ init__.py* : 오류 청사진을 애플리케이션에 등록하십시오.

```
app = Flask(__name__)

# ...

from app.errors import bp as errors_bp
app.register_blueprint(errors_bp)

# ...

from app import routes, models  # <-- remove errors from this import!
```

블루 프린트를 등록하기 `register_blueprint()`위해 Flask 애플리케이션 인스턴스 의 메소드가 사용됩니다. 블루 프린트가 등록되면 모든 뷰 함수, 템플릿, 정적 파일, 오류 처리기 등이 애플리케이션에 연결됩니다. `app.register_blueprint()`순환 종속성을 피하기 위해 청사진 가져 오기를 바로 위에 배치했습니다 .

### 인증 청사진

애플리케이션의 인증 기능을 블루 프린트로 리팩터링하는 프로세스는 오류 핸들러의 프로세스와 매우 유사합니다. 리팩토링 된 청사진의 다이어그램은 다음과 같습니다.

```
app/
    auth/                               <-- blueprint package
        __init__.py                     <-- blueprint creation
        email.py                        <-- authentication emails
        forms.py                        <-- authentication forms
        routes.py                       <-- authentication routes
    templates/
        auth/                           <-- blueprint templates
            login.html
            register.html
            reset_password_request.html
            reset_password.html
    __init__.py                         <-- blueprint registration
```

이 청사진을 만들려면 모든 인증 관련 기능을 청사진에서 만든 새 모듈로 옮겨야했습니다. 여기에는 몇 가지보기 기능, 웹 양식 및 암호 재설정 토큰을 전자 메일로 보내는 기능과 같은 지원 기능이 포함됩니다. 또한 오류 페이지에서와 같이 템플릿을 하위 디렉토리로 이동하여 나머지 응용 프로그램과 템플릿을 분리했습니다.

블루 프린트에서 경로를 정의 할 때 `@bp.route`데코레이션이 대신 사용됩니다 `@app.route`. `url_for()`URL을 빌드 하는 데 사용되는 구문도 변경해야 합니다. 응용 프로그램에 직접 연결된 일반 뷰 함수의 경우 첫 번째 인수 `url_for()`는 뷰 함수 이름입니다. 경로가 블루 프린트에 정의 된 경우이 인수는 블루 프린트 이름과보기 함수 이름을 마침표로 구분하여 포함해야합니다. 예를 들어, 나는 모든 발생을 `url_for('login')`로 바꾸어야 `url_for('auth.login')`하고 나머지 뷰 함수는 동일해야했습니다.

`auth`응용 프로그램에 청사진 을 등록 하기 위해 약간 다른 형식을 사용했습니다.

*app / __ init__.py* : 애플리케이션에 인증 청사진을 등록합니다.

```
# ...
from app.auth import bp as auth_bp
app.register_blueprint(auth_bp, url_prefix='/auth')
# ...
```

`register_blueprint()`이 경우 호출이 추가 인수를 가지고 `url_prefix`. 이것은 전적으로 선택 사항이지만 Flask는 URL 접두사 아래에 블루 프린트를 첨부 할 수있는 옵션을 제공하므로 블루 프린트에 정의 된 경로는 URL에서이 접두사를 얻습니다. 많은 경우에 이것은 청사진의 모든 경로를 응용 프로그램의 다른 경로 나 다른 청사진과 분리하여 유지하는 일종의 "네임 스페이스"로 유용합니다. 인증을 위해 */ auth로* 시작하는 모든 경로를 갖는 것이 좋았 으므로 접두사를 추가했습니다. 이제 로그인 URL은 *http : // localhost : 5000 / auth / login* 입니다. `url_for()`URL을 생성하는 데 사용 하고 있기 때문에 모든 URL에 자동으로 접두사가 포함됩니다.

### 주요 응용 프로그램 청사진

세 번째 청사진에는 핵심 응용 프로그램 논리가 포함되어 있습니다. 이 청사진을 리팩토링하려면 이전 두 청사진에서 사용한 것과 동일한 프로세스가 필요합니다. 이 청사진에 name `main`을 부여 했으므로 `url_for()`뷰 함수를 참조하는 모든 호출에는 `main.`접두사 가 있어야했습니다 . 이것이 응용 프로그램의 핵심 기능이기 때문에 템플릿을 같은 위치에두기로 결정했습니다. 템플릿을 다른 두 청사진에서 하위 디렉토리로 옮겼 기 때문에 문제가되지 않습니다.

## 어플리케이션 팩토리 패턴

이 장의 소개에서 언급했듯이 전역 변수로 응용 프로그램을 사용하면 주로 일부 테스트 시나리오의 제한 형식으로 인해 몇 가지 복잡한 문제가 발생합니다. 블루 프린트를 소개하기 전에 모든 뷰 함수와 오류 처리기는와 `app`같은 데코레이터로 장식해야했기 때문에 응용 프로그램은 전역 변수 여야 했습니다 `@app.route`. 그러나 이제 모든 경로 및 오류 처리기가 청사진으로 이동되었으므로 응용 프로그램을 전역으로 유지해야하는 이유는 훨씬 적습니다.

그래서 내가 할 일은 `create_app()`Flask 응용 프로그램 인스턴스를 생성하는 전역 함수를 제거 하는 함수를 추가하는 것 입니다. 변환은 사소한 것이 아니라 몇 가지 복잡한 문제를 해결해야했지만 먼저 응용 프로그램 팩토리 기능을 살펴 보겠습니다.

*app / __ init__.py* : 어플리케이션 팩토리 기능.

```
# ...
db = SQLAlchemy()
migrate = Migrate()
login = LoginManager()
login.login_view = 'auth.login'
login.login_message = _l('Please log in to access this page.')
mail = Mail()
bootstrap = Bootstrap()
moment = Moment()
babel = Babel()

def create_app(config_class=Config):
    app = Flask(__name__)
    app.config.from_object(config_class)

    db.init_app(app)
    migrate.init_app(app, db)
    login.init_app(app)
    mail.init_app(app)
    bootstrap.init_app(app)
    moment.init_app(app)
    babel.init_app(app)

    # ... no changes to blueprint registration

    if not app.debug and not app.testing:
        # ... no changes to logging setup

    return app
```

대부분의 Flask 확장은 확장의 인스턴스를 만들고 응용 프로그램을 인수로 전달하여 초기화되는 것을 보았습니다. 응용 프로그램이 글로 z 변수로 존재하지 않으면 확장이 두 단계로 초기화되는 대체 모드가 있습니다. 확장 인스턴스는 이전과 같이 전역 범위에서 먼저 생성되지만 인수는 전달되지 않습니다. 응용 프로그램에 연결되지 않은 확장 인스턴스를 만듭니다. 팩토리 함수에서 애플리케이션 인스턴스 `init_app()`를 작성할 때 확장 인스턴스 에서 메소드를 호출하여 현재 알려진 애플리케이션에 바인딩해야합니다.

초기화 중에 수행 된 다른 작업은 동일하게 유지되지만 전역 범위가 아닌 팩토리 기능으로 이동됩니다. 여기에는 블루 프린트 등록 및 로깅 구성이 포함됩니다. `not app.testing`전자 메일 및 파일 로깅을 사용할지 여부를 결정하는 조건을 조건부에 추가하여 단위 테스트 중에이 모든 로깅을 건너 뜁니다. `app.testing`플래그 될 것이다 `True`인해에 단위 테스트 실행시 `TESTING`에 변수 존재 세트 `True`구성된다.

그렇다면 누가 어플리케이션 팩토리 함수를 호출합니까? 이 기능을 사용하기에 가장 적합한 곳은 최상위 *microblog.py* 스크립트입니다.이 스크립트는 현재 응용 프로그램이 전체 범위에 존재하는 유일한 모듈입니다. 다른 곳은 *tests.py* 에 있으며 다음 섹션에서 단위 테스트에 대해 자세히 설명합니다.

위에서 언급했듯이 대부분의 참조 `app`는 청사진의 도입과 함께 사라졌지 만 여전히 해결해야 할 코드가 일부 있습니다. 예를 들어 *app / models.py* , *app / translate.py* 및 *app / main / routes.py* 모듈에는 모두에 대한 참조가있었습니다 `app.config`. 다행스럽게도 Flask 개발자는 지금까지했던 것처럼 뷰 함수가 응용 프로그램 인스턴스를 가져 오지 않고도 쉽게 액세스 할 수 있도록 노력했습니다. `current_app`플라스크가 제공하는 변수는 요청을 전달하기 전에 플라스크는 응용 프로그램 초기화하는 특별한 "컨텍스트"변수입니다. 이미 다른 컨텍스트 변수 `g`, 현재 로케일을 저장하는 변수를 이미 보았습니다 . Flask-Login과 함께이 두 가지`current_user` 그리고 아직 보지 못한 몇 가지 다른 변수는 전역 변수처럼 작동하지만 요청을 처리하는 동안에 만 액세스 할 수 있고 처리하는 스레드에서만 액세스 할 수 있다는 점에서 다소 "매직"변수입니다.

교체 `app`플라스크의와 `current_app`변수 것은 전역 변수로 응용 프로그램 인스턴스를 가져 오는 필요가 없습니다. 나는 모든 참조를 변경 할 수 있었다 `app.config`와 `current_app.config`간단한 검색을 통해 어려움없이 교체합니다.

*응용 프로그램 / email.py* 난 작은 트릭을 사용했다, 그래서 모듈은 약간 더 큰 도전을 선물 :

*app / email.py* : 응용 프로그램 인스턴스를 다른 스레드로 전달합니다.

```
from flask import current_app

def send_async_email(app, msg):
    with app.app_context():
        mail.send(msg)

def send_email(subject, sender, recipients, text_body, html_body):
    msg = Message(subject, sender=sender, recipients=recipients)
    msg.body = text_body
    msg.html = html_body
    Thread(target=send_async_email,
           args=(current_app._get_current_object(), msg)).start()
```

이 `send_email()`함수에서 응용 프로그램 인스턴스는 백그라운드 스레드에 인수로 전달 된 다음 기본 응용 프로그램을 차단하지 않고 전자 메일을 전달합니다. 클라이언트 요청을 처리하는 스레드에 연결된 컨텍스트 인식 변수 이기 때문에 백그라운드 스레드로 실행되는 함수 `current_app`에서 직접 사용 `send_async_email()`하는 것은 효과가 없었습니다 `current_app`. 다른 스레드에서는 `current_app`값이 할당되지 않습니다. 실제로 `current_app`스레드 객체에 인수로 전달하면 `current_app`실제로 작동하지 않습니다. 실제로 는 응용 프로그램 인스턴스에 동적으로 매핑 되는 *프록시 객체* 이기 때문 입니다 . 따라서 프록시 객체를 전달하는 것은 사용하는 것과 같습니다.`current_app`실에서 직접. 내가해야 할 일은 프록시 객체 내에 저장된 실제 응용 프로그램 인스턴스에 액세스하여 `app`인수 로 전달하는 것 입니다. 이 `current_app._get_current_object()`표현식은 프록시 객체 내부에서 실제 애플리케이션 인스턴스를 추출하므로 인수로 스레드에 전달한 것입니다.

까다로운 또 다른 모듈은 *app / cli.py인데* , 언어 번역 관리를위한 몇 가지 바로 가기 명령을 구현합니다. `current_app`이러한 명령하지 않을 경우 유일한 시간 인 요청을 처리하는 동안, 시작에 등록되어 있기 때문에 변수는이 경우에 작동하지 않습니다 `current_app`사용할 수 있습니다. `app`이 모듈에서 참조를 제거하기 위해 인스턴스를 인수로 사용하는 `register()`함수 내에서 이러한 사용자 정의 명령을 이동하는 또 다른 트릭 `app`을 사용했습니다.

*app / cli.py* : 사용자 정의 응용 프로그램 명령을 등록합니다.

```
import os
import click

def register(app):
    @app.cli.group()
    def translate():
        """Translation and localization commands."""
        pass

    @translate.command()
    @click.argument('lang')
    def init(lang):
        """Initialize a new language."""
        # ...

    @translate.command()
    def update():
        """Update all languages."""
        # ...

    @translate.command()
    def compile():
        """Compile all languages."""
        # ...
```

그런 다음 *microblog.py* 에서이 `register()`함수를 호출했습니다 . 모든 리팩토링 후 완전한 *microblog.py* 는 다음과 같습니다 .

*microblog.py* : 메인 애플리케이션 모듈 리팩토링.

```
from app import create_app, db, cli
from app.models import User, Post

app = create_app()
cli.register(app)

@app.shell_context_processor
def make_shell_context():
    return {'db': db, 'User': User, 'Post' :Post}
```

## 단위 테스트 개선

이 장의 시작 부분에서 암시 한 것처럼 지금까지 수행 한 많은 작업은 단위 테스트 워크 플로를 개선하려는 목표를 가지고있었습니다. 단위 테스트를 실행할 때 응용 프로그램이 데이터베이스와 같은 개발 자원을 방해하지 않는 방식으로 구성되어 있는지 확인하려고합니다.

*tests.py* 의 현재 버전은 응용 프로그램 인스턴스에 적용된 후 구성을 수정하는 트릭 에 *의존* 합니다. 이는 늦게 완료되었을 때 모든 유형의 변경이 작동하지는 않으므로 위험한 방법입니다. 내가 원하는 것은 테스트 구성을 응용 프로그램에 추가하기 전에 지정할 수있는 기회를 갖는 것입니다.

`create_app()`기능은 이제 인수로 구성 클래스를 사용할 수 있습니다. 기본적 `Config`으로 *config.py에* 정의 된 클래스 가 사용되지만 이제 새 클래스를 팩토리 함수에 전달하여 다른 구성을 사용하는 응용 프로그램 인스턴스를 만들 수 있습니다. 다음은 단위 테스트에 사용하기에 적합한 구성 클래스의 예입니다.

*tests.py* : 구성 테스트.

```
from config import Config

class TestConfig(Config):
    TESTING = True
    SQLALCHEMY_DATABASE_URI = 'sqlite://'
```

내가하고있는 일은 응용 프로그램 클래스의 하위 클래스를 만들고 `Config`메모리 내 SQLite 데이터베이스를 사용하도록 SQLAlchemy 구성을 재정의하는 것입니다. 또한 현재 필요하지 않은 `TESTING`속성 세트를 추가 `True`했지만 응용 프로그램이 단위 테스트에서 실행 중인지 여부를 결정 해야하는 경우 유용 할 수 있습니다.

기억한다면, 단위 테스트는 단위 테스트 프레임 워크에 의해 자동으로 호출 된 `setUp()`및 `tearDown()`메소드 에 의존하여 각 테스트를 실행하기에 적합한 환경을 만들고 파괴합니다. 이제이 두 가지 방법을 사용하여 각 테스트마다 새로운 응용 프로그램을 만들고 제거 할 수 있습니다.

*tests.py* : 각 테스트에 대한 응용 프로그램을 만듭니다.

```
class UserModelCase(unittest.TestCase):
    def setUp(self):
        self.app = create_app(TestConfig)
        self.app_context = self.app.app_context()
        self.app_context.push()
        db.create_all()

    def tearDown(self):
        db.session.remove()
        db.drop_all()
        self.app_context.pop()
```

새 애플리케이션은에 저장 `self.app`되지만 애플리케이션을 만드는 것만으로는 충분하지 않습니다. `db.create_all()`데이터베이스 테이블을 작성 하는 명령문을 고려하십시오 . `db`예는에서 데이터베이스 URI를 얻을 필요가 있기 때문에, 응용 프로그램 인스턴스가 무엇인지 알 필요가있다 `app.config`,하지만 당신은 당신이 정말로 하나의 응용 프로그램에 국한되지 않습니다 응용 프로그램 공장 작업 할 때, 더 만든 것보다는있을 수 있습니다. 방금 만든 인스턴스 `db`를 사용 하는 방법을 알고 `self.app`있습니까?

대답은 *응용 프로그램 컨텍스트에* 있습니다. `current_app`가져올 전역 응용 프로그램이 없을 때 응용 프로그램의 프록시 역할을하는 변수를 기억 하십니까? 이 변수는 현재 스레드에서 활성 응용 프로그램 컨텍스트를 찾은 다음 찾은 경우 해당 응용 프로그램을 가져옵니다. 컨텍스트가 없으면 어떤 애플리케이션이 활성화되어 있는지 알 수있는 방법이 없으므로 `current_app`예외가 발생합니다. 아래는 파이썬 콘솔에서 어떻게 작동하는지 볼 수 있습니다. 이것은 콘솔이 실행에 의해 시작해야 `python`때문에, `flask shell`명령이 자동으로 편의를 위해 애플리케이션 컨텍스트를 활성화합니다.

```
>>> from flask import current_app
>>> current_app.config['SQLALCHEMY_DATABASE_URI']
Traceback (most recent call last):
    ...
RuntimeError: Working outside of application context.

>>> from app import create_app
>>> app = create_app()
>>> app.app_context().push()
>>> current_app.config['SQLALCHEMY_DATABASE_URI']
'sqlite:////home/miguel/microblog/app.db'
```

이것이 비밀입니다! 보기 기능을 호출하기 전에, 플라스크가 제공하는 응용 프로그램 컨텍스트, 밀어 `current_app`및 `g`생활을. 요청이 완료되면 이러한 변수와 함께 컨텍스트가 제거됩니다. 위해 `db.create_all()`단위 테스트에서 작업을 호출 `setUp()`방법, 난 그냥 만든 응용 프로그램 인스턴스 응용 프로그램 컨텍스트를 밀어, 그 방법으로 `db.create_all()`사용할 수있는 `current_app.config`데이터베이스입니다 알고. 그런 다음 `tearDown()`메소드에서 컨텍스트를 팝하여 모든 것을 깨끗한 상태로 재설정합니다.

또한 응용 프로그램 컨텍스트가 Flask에서 사용하는 두 가지 컨텍스트 중 하나라는 것도 알고 있어야합니다. 또한 *요청에* 적용되는 *요청 컨텍스트* 가 더 구체적입니다. 요청이 처리되기 직전에 요청 컨텍스트가 활성화되면 Flask-Login뿐만 아니라 Flask `request`및 `session`변수를 사용할 수있게됩니다 `current_user`.

## 환경 변수

이 애플리케이션을 빌드 할 때 보았 듯이 서버를 시작하기 전에 환경에 변수를 설정하는 데 의존하는 여러 구성 옵션이 있습니다. 여기에는 비밀 키, 전자 메일 서버 정보, 데이터베이스 URL 및 Microsoft Translator API 키가 포함됩니다. 새 터미널 세션을 열 때마다 해당 변수를 다시 설정해야하므로 불편한 점에 동의 할 것입니다.

많은 환경 변수에 의존하는 응용 프로그램의 일반적인 패턴 은 루트 응용 프로그램 디렉토리 의 *.env* 파일에 저장하는 것입니다 . 응용 프로그램은 시작할 때이 파일의 변수를 가져 오므로 이러한 변수를 모두 수동으로 설정할 필요가 없습니다.

*.env* 파일 을 지원하는 Python 패키지가 `python-dotenv`있습니다. 패키지를 설치해 봅시다 :

```
(venv) $ pip install python-dotenv
```

이후 *config.py* 나는 모든 환경 변수를 읽을 경우 모듈은, 내가 가져 갈거야 *은 .env* 전과 파일을 `Config`, 클래스가 생성되므로 클래스가 구성 될 때 변수가 설정되어 있는지 :

*config.py* : 환경 변수가있는 .env 파일을 가져옵니다.

```
import os
from dotenv import load_dotenv

basedir = os.path.abspath(os.path.dirname(__file__))
load_dotenv(os.path.join(basedir, '.env'))

class Config(object):
    # ...
```

이제 응용 프로그램에 필요한 모든 환경 변수가 포함 된 *.env* 파일을 만들 수 있습니다 . 소스 컨트롤에 *.env* 파일을 추가하지 않는 것이 중요합니다 . 소스 코드 저장소에 비밀번호 및 기타 민감한 정보가 포함 된 파일을 원하지 않습니다.

*은 .env* 파일은 모든 구성 시간 변수에 사용할 수 있지만, 플라스크의 사용할 수 없습니다 `FLASK_APP`및 `FLASK_DEBUG`이 응용 프로그램 인스턴스 및 구성 객체가 존재하기 전에, 초기 응용 프로그램 부트 스트랩 과정에서 필요하기 때문에, 환경 변수.

다음 예는 비밀 키를 정의하고 포트 25에서 로컬로 실행중인 메일 서버로 나가도록 이메일을 구성하며 인증없이 Microsoft Translator API 키를 설정하고 기본값을 사용하도록 데이터베이스 구성을 유지 하는 *.env* 파일을 보여줍니다 .

```
SECRET_KEY=a-really-long-and-unique-key-that-nobody-knows
MAIL_SERVER=localhost
MAIL_PORT=25
MS_TRANSLATOR_KEY=<your-translator-key-here>
```

## 요구 사항 파일

이 시점에서 필자는 Python 가상 환경에 많은 수의 패키지를 설치했습니다. 다른 시스템에서 환경을 재생성해야하는 경우 설치해야 할 패키지를 기억하는 데 어려움이 있으므로 일반적으로 허용되는 방법은 모든 종속성을 나열하는 프로젝트의 루트 폴더에 *requirements.txt* 파일 을 작성하는 것입니다. 버전과 함께. 이 목록을 만드는 것은 실제로 쉽습니다.

```
(venv) $ pip freeze > requirements.txt
```

이 `pip freeze`명령은 가상 환경에 설치된 모든 패키지를 *requirements.txt* 파일 의 올바른 형식으로 덤프 합니다. 이제 패키지를 하나씩 설치하는 대신 다른 머신에서 동일한 가상 환경을 작성해야하는 경우 다음을 실행할 수 있습니다.

```
(venv) $ pip install -r requirements.txt
```





## [Part XVI: Full-Text](https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-xvi-full-text-search)

이것은 Flask Mega-Tutorial 시리즈의 16 번째 버전으로, Microblog에 전체 텍스트 검색 기능을 추가 할 것입니다.

이 장의 목표는 사용자가 자연어를 사용하여 흥미로운 게시물을 찾을 수 있도록 마이크로 블로그에 대한 검색 기능을 구현하는 것입니다. 많은 유형의 웹 사이트의 경우 Google, Bing 등이 모든 콘텐츠를 색인화하고 검색 API를 통해 검색 결과를 제공 할 수 있습니다. 이것은 포럼처럼 정적 페이지가 많은 사이트에 적합합니다. 그러나 내 응용 프로그램에서 기본 콘텐츠 단위는 전체 웹 페이지의 작은 부분 인 사용자 게시물입니다. 원하는 검색 결과 유형은 전체 페이지가 아닌 개별 블로그 게시물에 대한 것입니다. 예를 들어, "dog"이라는 단어를 검색하면 해당 단어를 포함하는 모든 사용자의 블로그 게시물이 표시됩니다. 분명히 "dog"이라는 단어가있는 모든 블로그 게시물을 표시하는 페이지

*이 장의 GitHub 링크는 [Browse](https://github.com/miguelgrinberg/microblog/tree/v0.16) , [Zip](https://github.com/miguelgrinberg/microblog/archive/v0.16.zip) , [Diff](https://github.com/miguelgrinberg/microblog/compare/v0.15...v0.16) 입니다.*

## 전체 텍스트 검색 엔진 소개

전체 텍스트 검색에 대한 지원은 관계형 데이터베이스처럼 표준화되지 않습니다. [Elasticsearch](https://www.elastic.co/products/elasticsearch) , [Apache Solr](http://lucene.apache.org/solr/) , [Whoosh](http://whoosh.readthedocs.io/) , [Xapian](https://xapian.org/) , [Sphinx](http://sphinxsearch.com/) 등과 같은 여러 오픈 소스 전체 텍스트 엔진이 있습니다. 이 방법이 충분하지 않은 것처럼 전용 검색 엔진과 비슷한 검색 기능을 제공하는 여러 데이터베이스가 있습니다. 위에서 열거 한 것들. [SQLite](https://www.sqlite.org/) , [MySQL](https://www.mysql.com/) 및 [PostgreSQL은](https://www.postgresql.org/) 모두 텍스트 검색을 지원하며 [MongoDB](https://www.mongodb.com/) 및 [CouchDB](http://couchdb.apache.org/) 와 같은 NoSQL 데이터베이스 도 지원합니다.

Flask 응용 프로그램에서이 중 어느 것이 작동 할 수 있는지 궁금하다면 그 대답이 전부입니다! 그것은 플라스크의 강점 중 하나입니다. 최선의 선택은 무엇입니까?

전용 검색 엔진 목록에서 Elasticsearch는 Logstash 및 Kibana와 함께 로그 인덱싱을위한 ELK 스택에서 "E"로 인기가 높기 때문에 상당히 유명합니다. 관계형 데이터베이스 중 하나의 검색 기능을 사용하는 것도 좋은 선택이 될 수 있지만 SQLAlchemy가이 기능을 지원하지 않는다는 사실을 감안할 때 원시 SQL 문을 사용하여 검색을 처리하거나 높은 수준을 제공하는 패키지를 찾아야합니다. SQLAlchemy와 공존하면서 텍스트 검색에 대한 레벨 액세스.

위의 분석을 기반으로 Elasticsearch를 사용하지만 다른 엔진으로 전환하기가 매우 쉬운 방식으로 모든 텍스트 인덱싱 및 검색 기능을 구현할 것입니다. 그러면 단일 모듈에서 몇 가지 기능을 다시 작성하여 구현을 다른 엔진을 기반으로하는 대체 구현으로 대체 할 수 있습니다.

## Elasticsearch 설치

원 클릭 설치 프로그램, 직접 설치해야하는 바이너리가 포함 된 zip 파일 및 Docker 이미지를 포함하여 Elasticsearch를 설치하는 몇 가지 방법이 있습니다. 설명서에는 이러한 모든 옵션에 대한 자세한 정보 가 포함 된 [설치](https://www.elastic.co/guide/en/elasticsearch/reference/current/install-elasticsearch.html) 페이지가 있습니다. Linux를 사용하는 경우 배포에 사용할 수있는 패키지가있을 수 있습니다. Mac을 사용 중이고 Homebrew가 설치되어 있으면 간단하게 실행할 수 있습니다 `brew install elasticsearch`.

컴퓨터에 Elasticsearch를 설치 한 후에는 `http://localhost:9200`브라우저의 주소 표시 줄 에 입력 하여 서비스에 대한 기본 정보를 JSON 형식으로 반환하여 브라우저 가 실행 중인지 확인할 수 있습니다 .

Python에서 Elasticsearch를 관리 할 예정이므로 Python 클라이언트 라이브러리도 사용합니다.

```
(venv) $ pip install elasticsearch
```

*requirements.txt* 파일 을 업데이트 할 수도 있습니다.

```
(venv) $ pip freeze > requirements.txt
```

## Elasticsearch 튜토리얼

먼저 파이썬 쉘에서 Elasticsearch를 사용하는 기본 사항을 보여 드리겠습니다. 이렇게하면이 서비스에 익숙해 지므로 나중에 논의 할 구현을 이해할 수 있습니다.

Elasticsearch에 대한 연결을 만들려면 `Elasticsearch`연결 URL을 인수로 전달하여 class 인스턴스를 생성하십시오 .

```
>>> from elasticsearch import Elasticsearch
>>> es = Elasticsearch('http://localhost:9200')
```

Elasticsearch의 데이터는 *색인에* 기록됩니다 . 관계형 데이터베이스와 달리 데이터는 단지 [JSON](http://www.json.org/) 객체입니다. 다음 예제는이라는 `text`색인에 필드가있는 객체를 씁니다 `my_index`.

```
>>> es.index(index='my_index', id=1, body={'text': 'this is a test'})
```

저장된 각 문서에 대해 Elasticsearch는 데이터와 함께 고유 한 ID와 JSON 객체를 가져옵니다.

이 색인에 두 번째 문서를 저장합시다.

```
>>> es.index(index='my_index', id=2, body={'text': 'a second test'})
```

이 색인에 두 개의 문서가 있으므로 자유 형식 검색을 발행 할 수 있습니다. 이 예에서는 다음을 검색합니다 `this test`.

```
>>> es.search(index='my_index', body={'query': {'match': {'text': 'this test'}}})
```

`es.search()`호출 의 응답 은 검색 결과가 포함 된 Python 사전입니다.

```
{
    'took': 1,
    'timed_out': False,
    '_shards': {'total': 5, 'successful': 5, 'skipped': 0, 'failed': 0},
    'hits': {
        'total': 2, 
        'max_score': 0.5753642, 
        'hits': [
            {
                '_index': 'my_index',
                '_type': 'my_index',
                '_id': '1',
                '_score': 0.5753642,
                '_source': {'text': 'this is a test'}
            },
            {
                '_index': 'my_index',
                '_type': 'my_index',
                '_id': '2',
                '_score': 0.25316024,
                '_source': {'text': 'a second test'}
            }
        ]
    }
}
```

여기서 검색 결과에 각각 점수가 지정된 두 개의 문서가 반환되었음을 알 수 있습니다. 가장 높은 점수를받은 문서에는 검색 한 두 단어가 포함되어 있고 다른 문서에는 하나만 포함되어 있습니다. 단어가 텍스트와 정확히 일치하지 않기 때문에 최상의 결과조차도 큰 점수를 얻지 못함을 알 수 있습니다.

이제 이것은 단어를 검색하면 결과입니다 `second`.

```
>>> es.search(index='my_index', body={'query': {'match': {'text': 'second'}}})
{
    'took': 1,
    'timed_out': False,
    '_shards': {'total': 5, 'successful': 5, 'skipped': 0, 'failed': 0},
    'hits': {
        'total': 1,
        'max_score': 0.25316024,
        'hits': [
            {
                '_index': 'my_index',
                '_type': 'my_index',
                '_id': '2',
                '_score': 0.25316024,
                '_source': {'text': 'a second test'}
            }
        ]
    }
}
```

검색 결과가이 문서의 텍스트와 일치하지 않기 때문에 점수가 여전히 낮지 만 두 문서 중 하나에 만 "second"라는 단어가 포함되어 있기 때문에 다른 문서는 전혀 표시되지 않습니다.

Elasticsearch 쿼리 객체에는 더 많은 옵션이 있으며 [문서화](https://www.elastic.co/guide/en/elasticsearch/reference/current/search-request-body.html) 되어 있으며 관계형 데이터베이스와 마찬가지로 페이지 매김 및 정렬과 같은 옵션이 포함되어 있습니다.

이 색인에 더 많은 항목을 추가하고 다른 검색을 시도하십시오. 실험을 마치면 다음 명령을 사용하여 색인을 삭제할 수 있습니다.

```
>>> es.indices.delete('my_index')
```

## Elasticsearch 구성

Elasticsearch를 애플리케이션에 통합하는 것은 Flask의 강력한 예입니다. 이것은 Flask와 관련이없는 서비스 및 Python 패키지이지만 Flask의 `app.config`사전에서 쓸 구성에서 시작하여 꽤 좋은 수준의 통합을 얻습니다 .

*config.py* : Elasticsearch 구성.

```
class Config(object):
    # ...
    ELASTICSEARCH_URL = os.environ.get('ELASTICSEARCH_URL')
```

다른 많은 구성 항목과 마찬가지로 Elasticsearch의 연결 URL은 환경 변수에서 제공됩니다. 변수가 정의되어 있지 않으면 설정을로 설정하고 `None`Elasticsearch를 비활성화하는 신호로 사용하겠습니다. 이는 주로 편의를위한 것으로, 애플리케이션에서 작업 할 때, 특히 단위 테스트를 실행할 때 항상 Elasticsearch 서비스를 시작하고 실행하지 않아도됩니다. 따라서 서비스를 사용 `ELASTICSEARCH_URL`하려면 터미널에서 직접 또는 다음과 같이 환경 변수를 *.env* 파일 에 추가 하여 환경 변수 를 정의해야 합니다.

```
ELASTICSEARCH_URL=http://localhost:9200
```

Elasticsearch는 Flask 확장 프로그램으로 포장되지 않은 문제를 제시합니다. 위의 예제에서와 같이 전역 범위에서 Elasticsearch 인스턴스를 만들 수 없습니다. 초기화하기 위해 액세스가 필요하기 때문에 함수가 호출 된 `app.config`후에 만 사용할 수 있습니다 `create_app()`. 따라서 응용 프로그램 팩토리 함수에서 인스턴스에 `elasticsearch`속성 을 추가하기로 결정했습니다 `app`.

*app / __ init__.py* : Elasticsearch 인스턴스

```
# ...
from elasticsearch import Elasticsearch

# ...

def create_app(config_class=Config):
    app = Flask(__name__)
    app.config.from_object(config_class)

    # ...
    app.elasticsearch = Elasticsearch([app.config['ELASTICSEARCH_URL']]) \
        if app.config['ELASTICSEARCH_URL'] else None

    # ...
app`인스턴스에 새로운 속성을 추가하는 것은 조금 이상하게 보일 수 있지만, 파이썬 객체는 구조가 엄격하지 않으며 언제든지 새로운 속성을 추가 할 수 있습니다. 또한 고려할 수있는 대안 은 해당 기능에 정의 된 속성 을 사용하여 서브 클래스 `Flask`(아마도 호출 가능 `Microblog`) 를 작성하는 것 입니다.`elasticsearch``__init__()
```

Elasticsearch 서비스의 URL이 환경에 정의되지 않은 경우 [조건식](https://docs.python.org/3/reference/expressions.html#conditional-expressions) 을 사용하여 Elasticsearch 인스턴스를 만드는 방법에 유의하십시오 `None`.

## 전문 검색 추상화

이 장의 소개에서 말했듯이 Elasticsearch에서 다른 검색 엔진으로 쉽게 전환하고 싶으며 블로그 게시물 검색을 위해이 기능을 특별히 코딩하고 싶지 않습니다. 향후에 솔루션을 설계하는 것을 선호합니다 필요한 경우 다른 모델로 쉽게 확장 할 수 있습니다. 이 모든 이유 때문에 검색 기능에 대한 *추상화* 를 작성하기로 결정했습니다 . 아이디어는 기능을 일반적인 용어로 디자인하는 것이므로 `Post`모델이 색인을 생성해야하는 유일한 모델이라고 가정하지 않으며 Elasticsearch가 선택한 색인 엔진이라고 가정하지도 않습니다. 그러나 아무 것도 가정 할 수 없다면 어떻게이 작업을 수행 할 수 있습니까?

가장 먼저 필요한 것은 색인을 생성 할 모델과 필드를 나타내는 일반적인 방법을 찾는 것입니다. 색인 작성이 필요한 모델은 색인에 `__searchable__`포함되어야하는 필드를 나열 하는 클래스 속성 을 정의해야한다고 말하겠습니다 . 를 들어 `Post`모델, 이러한 변경 사항은 다음과 같습니다 :

*app / models.py* : \ _ \ _ searchable \ _ \ _ 속성을 Post 모델에 추가하십시오.

```
class Post(db.Model):
    __searchable__ = ['body']
    # ...
```

여기서는이 모델의 `body`필드를 인덱스 해야한다고 말합니다 . 그러나 이것이 완벽하게 명확하게하기 위해 `__searchable__`추가 한이 속성은 변수 일 뿐이며 관련 동작이 없습니다. 인덱싱 함수를 일반적인 방식으로 작성하는 데 도움이됩니다.

*app / search.py* 모듈 에서 Elasticsearch 색인과 상호 작용하는 모든 코드를 작성하겠습니다 . 아이디어는이 모듈에 모든 Elasticsearch 코드를 유지하는 것입니다. 애플리케이션의 나머지 부분은이 새로운 모듈의 기능을 사용하여 인덱스에 액세스하며 Elasticsearch에 직접 액세스 할 수 없습니다. 언젠가 Elasticsearch가 더 이상 마음에 들지 않고 다른 엔진으로 전환하고 싶다면이 모듈의 기능을 다시 작성하기 만하면 애플리케이션이 이전과 같이 계속 작동하기 때문에 중요합니다.

이 응용 프로그램의 경우 텍스트 인덱싱과 관련된 세 가지 지원 기능이 필요하다고 결정했습니다. 전체 텍스트 인덱스에 항목을 추가하고 인덱스에서 항목을 제거해야합니다 (하루 블로그 게시물 삭제를 지원한다고 가정). 검색어를 실행해야합니다. 다음은 Python 콘솔에서 위에서 보여준 기능을 사용하여 Elasticsearch에 대한이 세 가지 기능을 구현 하는 *app / search.py* 모듈입니다.

*app / search.py* : 검색 기능.

```
from flask import current_app

def add_to_index(index, model):
    if not current_app.elasticsearch:
        return
    payload = {}
    for field in model.__searchable__:
        payload[field] = getattr(model, field)
    current_app.elasticsearch.index(index=index, id=model.id, body=payload)

def remove_from_index(index, model):
    if not current_app.elasticsearch:
        return
    current_app.elasticsearch.delete(index=index, id=model.id)

def query_index(index, query, page, per_page):
    if not current_app.elasticsearch:
        return [], 0
    search = current_app.elasticsearch.search(
        index=index,
        body={'query': {'multi_match': {'query': query, 'fields': ['*']}},
              'from': (page - 1) * per_page, 'size': per_page})
    ids = [int(hit['_id']) for hit in search['hits']['hits']]
    return ids, search['hits']['total']['value']
```

이러한 함수는 모두 `app.elasticsearch`is 인지 확인하여 시작하며이 경우 `None`아무 작업도하지 않고 반환됩니다. 이는 Elasticsearch 서버가 구성되지 않은 경우에도 애플리케이션이 검색 기능없이 오류없이 계속 실행되도록하기위한 것입니다. 이는 개발 중이나 단위 테스트를 실행할 때 편리함과 관련이 있습니다.

함수는 색인 이름을 인수로 승인합니다. Elasticsearch로 전달하는 모든 호출에서 Python 콘솔 예제에서와 같이이 이름을 인덱스 이름 및 문서 유형으로 사용하고 있습니다.

인덱스에서 항목을 추가 및 제거하는 함수는 SQLAlchemy 모델을 두 번째 인수로 사용합니다. 이 `add_to_index()`함수는 `__searchable__`모델에 추가 한 클래스 변수를 사용 하여 색인에 삽입 된 문서를 작성합니다. 리콜하면 Elasticsearch 문서에도 고유 식별자가 필요합니다. 이를 위해 `id`SQLAlchemy 모델 의 필드를 사용하고 있는데 이는 편리합니다. `id`SQLAlchemy 및 Elasticsearch에 동일한 값을 사용하면 두 데이터베이스의 항목을 연결할 수 있으므로 검색을 실행할 때 매우 유용합니다. 위에서 언급하지 않은 것은 기존 항목으로 항목을 추가하려고하면 `id`Elasticsearch가 이전 항목을 새 항목으로 대체하므로 수정 된 항목 `add_to_index()`뿐만 아니라 새 객체에도 사용할 수 있다는 것입니다.

이전에 `es.delete()`사용 했던 기능을 보여주지 않았습니다 `remove_from_index()`. 이 기능은 주어진 밑에 저장된 문서를 삭제합니다 `id`. 다음은 동일한 `id`것을 사용하여 두 데이터베이스의 항목을 연결 하는 편의의 좋은 예입니다 .

이 `query_index()`함수는 페이지 이름 컨트롤과 함께 검색 할 인덱스 이름과 텍스트를 사용하므로 Flask-SQLAlchemy 결과처럼 검색 결과를 페이지 매김 할 수 있습니다. 이미 `es.search()`Python 콘솔에서 함수 사용법을 보았습니다 . 여기서 발행하는 호출은 상당히 유사하지만 `match`쿼리 유형 을 사용하는 대신 `multi_match`여러 필드를 검색 할 수있는 을 사용하기로 결정했습니다 . 의 필드 이름을 전달하면 `*`Elasticsearch에 모든 필드를 찾도록 지시하므로 기본적으로 전체 인덱스를 검색합니다. 다른 모델이 색인에서 다른 필드 이름을 가질 수 있으므로이 기능을 일반화하는 데 유용합니다.

`body`에 대한 인수는 `es.search()`쿼리 자체뿐만 아니라 매김 인수를 포함합니다. `from`및 `size`인수는 전체 결과 집합의 부분 집합이 반환에 필요한 사항을 제어 할 수 있습니다. Elasticsearch는 `Pagination`Flask-SQLAlchemy와 같은 멋진 객체를 제공하지 않으므로 `from`값 을 계산하기 위해 페이지 매김 수학을 수행해야합니다 .

함수 의 `return`문장 `query_index()`은 다소 복잡합니다. 첫 번째는 `id`검색 결과 의 요소 목록이고 두 번째는 총 결과 수입니다. 둘 다 `es.search()`함수가 반환 한 Python 사전에서 가져옵니다 . ID 목록을 얻는 데 사용하는 표현식에 익숙하지 않은 경우이를 *목록 이해* 라고하며 *목록* 을 한 형식에서 다른 형식으로 변환 할 수있는 Python 언어의 환상적인 기능입니다. 이 경우에는 목록 이해를 사용하여 `id`Elasticsearch에서 제공하는 훨씬 더 큰 결과 목록에서 값 을 추출합니다 .

너무 혼란 스럽습니까? 파이썬 콘솔에서 이러한 기능을 시연하면 약간 더 이해하는 데 도움이 될 수 있습니다. 다음 세션에서는 데이터베이스의 모든 게시물을 Elasticsearch 색인에 수동으로 추가합니다. 테스트 데이터베이스에는 숫자 "1", "2", "3", "4"및 "5"가 포함 된 몇 개의 게시물이 있었으므로 검색 쿼리로 사용했습니다. 데이터베이스의 내용과 일치하도록 쿼리를 조정해야 할 수도 있습니다.

```
>>> from app.search import add_to_index, remove_from_index, query_index
>>> for post in Post.query.all():
...     add_to_index('posts', post)
>>> query_index('posts', 'one two three four five', 1, 100)
([15, 13, 12, 4, 11, 8, 14], 7)
>>> query_index('posts', 'one two three four five', 1, 3)
([15, 13, 12], 7)
>>> query_index('posts', 'one two three four five', 2, 3)
([4, 11, 8], 7)
>>> query_index('posts', 'one two three four five', 3, 3)
([14], 7)
```

내가 발행 한 쿼리는 7 개의 결과를 반환했습니다. 페이지 당 100 개의 항목으로 1 페이지를 요청했을 때 7 개를 모두 얻었지만 다음 세 가지 예는 Flask-SQLAlchemy에서했던 것과 매우 유사한 방식으로 결과를 페이지 매김하는 방법을 보여줍니다. 결과는 SQLAlchemy 오브젝트 대신 ID 목록으로 제공됩니다.

일을 깨끗하게 유지하려면 `posts`실험을 한 후에 색인을 삭제하십시오 .

```
>>> app.elasticsearch.indices.delete('posts')
```

## SQLAlchemy와 검색 통합

이전 섹션에서 보여 드린 솔루션은 괜찮지 만 여전히 몇 가지 문제가 있습니다. 가장 명백한 문제는 결과가 숫자 ID 목록으로 제공된다는 것입니다. 이것은 매우 불편하고 렌더링을 위해 템플릿으로 전달할 수 있도록 SQLAlchemy 모델이 필요하며 해당 숫자 목록을 데이터베이스의 해당 모델로 바꾸는 방법이 필요합니다. 두 번째 문제점은이 솔루션에서 포스트가 추가되거나 제거 될 때 애플리케이션이 명시 적으로 인덱싱 호출을 발행해야한다는 점입니다. 이는 SQLAlchemy 측에서 변경할 때 인덱싱 호출이 누락되는 버그가 있기 때문에 끔찍하지는 않지만 이상적이지는 않습니다. 쉽게 감지되지 않으면 버그가 발생할 때마다 두 데이터베이스가 점점 동기화되지 않고 잠시 동안 눈치 채지 못할 것입니다.

데이터베이스에서 해당 오브젝트를 읽는 SQLAlchemy 조회를 작성하여 ID를 오브젝트로 바꾸는 문제를 해결할 수 있습니다. 실제로는 쉬운 것처럼 들리지만 단일 쿼리로 효율적으로 수행하는 것은 실제로 구현하기가 약간 까다 롭습니다.

인덱싱 변경을 자동으로 트리거하는 문제 때문에 SQLAlchemy *events* 에서 Elasticsearch 인덱스로 업데이트하기로 결정했습니다 . SQLAlchemy는 응용 프로그램에 알릴 수 있는 많은 [이벤트](http://docs.sqlalchemy.org/en/latest/core/event.html) 목록을 제공합니다 . 예를 들어, 세션이 커밋 될 때마다 SQLAlchemy가 호출 한 응용 프로그램에서 함수를 사용할 수 있으며이 함수에서 SQLAlchemy 세션에서 수행 된 것과 동일한 업데이트를 Elasticsearch 인덱스에 적용 할 수 있습니다.

이 두 가지 문제에 대한 솔루션을 구현하기 위해 *mixin* 클래스 를 작성하겠습니다 . 믹스 인 수업을 기억하십니까? 에서 [제 5 장](https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-v-user-logins) , 내가 추가 된 `UserMixin`받는 플라스크-로그인에서 클래스를 `User`그것을 플라스크 - 로그인이 요구 한 몇 가지 기능을 제공하는 모델. 검색 지원 `SearchableMixin`을 위해 모델에 연결할 때 관련 전체 텍스트 인덱스를 자동으로 관리 할 수있는 클래스를 직접 정의하려고합니다 . mixin 클래스는 SQLAlchemy와 Elasticsearch 세계 사이에서 "접착제"계층으로 작동하여 위에서 언급 한 두 가지 문제에 대한 솔루션을 제공합니다.

구현을 보여 드리고 흥미로운 세부 사항을 살펴 보겠습니다. 여기에는 여러 가지 고급 기술이 사용되므로이 코드를 완전히 이해하려면이 코드를주의해서 연구해야합니다.

*app / models.py* : SearchableMixin 클래스.

```
from app.search import add_to_index, remove_from_index, query_index

class SearchableMixin(object):
    @classmethod
    def search(cls, expression, page, per_page):
        ids, total = query_index(cls.__tablename__, expression, page, per_page)
        if total == 0:
            return cls.query.filter_by(id=0), 0
        when = []
        for i in range(len(ids)):
            when.append((ids[i], i))
        return cls.query.filter(cls.id.in_(ids)).order_by(
            db.case(when, value=cls.id)), total

    @classmethod
    def before_commit(cls, session):
        session._changes = {
            'add': list(session.new),
            'update': list(session.dirty),
            'delete': list(session.deleted)
        }

    @classmethod
    def after_commit(cls, session):
        for obj in session._changes['add']:
            if isinstance(obj, SearchableMixin):
                add_to_index(obj.__tablename__, obj)
        for obj in session._changes['update']:
            if isinstance(obj, SearchableMixin):
                add_to_index(obj.__tablename__, obj)
        for obj in session._changes['delete']:
            if isinstance(obj, SearchableMixin):
                remove_from_index(obj.__tablename__, obj)
        session._changes = None

    @classmethod
    def reindex(cls):
        for obj in cls.query:
            add_to_index(cls.__tablename__, obj)

db.event.listen(db.session, 'before_commit', SearchableMixin.before_commit)
db.event.listen(db.session, 'after_commit', SearchableMixin.after_commit)
```

이 믹스 인 클래스에는 4 가지 함수, 모든 클래스 메소드가 있습니다. 리프레쉬와 마찬가지로 클래스 메소드는 특정 인스턴스가 아닌 클래스와 연관된 특수 메소드입니다. 이 메소드가 첫 번째 인수로 인스턴스가 아닌 클래스를 수신한다는 것을 분명히하기 위해 `self`일반 인스턴스 메소드에서 사용되는 인수의 이름을 어떻게 변경했는지 참고하십시오 `cls`. `Post`예를 들어 모델에 연결되면 `search()`위 의 메소드 `Post.search()`는 실제 클래스 인스턴스를 가질 필요없이 로 호출됩니다 `Post`.

`search()`클래스 방법은 랩 `query_index()`에서 기능 *앱 / search.py* 실제 객체와 객체 ID 목록을 대체. 이 함수가 수행하는 첫 번째 작업 은 인덱스 이름으로 `query_index()`전달 `cls.__tablename__`되는 call 입니다. 이것은 규칙이 될 것입니다. 모든 인덱스는 관계형 테이블에 지정된 Flask-SQLAlchemy라는 이름으로 명명됩니다. 이 함수는 결과 ID 목록과 총 결과 수를 반환합니다. ID별로 개체 목록을 검색하는 SQLAlchemy 쿼리는`CASE`데이터베이스의 결과가 ID와 동일한 순서로 나오는지 확인하는 데 사용해야하는 SQL 언어의 명령문. Elasticsearch 쿼리는 결과를 더 관련성있게 정렬 한 결과를 반환하기 때문에 중요합니다. 이 쿼리의 작동 방식에 대한 자세한 내용을 보려면이 [StackOverflow 질문에](https://stackoverflow.com/a/6332081/904393) 대해 허용 된 답변을 참조하십시오 . 이 `search()`함수는 ID 목록을 대체하는 쿼리를 반환하고 총 검색 결과 수를 두 번째 반환 값으로 전달합니다.

`before_commit()`및 `after_commit()`방법은 각각 발생 커밋 이전과 이후 트리거 SQLAlchemy의 두 이벤트에 응답 할 것입니다. 세션이 아직 커밋되지 않았기 때문에 나는 개체로 사용할 수, 추가, 수정 및 삭제하려고하는 것을 밖으로와 그림을 볼 수 있도록 전 처리기, 유용 `session.new`, `session.dirty`그리고 `session.deleted`각각. 세션이 커밋 된 후에는 이러한 개체를 더 이상 사용할 수 없으므로 커밋이 발생하기 전에 저장해야합니다. `session._changes`세션이 커밋 되 자마자 Elasticsearch 인덱스를 업데이트하는 데 사용하기 때문에 사전을 사용 하여 세션 커밋에서 살아남을 장소에 이러한 객체를 작성하고 있습니다.

때 `after_commit()`핸들러가 호출이이 Elasticsearch 측에서 변경을 할 수있는 적절한 시간이다, 그래서 세션이 성공적으로 최선을 다하고있다. 세션 객체에는 `_changes`내가 추가 한 변수가 `before_commit()`있으므로 이제 추가, 수정 및 삭제 된 객체를 반복 하고 클래스 가있는 객체에 대해 *app / search.py* 의 색인 함수를 호출 할 수 있습니다 `SearchableMixin`.

`reindex()`클래스 메서드는 관계 측면에서 모든 데이터와 인덱스를 갱신하는 데 사용할 수있는 간단한 헬퍼 방법입니다. 위의 Python 셸 세션과 비슷한 작업을 수행하여 모든 게시물을 테스트 색인에 초기로드했습니다. 이 방법을 사용 `Post.reindex()`하면 데이터베이스의 모든 게시물을 검색 색인에 추가 할 수 있습니다 .

클래스 정의 후 SQLALchemy의 function을 두 번 호출했습니다 `db.event.listen()`. 이 호출은 클래스 내부가 아니라 그 뒤에 있습니다. 이 두 명령문의 목적은 SQLAlchemy가 각 커밋 전후에 각각 `before_commit()`및 `after_commit()`메소드를 호출하게하는 이벤트 핸들러를 설정하는 것 입니다.

`SearchableMixin`클래스를 `Post`모델에 통합하려면 서브 클래스로 추가해야하며 before 및 after commit 이벤트도 연결해야합니다.

*app / models.py* : Post 모델에 SearchableMixin 클래스 추가

```
class Post(SearchableMixin, db.Model):
    # ...
```

이제 `Post`모델은 게시물에 대한 전체 텍스트 검색 색인을 자동으로 유지 관리합니다. 이 `reindex()`방법을 사용하여 현재 데이터베이스에있는 모든 게시물에서 색인을 초기화 할 수 있습니다 .

```
>>> Post.reindex()
```

그리고를 실행하여 SQLAlchemy 모델로 작업하는 게시물을 검색 할 수 있습니다 `Post.search()`. 다음 예에서는 쿼리에 5 가지 요소 중 첫 페이지를 요청합니다.

```
>>> query, total = Post.search('one two three four five', 1, 5)
>>> total
7
>>> query.all()
[<Post five>, <Post two>, <Post one>, <Post one more>, <Post one>]
```

## 검색 양식

이것은 매우 강렬했다. 위에서 여러 가지 고급 주제를 다루기 위해 수행 한 작업이므로 완전히 이해하는 데 시간이 걸릴 수 있습니다. 그러나 이제 블로그 게시물에 대한 자연어 검색을 수행 할 수있는 완벽한 시스템이 있습니다. 지금해야 할 일은이 모든 기능을 응용 프로그램과 통합하는 것입니다.

웹 기반 검색을위한 상당히 표준적인 접근 방식 `q`은 검색어를 URL의 쿼리 문자열에 인수로 사용하는 것입니다. 예를 들어 `Python`Google에서 검색 하고 몇 초를 저장하려는 경우 브라우저의 주소 표시 줄에 다음 URL을 입력하여 결과로 직접 이동할 수 있습니다.

```
https://www.google.com/search?q=python
```

링크를 클릭하기 만하면 검색 결과에 액세스 할 수있는 다른 사람들과 공유 할 수 있기 때문에 검색을 URL에 완전히 캡슐화하는 것이 좋습니다.

이것은 과거에 웹 양식을 처리하는 방법을 보여줍니다. `POST`응용 프로그램이 지금까지 가지고있는 모든 양식에 대해 양식 데이터를 제출하기 위해 요청을 사용 했지만 위와 같이 검색을 구현하려면 양식 제출이 `GET`요청 으로 이동 해야합니다. 이는 URL을 입력 할 때 사용되는 요청 방법입니다 브라우저를 클릭하거나 링크를 클릭하십시오. 또 다른 흥미로운 차이점은 검색 양식이 탐색 모음에있을 것이므로 응용 프로그램의 모든 페이지에 표시되어야한다는 것입니다.

`q`텍스트 필드 만있는 검색 양식 클래스는 다음과 같습니다 .

*app / main / forms.py* : 검색 양식.

```
from flask import request

class SearchForm(FlaskForm):
    q = StringField(_l('Search'), validators=[DataRequired()])

    def __init__(self, *args, **kwargs):
        if 'formdata' not in kwargs:
            kwargs['formdata'] = request.args
        if 'csrf_enabled' not in kwargs:
            kwargs['csrf_enabled'] = False
        super(SearchForm, self).__init__(*args, **kwargs)
```

이 `q`필드는 과거에 사용한 다른 텍스트 필드와 유사하므로 설명이 필요하지 않습니다. 이 양식의 경우 제출 버튼을 사용하지 않기로 결정했습니다. 텍스트 필드가있는 양식의 경우, 필드에 초점을두고 Enter를 누르면 브라우저가 양식을 제출하므로 단추가 필요하지 않습니다. 또한 호출자가 제공하지 않으면 및 인수에 `__init__`대한 값을 제공 하는 생성자 함수를 추가했습니다 . 이 인수는 Flask-WTF가 양식 제출을 얻는 위치를 결정합니다. 기본값은 사용 이며, Flask는 요청을 통해 제출 된 양식 값을 넣습니다 . 요청을 통해 제출 된 양식 에는 쿼리 문자열의 필드 값이 있으므로 Flask-WTF를 가리켜 야합니다.`formdata``csrf_enabled``formdata``request.form``POST``GET``request.args`Flask가 쿼리 문자열 인수를 쓰는 곳입니다. 기억 하듯이 `form.hidden_tag()`템플릿 에는 구성을 통해 양식에 추가되는 CSRF 토큰이 포함되어있어 양식에 기본적으로 CSRF 보호 기능이 추가되어 있습니다. 클릭 가능한 검색 링크가 작동하려면 CSRF를 비활성화 `csrf_enabled`해야 `False`하므로 Flask-WTF가이 양식에 대해 CSRF 검증을 우회해야 함을 알 수 있도록 설정 하고 있습니다.

모든 페이지에이 양식을 표시해야 `SearchForm`하므로 사용자가보고있는 페이지에 관계없이 클래스 의 인스턴스를 만들어야합니다 . 익명 사용자의 경우 현재 콘텐츠를 표시하지 않기 때문에 사용자가 로그인해야합니다. 모든 경로에서 양식 객체를 만든 다음 양식을 모든 템플릿에 전달하는 대신 전체 응용 프로그램에서 기능을 구현해야 할 때 코드 중복을 제거하는 매우 유용한 트릭을 보여 드리겠습니다. `before_request`이전에 [6 장으로](https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-vi-profile-page-and-avatars) 돌아가서 각 사용자의 마지막 방문 시간을 기록 하기 위해 이미 핸들러를 사용했습니다 . 내가 할 일은 동일한 기능으로 검색 양식을 작성하지만 꼬인 것입니다.

*app / main / routes.py* : before \ _request 핸들러에서 검색 양식을 인스턴스화합니다.

```
from flask import g
from app.main.forms import SearchForm

@bp.before_app_request
def before_request():
    if current_user.is_authenticated:
        current_user.last_seen = datetime.utcnow()
        db.session.commit()
        g.search_form = SearchForm()
    g.locale = str(get_locale())
```

여기서 인증 된 사용자가있을 때 검색 폼 클래스의 인스턴스를 만듭니다. 그러나 물론 요청이 끝날 때까지 렌더링 할 수있을 때까지 지속하려면이 양식 객체가 필요하므로 어딘가에 저장해야합니다. `g`플라스크가 제공 하는 컨테이너 가 될 것 입니다. `g`Flask에서 제공하는 이 변수는 애플리케이션이 요청 수명 동안 지속해야하는 데이터를 저장할 수있는 장소입니다. 여기에 양식을 저장하고 있습니다 `g.search_form`. 따라서 요청 전 처리기가 종료되고 Flask가 요청 된 URL을 처리하는 뷰 함수를 호출하면 `g`객체가 동일하게 유지되며 양식이 첨부됩니다. 이 점에 유의하는 것이 중요합니다`g`변수는 각 요청 및 각 클라이언트에 따라 다르므로 웹 서버가 다른 클라이언트에 대해 한 번에 여러 요청을 처리하더라도 다른 요청에서 발생하는 `g`작업과 관계없이 각 요청에 대한 개인 저장소로 작업 할 수 있습니다. 동시에 처리됩니다.

다음 단계는 양식을 페이지에 렌더링하는 것입니다. 위의 내용은 모든 페이지에서이 양식을 원했기 때문에 탐색 표시 줄의 일부로 렌더링하는 것이 더 의미가 있습니다. 실제로 템플릿은 `g`변수에 저장된 데이터를 볼 수 있기 때문에 `render_template()`응용 프로그램의 모든 호출에서 양식을 명시 적 템플릿 인수로 추가하는 것에 대해 걱정할 필요가 없습니다 . 기본 템플릿에서 양식을 렌더링하는 방법은 다음과 같습니다.

*app / templates / base.html* : 탐색 모음에서 검색 양식을 렌더링하십시오.

```
            ...
            <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
                <ul class="nav navbar-nav">
                    ... home and explore links ...
                </ul>
                {% if g.search_form %}
                <form class="navbar-form navbar-left" method="get"
                        action="{{ url_for('main.search') }}">
                    <div class="form-group">
                        {{ g.search_form.q(size=20, class='form-control',
                            placeholder=g.search_form.q.label.text) }}
                    </div>
                </form>
                {% endif %}
                ...
```

양식이 `g.search_form`정의 된 경우에만 양식이 렌더링됩니다 . 오류 페이지와 같은 일부 페이지에 정의되어 있지 않을 수 있으므로이 점검이 필요합니다. 이 양식은 이전에 수행 한 양식과 약간 다릅니다. 양식 데이터를 요청 과 함께 쿼리 문자열에 제출하기를 원하므로 `method`속성을로 설정하고 `get`있습니다 `GET`. 또한 내가 만든 다른 양식 `action`은 양식을 렌더링하는 동일한 페이지에 제출 되었기 때문에 속성이 비어 있었습니다 . 이 양식은 모든 페이지에 표시되기 때문에 특별하므로 제출해야 할 위치를 명시 적으로 알려야합니다. 검색을 처리하기위한 전용 경로입니다.

## 검색보기 기능

검색 기능을 완성하는 마지막 기능은 검색 양식 제출을받는보기 기능입니다. 이보기 기능은 */ search* 경로에 첨부 되므로 Google과 마찬가지로 *http : // localhost : 5000 / search? q = search-words* 와 함께 검색 요청을 보낼 수 있습니다 .

*app / main / routes.py* : 검색보기 기능.

```
@bp.route('/search')
@login_required
def search():
    if not g.search_form.validate():
        return redirect(url_for('main.explore'))
    page = request.args.get('page', 1, type=int)
    posts, total = Post.search(g.search_form.q.data, page,
                               current_app.config['POSTS_PER_PAGE'])
    next_url = url_for('main.search', q=g.search_form.q.data, page=page + 1) \
        if total > page * current_app.config['POSTS_PER_PAGE'] else None
    prev_url = url_for('main.search', q=g.search_form.q.data, page=page - 1) \
        if page > 1 else None
    return render_template('search.html', title=_('Search'), posts=posts,
                           next_url=next_url, prev_url=prev_url)
```

다른 양식에서이 `form.validate_on_submit()`방법을 사용 하여 양식 제출이 유효한지 확인했습니다. 불행히도 그 방법은 `POST`요청을 통해 제출 된 양식에만 작동 하므로이 양식의 `form.validate()`경우 데이터 제출 방법을 확인하지 않고 필드 값의 유효성을 검사 해야합니다 . 유효성 검사가 실패하면 사용자가 빈 검색 양식을 제출했기 때문에 모든 블로그 게시물을 보여주는 탐색 페이지로 리디렉션합니다.

`Post.search()`내 `SearchableMixin`클래스 의 메소드 는 검색 결과 목록을 얻는 데 사용됩니다. 페이지 매김은 인덱스 및 탐색 페이지와 매우 유사한 방식으로 처리되지만 `Pagination`Flask-SQLAlchemy 의 개체를 사용 하지 않고 다음 및 이전 링크를 생성하는 것은 약간 까다 롭습니다 . 여기에서 두 번째 반환 값으로 전달 된 총 결과 수가 `Post.search()`유용합니다.

검색 결과 페이지와 페이지 매김 링크가 계산되면 남은 것은이 모든 데이터가 포함 된 템플릿을 렌더링하는 것입니다. *index.html* 템플릿을 사용하여 검색 결과를 표시 하는 방법을 알아낼 수 있었지만 몇 가지 차이점 이 있으므로 *_post* 를 활용하여 검색 결과를 표시 하는 전용 *search.html* 템플릿 을 만들기로 결정했습니다. 검색 결과를 렌더링하는 *.html* 하위 템플릿 :

*app / templates / search.html* : 검색 결과 템플릿.

```
{% extends "base.html" %}

{% block app_content %}
    <h1>{{ _('Search Results') }}</h1>
    {% for post in posts %}
        {% include '_post.html' %}
    {% endfor %}
    <nav aria-label="...">
        <ul class="pager">
            <li class="previous{% if not prev_url %} disabled{% endif %}">
                <a href="{{ prev_url or '#' }}">
                    <span aria-hidden="true">&larr;</span>
                    {{ _('Previous results') }}
                </a>
            </li>
            <li class="next{% if not next_url %} disabled{% endif %}">
                <a href="{{ next_url or '#' }}">
                    {{ _('Next results') }}
                    <span aria-hidden="true">&rarr;</span>
                </a>
            </li>
        </ul>
    </nav>
{% endblock %}
```

이전 링크와 다음 링크의 렌더링 로직이 약간 혼동되면 [페이지 매김 구성 요소에](https://getbootstrap.com/docs/3.3/components/#pagination) 대한 부트 스트랩 문서를 검토하는 데 도움이 될 수 있습니다 .

![검색 결과](.\images\mega-tutorial/ch10-search-results.png)

어떻게 생각해? 이것은 강렬한 장으로, 상당히 고급 기술을 소개했습니다. 이 장의 일부 개념은 이해하는 데 시간이 다소 걸릴 수 있습니다.이 장에서 가장 중요한 점은 Elasticsearch와 다른 검색 엔진을 사용하려면 세 가지 기능을 다시 구현하기 만하면됩니다. *응용 프로그램 / search.py* . 이 노력을 통해 얻을 수있는 또 다른 중요한 이점은 미래에 다른 데이터베이스 모델에 대한 검색 지원을 추가해야하는 경우 `SearchableMixin`클래스를 추가하고 `__searchable__`색인을 생성 할 필드 목록이 있는 속성을 추가하면됩니다. SQLAlchemy 이벤트 핸들러 연결 이제부터는 전체 텍스트 인덱스를 쉽게 처리 할 수 있기 때문에 노력할만한 가치가 있다고 생각합니다.



## [Part XVII: Deployment on Linux](https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-xvii-deployment-on-linux)

Flask Mega-Tutorial 시리즈의 17 번째 버전으로, 마이크로 블로그를 Linux 서버에 배포 할 예정입니다.

이 장에서는 실제 사용자가 액세스 할 수 있도록 프로덕션 서버에 응용 프로그램을 배포 할 수있는 방법에 대해 논의하면서 Microblog 응용 프로그램의 수명에서 이정표에 도달하고 있습니다.

배포 주제는 광범위하므로, 여기에서 가능한 모든 옵션을 다루는 것은 불가능합니다. 이 장은 전통적인 호스팅 옵션을 탐구하기 위해 만들어졌으며 주제로 우분투를 실행하는 전용 Linux 서버와 널리 사용되는 Raspberry Pi 미니 컴퓨터를 사용할 것입니다. 나중 장에서 클라우드 및 컨테이너 배포와 같은 다른 옵션을 다룰 것입니다.

*이 장의 GitHub 링크는 [Browse](https://github.com/miguelgrinberg/microblog/tree/v0.17) , [Zip](https://github.com/miguelgrinberg/microblog/archive/v0.17.zip) , [Diff](https://github.com/miguelgrinberg/microblog/compare/v0.16...v0.17) 입니다.*

## 전통적인 호스팅

"전통적인 호스팅"을 언급 할 때 응용 프로그램이 수동으로 설치되거나 스톡 서버 시스템의 스크립트 설치 프로그램을 통해 설치됩니다. 프로세스에는 응용 프로그램, 해당 종속 항목 및 프로덕션 규모 웹 서버를 설치하고 시스템을 안전하게 구성 할 수 있습니다.

자신의 프로젝트를 배포하려고 할 때 가장 먼저 질문해야 할 것은 서버를 찾는 위치입니다. 요즘에는 많은 경제 호스팅 서비스가 있습니다. 예를 들어, 월 5 달러에 [Digital Ocean](https://www.digitalocean.com/) , [Linode](https://www.linode.com/) 또는 [Amazon Lightsail](https://amazonlightsail.com/) 은 배포 실험을 실행할 가상화 된 Linux 서버를 임대합니다 (Linode 및 Digital Ocean은 1GB의 RAM으로 엔트리 레벨 서버를 프로비저닝하는 반면 Amazon은 512MB 만 제공합니다) ). 비용을 들이지 않고 배포를 연습하고 싶다면 [Vagrant](https://www.vagrantup.com/) 와 [VirtualBox](https://www.virtualbox.org/) 는 자신의 컴퓨터에서 유료 서버와 유사한 가상 서버를 만들 수있는 두 가지 도구입니다.

기술적 관점에서 볼 때 운영 체제 선택에 따라이 응용 프로그램은 모든 주요 운영 체제, 다양한 오픈 소스 Linux 및 BSD 배포판 및 상용 OS X 및 Microsoft에 포함 된 목록에 배포 할 수 있습니다. Windows (OS X는 오픈 소스 BSD 파생물 인 Darwin을 기반으로하기 때문에 하이브리드 오픈 소스 / 상업용 옵션이지만).

OS X와 Windows는 서버로 작동하도록 최적화되지 않은 데스크탑 운영 체제이므로이를 후보로 버릴 것입니다. Linux 또는 BSD 운영 체제 중에서 선택하는 것은 주로 기본 설정을 기반으로하므로 Linux 중 가장 인기있는 두 가지를 선택하겠습니다. Linux 배포판에 관해서는 다시 한 번 인기로 선택하고 우분투와 함께 갈 것입니다.

## 우분투 서버 만들기

나와 함께이 배포를 수행하려면 서버가 있어야합니다. 유료 서버와 무료 서버를 구매할 수있는 두 가지 옵션을 추천합니다. 약간의 돈을 기꺼이 지불하려는 경우 Digital Ocean, Linode 또는 Amazon Lightsail에서 계정을 만들고 Ubuntu 16.04 가상 서버를 만들 수 있습니다. 가장 작은 서버 옵션을 사용해야합니다.이 옵션을 작성할 때 세 공급자 모두에 대해 월 $ 5의 비용이 듭니다. 비용은 서버 가동 시간으로 비례 배분되므로 서버를 생성하고 몇 시간 동안 재생 한 후 삭제하면 센트 만 지불하면됩니다.

무료 대안은 자신의 컴퓨터에서 실행할 수있는 가상 머신을 기반으로합니다. 이 옵션을 사용하려면 컴퓨터에 [Vagrant](https://www.vagrantup.com/) 및 [VirtualBox](https://www.virtualbox.org/) 를 설치 한 다음 *Vagrantfile* 이라는 파일을 만들어 다음 내용으로 VM의 사양을 설명하십시오.

*Vagrantfile* : 방랑 구성.

```
Vagrant.configure("2") do |config|
  config.vm.box = "ubuntu/xenial64"
  config.vm.network "private_network", ip: "192.168.33.10"
  config.vm.provider "virtualbox" do |vb|
    vb.memory = "1024"
  end
end
```

이 파일은 1GB의 RAM으로 Ubuntu 16.04 서버를 구성하며 IP 주소 192.168.33.10의 호스트 컴퓨터에서 액세스 할 수 있습니다. 서버를 작성하려면 다음 명령을 실행하십시오.

```
$ vagrant up
```

가상 서버를 관리하는 다른 옵션에 대한 자세한 내용 은 Vagrant [명령 줄 설명서](https://www.vagrantup.com/docs/cli/) 를 참조하십시오 .

## SSH 클라이언트 사용

서버는 헤드리스이므로 컴퓨터에있는 것처럼 데스크탑을 갖지 않을 것입니다. SSH 클라이언트를 통해 서버에 연결하고 명령 줄을 통해 서버에서 작업합니다. Linux 또는 Mac OS X를 사용하는 경우 [OpenSSH가](http://www.openssh.org/) 이미 설치 되었을 수 있습니다 . Microsoft Windows를 사용하는 경우 [Cygwin](https://www.cygwin.com/) , [Git](https://git-scm.com/) 및 [Linux 용 Windows 서브 시스템](https://msdn.microsoft.com/en-us/commandline/wsl/about) 은 OpenSSH를 제공하므로 이러한 옵션 중 하나를 설치할 수 있습니다.

타사 제공 업체의 가상 서버를 사용하는 경우 서버를 만들 때 IP 주소가 제공됩니다. 다음 명령을 사용하여 새 서버에서 터미널 세션을 열 수 있습니다.

```
$ ssh root@<server-ip-address>
```

비밀번호를 입력하라는 메시지가 표시됩니다. 서비스에 따라 서버를 만든 후 암호가 자동으로 생성되어 표시되거나 자신의 암호를 선택하는 옵션이 제공되었을 수 있습니다.

Vagrant VM을 사용하는 경우 다음 명령을 사용하여 터미널 세션을 열 수 있습니다.

```
$ vagrant ssh
```

Windows를 사용 중이고 Vagrant VM이있는 경우 `ssh`OpenSSH 에서 명령을 호출 할 수있는 쉘에서 위의 명령을 실행해야 합니다.

## 비밀번호가없는 로그인

Vagrant VM을 사용하는 경우 Vagrant가 `ubuntu`암호없이 자동으로 이름이 루트가 아닌 계정을 사용하도록 VM이 올바르게 구성되어 있으므로이 섹션을 건너 뛸 수 있습니다 .

가상 서버를 사용하는 경우 배포 작업을 수행하기 위해 일반 사용자 계정을 만들고 암호를 사용하지 않고 로그인하도록이 계정을 구성하는 것이 좋습니다. 처음에는 나쁜 생각처럼 보일 수 있습니다. 더 편리 할뿐만 아니라 더 안전하다는 것을 알 수 있습니다.

이름이 지정된 사용자 계정을 만들려고합니다 `ubuntu`(원하는 경우 다른 이름을 사용할 수 있음). 이 사용자 계정을 작성하려면 `ssh`이전 섹션 의 지시 사항을 사용하여 서버의 루트 계정에 로그인 한 후 다음 명령을 입력하여 사용자를 작성하고 `sudo`권한을 부여한 후 마지막으로 전환하십시오.

```
$ adduser --gecos "" ubuntu
$ usermod -aG sudo ubuntu
$ su ubuntu
```

이제 비밀번호를 입력하지 않고 로그인 할 수 있도록 [공개 키](http://en.wikipedia.org/wiki/Public-key_cryptography) 인증 `ubuntu`을 사용 하도록이 새 계정 을 구성하겠습니다 .

서버에서 열린 터미널 세션을 잠시 그대로두고 로컬 컴퓨터에서 두 번째 터미널을 시작하십시오. Windows를 사용하는 경우이 `ssh`명령 은 명령에 액세스 할 수있는 터미널이어야 하므로 아마도 `bash`기본 Windows 터미널이 아닌 유사한 프롬프트 일 것입니다 . 해당 터미널 세션에서 *~ / .ssh* 디렉토리 의 내용을 확인하십시오 .

```
$ ls ~/.ssh
id_rsa  id_rsa.pub
```

디렉토리 목록에 위와 같이 *id_rsa* 및 *id_rsa.pub* 라는 파일이 표시되면 이미 키가있는 것입니다. 이 두 파일이 없거나 *~ / .ssh* 디렉토리 가 없으면 OpenSSH 도구 세트의 일부인 다음 명령을 실행하여 SSH 키 쌍을 작성해야합니다.

```
$ ssh-keygen
```

이 응용 프로그램은 몇 가지 사항을 입력하라는 메시지를 표시합니다. 모든 프롬프트에서 Enter 키를 눌러 기본값을 그대로 사용하는 것이 좋습니다. 당신이하고있는 일을 알고 있고 달리하고 싶은 경우에, 당신은 확실히 할 수 있습니다.

이 명령이 실행되면 위에 나열된 두 파일이 있어야합니다. *id_rsa.pub* 파일 은 *공개 키* 이며, 이는 귀하 를 식별하기 위해 제 3 자에게 제공 할 파일입니다. *하여 id_rsa_gsg_keypair의* 파일이 있습니다 *개인 키를* 다른 사람과 공유 할 수 없습니다한다.

이제 서버에서 공개 키를 *인증 된 호스트* 로 구성해야합니다. 자신의 컴퓨터에서 연 단말기에서 공개 키를 화면에 인쇄하십시오.

```
$ cat ~/.ssh/id_rsa.pub
ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQCjw....F8Xv4f/0+7WT miguel@miguelspc
```

이것은 여러 줄에 걸쳐있는 매우 긴 문자 시퀀스입니다. 이 데이터를 클립 보드에 복사 한 다음 원격 서버의 터미널로 다시 전환해야합니다. 여기서 공개 키를 저장하려면 다음 명령을 실행하십시오.

```
$ echo <paste-your-key-here> >> ~/.ssh/authorized_keys
$ chmod 600 ~/.ssh/authorized_keys
```

비밀번호가없는 로그인이 작동합니다. 아이디어는 `ssh`머신에서 개인 키가 필요한 암호화 조작을 수행하여 서버에서 자신을 식별 한다는 것입니다. 그런 다음 서버는 공개 키를 사용하여 작업이 유효한지 확인합니다.

이제 `ubuntu`세션에서 로그 아웃 한 다음 세션에서 로그 아웃 `root`한 후 다음을 사용하여 `ubuntu`계정에 직접 로그인하십시오 .

```
$ ssh ubuntu@<server-ip-address>
```

이번에는 비밀번호를 입력 할 필요가 없습니다!

## 서버 보안

서버 손상 위험을 최소화하기 위해 공격자가 액세스 할 수있는 여러 가지 잠재적 인 문을 닫는 데 필요한 몇 가지 단계가 있습니다.

첫 번째 변경은 SSH를 통한 루트 로그인을 비활성화하는 것입니다. 이제 `ubuntu`계정에 비밀번호없이 액세스 할 수 있으며을 통해이 계정에서 관리자 명령을 실행할 수 `sudo`있으므로 루트 계정을 노출 할 필요가 없습니다. 루트 로그인을 비활성화하려면 서버 에서 */ etc / ssh / sshd_config* 파일 을 편집 해야합니다. 파일을 편집하는 데 사용할 수 있는 `vi`및 `nano`텍스트 편집기가 서버에 설치되어있을 수 있습니다 (둘 중 하나에 익숙하지 않은 경우 `nano`먼저 시도하십시오 ). `sudo`SSH 구성은 일반 사용자 (예 :)가 액세스 할 수 없으므로 편집기 앞에 접두사를 붙여야합니다 `sudo vi /etc/ssh/sshd_config`. 이 파일에서 한 줄을 변경해야합니다.

*/ etc / ssh / sshd_config* : 루트 로그인을 비활성화합니다.

```
PermitRootLogin no
```

이 변경을 수행하려면 `PermitRootLogin`서버에서 시작하는 행을 찾아서 서버에있을 수있는 값을로 변경해야합니다 `no`.

다음 변경 사항은 동일한 파일에 있습니다. 이제 모든 계정에 대해 비밀번호 로그인을 비활성화하겠습니다. 비밀번호가없는 로그인이 설정되어 있으므로 비밀번호를 전혀 허용 할 필요가 없습니다. 암호 비활성화에 대해 신경이 쓰이면이 변경 사항을 건너 뛸 수 있지만 프로덕션 서버의 경우 공격자가 운이 좋기를 바라는 모든 서버에서 임의의 계정 이름과 암호를 지속적으로 시도하기 때문에 프로덕션 서버의 경우 정말 좋습니다. 비밀번호 로그인을 비활성화하려면 */ etc / ssh / sshd_config* 에서 다음 줄을 변경하십시오 .

*/ etc / ssh / sshd_config* : 비밀번호 로그인을 비활성화합니다.

```
PasswordAuthentication no
```

SSH 구성 편집을 완료 한 후 변경 사항을 적용하려면 서비스를 다시 시작해야합니다.

```
$ sudo service ssh restart
```

세 번째 변경 사항은 *방화벽* 을 설치하는 것 입니다. 명시 적으로 활성화되지 않은 포트에서 서버에 대한 액세스를 차단하는 소프트웨어입니다.

```
$ sudo apt-get install -y ufw
$ sudo ufw allow ssh
$ sudo ufw allow http
$ sudo ufw allow 443/tcp
$ sudo ufw --force enable
$ sudo ufw status
```

이 명령 은 복잡하지 않은 방화벽 인 [ufw를](https://wiki.ubuntu.com/UncomplicatedFirewall) 설치 하고 포트 22 (ssh), 80 (http) 및 443 (https)의 외부 트래픽 만 허용하도록 구성합니다. 다른 포트는 허용되지 않습니다.

## 기본 종속성 설치

내 조언을 따르고 Ubuntu 16.04 릴리스로 서버를 프로비저닝 한 경우 Python 3.5를 완벽하게 지원하는 시스템이 있으므로 배포에 사용할 릴리스입니다.

기본 Python 인터프리터는 아마도 서버에 사전 설치되어 있지만 추가 패키지가 없을 수도 있고 Python 외부에 견고하고 생산 준비가 된 배포를 만드는 데 유용한 몇 가지 다른 패키지가 있습니다. . 데이터베이스 서버의 경우 SQLite에서 MySQL로 전환하겠습니다. postfix 패키지는 전자 메일을 보내는 데 사용할 메일 전송 에이전트입니다. 수퍼바이저 도구는 Flask 서버 프로세스를 모니터링하고 충돌이 발생하거나 서버가 재부팅 된 경우 자동으로 다시 시작합니다. nginx 서버는 외부에서 온 모든 요청을 수락하여 응용 프로그램으로 전달합니다. 마지막으로, git을 선택 도구로 사용하여 git 저장소에서 직접 응용 프로그램을 다운로드합니다.

```
$ sudo apt-get -y update
$ sudo apt-get -y install python3 python3-venv python3-dev
$ sudo apt-get -y install mysql-server postfix supervisor nginx git
```

이러한 설치는 대부분 무인으로 실행되지만, 어느 시점에서 세 번째 설치 명령문을 실행하는 동안 MySQL 서비스의 루트 비밀번호를 선택하라는 프롬프트가 표시되며 postfix 패키지 설치에 관한 몇 가지 질문이 표시됩니다. 기본 답변을 수락 할 수 있습니다.

이 배포에서는 Elasticsearch를 설치하지 않기로 선택합니다. 이 서비스에는 많은 양의 RAM이 필요하므로 2GB 이상의 RAM을 가진 큰 서버가있는 경우에만 실행 가능합니다. 메모리가 부족한 서버의 문제를 피하기 위해 검색 기능을 그대로 둡니다. 서버가 충분히 큰 경우 [Elasticsearch 사이트](https://elastic.co/) 에서 공식 .deb 패키지를 다운로드 하고 설치 지침에 따라 서버에 추가 할 수 있습니다. Ubuntu 16.04 패키지 리포지토리에서 사용 가능한 Elasticsearch 패키지가 너무 오래되어 작동하지 않으므로 버전 6.x 이상이 필요합니다.

또한 프로덕션 환경에서 전자 우편을 보내기에는 postfix의 기본 설치가 충분하지 않을 수 있습니다. 스팸 및 악의적 인 전자 메일을 피하려면 많은 서버에서 보낸 사람 서버가 보안 확장을 통해 자신을 식별해야합니다. 즉, 최소한 서버와 연결된 도메인 이름이 있어야합니다. 표준 보안 테스트를 통과하도록 이메일 서버를 완전히 구성하는 방법을 배우려면 다음 Digital Ocean 안내서를 참조하십시오.

- [접미사 구성](http://do.co/2FhdIes)
- [SPF 레코드 추가](http://do.co/2Ff8ksk)
- [DKIM 설치 및 구성](http://do.co/2HW2oTD)

## 응용 프로그램 설치

이제 `git`GitHub 리포지토리에서 Microblog 소스 코드를 다운로드하는 데 사용하겠습니다 . git 소스 컨트롤에 익숙하지 않은 경우 [초보자를 위해 git을](http://ryanflorence.com/git-for-beginners/) 읽는 것이 좋습니다 .

응용 프로그램을 서버로 다운로드하려면 `ubuntu`사용자의 홈 디렉토리 에 있는지 확인한 후 다음을 실행하십시오.

```
$ git clone https://github.com/miguelgrinberg/microblog
$ cd microblog
$ git checkout v0.17
```

그러면 서버에 코드가 설치되고이 장과 동기화됩니다. 이 튜토리얼 코드의 버전을 자체 git 저장소에 유지하는 경우 저장소 URL을 사용자의 것으로 변경하고이 경우 `git checkout`명령을 건너 뛸 수 있습니다 .

이제 가상 환경을 생성하고 모든 패키지 종속성으로 채워야합니다.이를 [15 장의 ](https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-xv-a-better-application-structure)*requirements.txt* 파일에 편리하게 저장했습니다 .

```
$ python3 -m venv venv
$ source venv/bin/activate
(venv) $ pip install -r requirements.txt
```

의 일반적인 요구 사항 외에도 *requirements.txt* , 나는 그들이 요구 사항 파일에 포함되지 않도록,이 프로덕션 배포와 관련된 두 가지 패키지를 사용하겠습니다. 이 `gunicorn`패키지는 Python 응용 프로그램을위한 프로덕션 웹 서버입니다. 이 `pymysql`패키지에는 SQLAlchemy가 MySQL 데이터베이스와 작동 할 수 있도록하는 MySQL 드라이버가 포함되어 있습니다.

```
(venv) $ pip install gunicorn pymysql
```

필요한 모든 환경 변수가 포함 된 *.env* 파일 을 만들어야 합니다.

*/home/ubuntu/microblog/.env* : 환경 구성.

```
SECRET_KEY=52cb883e323b48d78a0a36e8e951ba4a
MAIL_SERVER=localhost
MAIL_PORT=25
DATABASE_URL=mysql+pymysql://microblog:<db-password>@localhost:3306/microblog
MS_TRANSLATOR_KEY=<your-translator-key-here>
```

이 *.env* 파일은 [15 장에](https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-xv-a-better-application-structure) 표시된 예와 대부분 비슷 하지만에 임의의 문자열을 사용했습니다 `SECRET_KEY`. 이 임의의 문자열을 생성하기 위해 다음 명령을 사용했습니다.

```
python3 -c "import uuid; print(uuid.uuid4().hex)"
```

를 들어 `DATABASE_URL`변수 I는 MySQL의 URL을 정의했다. 다음 섹션에서 데이터베이스를 구성하는 방법을 보여 드리겠습니다.

명령이 작동 하려면 `FLASK_APP`환경 변수를 응용 프로그램의 진입 점 으로 설정해야 `flask`하지만 *.env* 파일을 구문 분석 하기 전에이 변수가 필요 하므로 수동으로 설정해야합니다. 매번 설정하지 않으려면 계정 의 *~ / .profile* 파일 맨 아래에 추가하여 `ubuntu`로그인 할 때마다 자동으로 설정되도록합니다.

```
$ echo "export FLASK_APP=microblog.py" >> ~/.profile
```

로그 아웃했다가 다시 로그인하면 지금 `FLASK_APP`설정됩니다. 를 실행하여 설정을 확인할 수 있습니다 `flask --help`. 도움말 메시지 `translate`에 응용 프로그램이 추가 한 명령이 표시 되면 응용 프로그램이 발견 된 것입니다.

이제 `flask`명령이 작동하므로 언어 번역을 컴파일 할 수 있습니다.

```
(venv) $ flask translate compile
```

## MySQL 설정

개발 중에 사용한 sqlite 데이터베이스는 간단한 응용 프로그램에는 유용하지만 한 번에 여러 요청을 처리해야 할 수있는 완전한 웹 서버를 배포 할 때는보다 강력한 데이터베이스를 사용하는 것이 좋습니다. 이러한 이유로 저는 호출 할 MySQL 데이터베이스를 설정하려고합니다 `microblog`.

데이터베이스 서버를 관리하기 위해 서버에 `mysql`이미 설치되어 있는 명령 을 사용하겠습니다 .

```
$ mysql -u root -p
Enter password:
Welcome to the MySQL monitor.  Commands end with ; or \g.
Your MySQL connection id is 6
Server version: 5.7.19-0ubuntu0.16.04.1 (Ubuntu)

Copyright (c) 2000, 2017, Oracle and/or its affiliates. All rights reserved.

Oracle is a registered trademark of Oracle Corporation and/or its
affiliates. Other names may be trademarks of their respective
owners.

Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.

mysql>
```

MySQL 명령 프롬프트에 액세스하려면 MySQL을 설치할 때 선택한 MySQL 루트 암호를 입력해야합니다.

다음은이라는 새 데이터베이스를 작성하는 명령 `microblog`과 동일한 이름을 가진 사용자가 데이터베이스에 완전히 액세스 할 수있는 명령입니다.

```
mysql> create database microblog character set utf8 collate utf8_bin;
mysql> create user 'microblog'@'localhost' identified by '<db-password>';
mysql> grant all privileges on microblog.* to 'microblog'@'localhost';
mysql> flush privileges;
mysql> quit;
```

``선택한 비밀번호 로 바꿔야 합니다. 이것은 `microblog`데이터베이스 사용자 의 비밀번호가 되므로 루트 사용자에 대해 선택한 것과 동일한 비밀번호를 사용하지 않는 것이 좋습니다. 에 대한 암호 `microblog`사용자는 당신이에 포함 된 암호와 일치해야합니다 `DATABASE_URL`에서 변수 *은 .env* 파일을.

데이터베이스 구성이 올바른 경우 이제 모든 테이블을 작성하는 데이터베이스 마이그레이션을 실행할 수 있습니다.

```
(venv) $ flask db upgrade
```

계속하기 전에 위의 명령이 오류없이 완료되는지 확인하십시오.

## Gunicorn 및 감독자 설정

로 서버를 실행하면 `flask run`Flask와 함께 제공되는 웹 서버를 사용하게됩니다. 이 서버는 개발 중에 매우 유용하지만 성능 및 견고성을 염두에두고 제작되지 않았으므로 프로덕션 서버에 사용하기에 적합하지 않습니다. Flask 개발 서버 대신이 배포를 위해 순수 Python 웹 서버 인 [gunicorn](http://gunicorn.org/) 을 사용하기로 결정 했지만 Flask와 달리 많은 사람들이 사용하는 강력한 프로덕션 서버이며 동시에 사용하기 매우 쉽습니다.

gunicorn에서 Microblog를 시작하려면 다음 명령을 사용할 수 있습니다.

```
(venv) $ gunicorn -b localhost:8000 -w 4 microblog:app
```

이 `-b`옵션은 요청을 수신 할 위치를 gunicorn에 알려줍니다. 포트 8000에서 내부 네트워크 인터페이스로 설정했습니다. 일반적으로 외부 액세스없이 Python 웹 응용 프로그램을 실행 한 다음 서비스에 최적화 된 매우 빠른 웹 서버를 사용하는 것이 좋습니다 클라이언트의 모든 요청을 수락하는 정적 파일. 이 빠른 웹 서버는 정적 파일을 직접 제공하고 응용 프로그램의 모든 요청을 내부 서버로 전달합니다. 다음 섹션에서 nginx를 공개 서버로 설정하는 방법을 보여 드리겠습니다.

이 `-w`옵션 은 gunicorn이 몇 명의 *작업자* 를 실행 할지 구성합니다 . 작업자가 4 명이면 응용 프로그램이 최대 4 개의 클라이언트를 동시에 처리 할 수 있습니다. 웹 응용 프로그램의 경우 클라이언트가 항상 콘텐츠를 요청하는 것은 아니기 때문에 보통 상당량의 클라이언트를 처리하기에 충분합니다. 서버의 RAM 용량에 따라 메모리가 부족하지 않도록 작업자 수를 조정해야 할 수도 있습니다.

이 `microblog:app`인수는 gunicorn에게 응용 프로그램 인스턴스를로드하는 방법을 알려줍니다. 콜론 앞의 이름은 응용 프로그램을 포함하는 모듈이고 콜론 뒤의 이름은이 응용 프로그램의 이름입니다.

gunicorn은 설정이 매우 간단하지만 명령 줄에서 서버를 실행하는 것은 실제로 프로덕션 서버에는 적합하지 않습니다. 내가하고 싶은 일은 서버가 백그라운드에서 실행되고 지속적으로 모니터링되는 것입니다. 어떤 이유로 서버가 충돌하고 종료되면 새 서버가 자동으로 시작되도록하기 때문입니다. 또한 컴퓨터를 다시 부팅하면 서버를 시작하고 직접 시작할 필요없이 시작시 서버가 자동으로 실행되는지 확인하고 싶습니다. 위에서 설치 한 [수퍼바이저](http://supervisord.org/) 패키지 를 사용 하여이 작업을 수행합니다.

수퍼바이저 유틸리티는 구성 파일을 사용하여 모니터링 할 프로그램과 필요한 경우 다시 시작하는 방법을 알려줍니다. 구성 파일은 */etc/supervisor/conf.d에* 저장해야합니다 . 다음은 *microblog.conf* 라는 Microblog 구성 파일입니다 .

*/etc/supervisor/conf.d/microblog.conf* : 감독자 구성.

```
[program:microblog]
command=/home/ubuntu/microblog/venv/bin/gunicorn -b localhost:8000 -w 4 microblog:app
directory=/home/ubuntu/microblog
user=ubuntu
autostart=true
autorestart=true
stopasgroup=true
killasgroup=true
```

`command`, `directory`및 `user`설정 방법 응용 프로그램을 실행하는 관리자를 말한다. `autostart`및 `autorestart`인해 컴퓨터에 자동 다시 시작 설정은 시작 또는 충돌합니다. `stopasgroup`및 `killasgroup`옵션은 관리자의 요구가 응용 프로그램을 다시 시작 중지 할 때, 그것은 또한 최상위 gunicorn 프로세스의 자식 프로세스에 도달했는지 확인하십시오.

이 구성 파일을 작성한 후에는 수퍼바이저 서비스를 다시로드하여 가져와야합니다.

```
$ sudo supervisorctl reload
```

그리고 그와 마찬가지로 gunicorn 웹 서버가 가동되어 모니터링되고 있어야합니다!

## Nginx 설정

gunicorn이 제공하는 마이크로 블로그 응용 프로그램 서버는 이제 개인 포트 8000을 실행하고 있습니다. 응용 프로그램을 외부 세계에 노출시키기 위해해야 할 일은 공용 포트 웹 서버를 포트 80과 443에서 활성화하는 것입니다. 방화벽은 응용 프로그램의 웹 트래픽을 처리합니다.

이것이 안전한 배포가되기를 원하므로 모든 트래픽을 포트 443으로 전달하도록 포트 80을 구성하려고합니다.이 포트는 암호화 될 것입니다. SSL 인증서를 만드는 것으로 시작하겠습니다. 지금은 *자체 서명 SSL 인증서* 를 만들 것입니다 . 이는 모든 것을 테스트하는 데는 좋지만 실제 배포에는 좋지 않습니다. 웹 브라우저는 사용자에게 신뢰할 수있는 인증 기관에서 인증서가 발급되지 않았다고 경고하므로 사용자에게 경고합니다. 마이크로 블로그 용 SSL 인증서를 작성하는 명령은 다음과 같습니다.

```
$ mkdir certs
$ openssl req -new -newkey rsa:4096 -days 365 -nodes -x509 \
  -keyout certs/key.pem -out certs/cert.pem
```

이 명령은 응용 프로그램과 자신에 대한 정보를 요청합니다. 이것은 SSL 인증서에 포함될 정보이며, 웹 브라우저는 사용자에게 인증서를 요청하면 표시합니다. 위의 명령의 결과라는 두 개의 파일이 될 것입니다 *key.pem* 및 *cert.pem* 나는에 배치 *된 인증서* 마이크로 블로그 루트 디렉토리의 하위 디렉토리.

nginx가 제공하는 웹 사이트를 가지려면 해당 구성 파일을 작성해야합니다. 대부분의 nginx 설치에서이 파일은 */ etc / nginx / sites-enabled* 디렉토리에 있어야합니다 . Nginx는 실제로 필요하지 않은이 위치에 테스트 사이트를 설치하므로 제거해야합니다.

```
$ sudo rm /etc/nginx/sites-enabled/default
```

아래는 */ etc / nginx / sites-enabled / microblog에* 있는 Microblog의 nginx 구성 파일을 볼 수 있습니다 .

*/ etc / nginx / sites-enabled / microblog* : Nginx 구성.

```
server {
    # listen on port 80 (http)
    listen 80;
    server_name _;
    location / {
        # redirect any requests to the same URL but on https
        return 301 https://$host$request_uri;
    }
}
server {
    # listen on port 443 (https)
    listen 443 ssl;
    server_name _;

    # location of the self-signed SSL certificate
    ssl_certificate /home/ubuntu/microblog/certs/cert.pem;
    ssl_certificate_key /home/ubuntu/microblog/certs/key.pem;

    # write access and error logs to /var/log
    access_log /var/log/microblog_access.log;
    error_log /var/log/microblog_error.log;

    location / {
        # forward application requests to the gunicorn server
        proxy_pass http://localhost:8000;
        proxy_redirect off;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    }

    location /static {
        # handle static files directly, without forwarding to the application
        alias /home/ubuntu/microblog/app/static;
        expires 30d;
    }
}
```

nginx 구성은 사소한 것이 아니지만 적어도 각 섹션의 기능을 알 수 있도록 몇 가지 주석을 추가했습니다. 특정 지시문에 대한 정보가 필요하면 [nginx 공식 문서를](https://nginx.org/en/docs/) 참조하십시오 .

이 파일을 추가 한 후에는 nginx에 구성을 다시로드하여 활성화하도록 지시해야합니다.

```
$ sudo service nginx reload
```

이제 응용 프로그램을 배포해야합니다. 웹 브라우저에서 서버의 IP 주소 (또는 Vagrant VM을 사용하는 경우 192.168.33.10)를 입력하면 응용 프로그램에 연결됩니다. 자체 서명 된 인증서를 사용하고 있으므로 웹 브라우저에서 경고 메시지가 표시되며,이 경고를 해제해야합니다.

자신의 프로젝트에 대한 위의 지침으로 배포를 완료 한 후 브라우저가 사용자에게 사이트에 대해 경고하지 않도록 자체 서명 된 인증서를 실제 인증서로 바꾸는 것이 좋습니다. 이를 위해서는 먼저 도메인 이름을 구입하고 서버의 IP 주소를 가리 키도록 구성해야합니다. 도메인이 있으면 무료 SSL 인증서 [암호화](https://letsencrypt.org/) 인증서를 요청할 수 있습니다 . [HTTPS를 통해 Flask 응용 프로그램](https://blog.miguelgrinberg.com/post/running-your-flask-application-over-https) 을 [실행](https://blog.miguelgrinberg.com/post/running-your-flask-application-over-https) 하는 방법에 대한 자세한 기사를 내 블로그에 작성했습니다 .

## 응용 프로그램 업데이트 배포

Linux 기반 배포와 관련하여 마지막으로 논의하고자하는 주제는 응용 프로그램 업그레이드를 처리하는 방법입니다. 애플리케이션 소스 코드는를 통해 서버에 설치 `git`되므로 애플리케이션을 최신 버전으로 업그레이드 할 때마다 `git pull`이전 배치 이후 작성된 새 커밋을 다운로드하기 위해 실행할 수 있습니다 .

그러나 새 버전의 코드를 다운로드해도 업그레이드되지는 않습니다. 현재 실행중인 서버 프로세스는 메모리에서 이미 읽고 저장된 이전 코드로 계속 실행됩니다. 업그레이드를 시작하려면 현재 서버를 중지하고 새 서버를 시작하여 모든 코드를 다시 읽도록해야합니다.

업그레이드는 일반적으로 서버를 다시 시작하는 것보다 더 복잡합니다. 데이터베이스 마이그레이션을 적용하거나 새 언어 번역을 컴파일해야 할 수도 있으므로 실제로 업그레이드를 수행하는 프로세스에는 일련의 명령이 포함됩니다.

```
(venv) $ git pull                              # download the new version
(venv) $ sudo supervisorctl stop microblog     # stop the current server
(venv) $ flask db upgrade                      # upgrade the database
(venv) $ flask translate compile               # upgrade the translations
(venv) $ sudo supervisorctl start microblog    # start a new server
```

## 라즈베리 파이 호스팅

[라즈베리 파이는](http://www.raspberrypi.org/) 이 데스크톱 컴퓨터 또는 노트북을 묶는없이 온라인으로 24 시간을 될 수있는 가정 기반의 웹 서버를 호스트 할 수있는 완벽한 장치입니다, 그래서 매우 낮은 전력 소모가 저가의 혁명적 인 작은 리눅스 컴퓨터입니다. Raspberry Pi에서 실행되는 여러 Linux 배포판이 있습니다. 저는 Raspberry Pi Foundation의 공식 배포판 인 [Raspbian을](http://www.raspbian.org/) 선택했습니다 .

Raspberry Pi를 준비하기 위해 새로운 Raspbian 릴리스를 설치하겠습니다. 2017 년 9 월 Raspbian Stretch Lite 버전을 사용하지만이 기사를 읽을 때 최신 버전이 출시 될 가능성이 있으므로 공식 [다운로드 페이지](https://www.raspberrypi.org/downloads/raspbian/) 에서 최신 버전을 확인하십시오 .

Raspbian 이미지는 SD 카드에 설치해야합니다. 그런 다음 Raspberry Pi에 연결하여 부팅 할 수 있습니다. Windows, Mac OS X 및 Linux에서 Raspbian 이미지를 SD 카드로 복사하는 방법은 [Raspberry Pi 사이트](https://www.raspberrypi.org/documentation/installation/installing-images/) 에서 확인할 수 [있습니다](https://www.raspberrypi.org/documentation/installation/installing-images/) .

Raspberry Pi를 처음 부팅 할 때 키보드와 모니터에 연결된 상태에서 부팅하면 설정을 수행 할 수 있습니다. 최소한 컴퓨터에서 로그인하여 배포 작업을보다 편안하게 수행 할 수 있도록 SSH를 활성화해야합니다.

우분투와 마찬가지로, Raspbian은 데비안의 파생물이므로, Ubuntu Linux에 대한 위의 지침은 대부분 Raspberry Pi에서도 작동합니다. 그러나 외부 액세스없이 홈 네트워크에서 작은 응용 프로그램을 실행하려는 경우 일부 단계를 건너 뛸 수 있습니다. 예를 들어, 방화벽이나 암호가없는 로그인이 필요하지 않을 수 있습니다. 그런 작은 컴퓨터에서는 MySQL 대신 SQLite를 사용할 수 있습니다. nginx를 사용하지 않고 gunicorn 서버가 클라이언트의 요청을 직접 수신하도록 선택할 수 있습니다. 아마 한 명의 유니콘 작업자 만 원할 것입니다. 수퍼바이저 서비스는 응용 프로그램이 항상 작동하도록하는 데 유용하므로 Raspberry Pi에서도 사용하는 것이 좋습니다.



## [Part XVIII: Deployment on Heroku](https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-xviii-deployment-on-heroku)

이것은 Flask Mega-Tutorial 시리즈의 18 번째 버전으로, Microku를 Heroku 클라우드 플랫폼에 배포 할 예정입니다.

이전 기사에서는 Python 응용 프로그램을 호스팅하는 "전통적인"방법을 보여 주었으며 Linux 기반 서버에 실제로 배포하는 두 가지 예를 제시했습니다. Linux 시스템을 관리하는 데 익숙하지 않은 경우 작업에 투입해야하는 노력의 양이 많고 더 쉬운 방법이 있어야한다고 생각했을 것입니다.

이 장에서는 완전히 다른 접근 방식을 보여 드리겠습니다.이 방법은 대부분의 관리 작업을 수행하기 위해 타사 *클라우드* 호스팅 제공 업체에 의존하므로 애플리케이션 작업에 더 많은 시간을 할애 할 수 있습니다.

많은 클라우드 호스팅 제공 업체는 애플리케이션을 실행할 수있는 관리 형 플랫폼을 제공합니다. 하드웨어, 운영 체제, 스크립팅 언어 해석기, 데이터베이스 등이 모두 서비스에 의해 관리되므로 이러한 플랫폼에 응용 프로그램을 배포하기 위해 제공해야 할 것은 실제 응용 프로그램입니다. 이 유형의 서비스를 [Platform as a Service](https://en.wikipedia.org/wiki/Platform_as_a_service) 또는 PaaS라고합니다.

사실 너무 좋은 소리?

Python 애플리케이션에도 매우 친숙한 인기있는 클라우드 호스팅 서비스 인 [Heroku에](http://heroku.com/) Microblog를 배포하는 방법을 살펴 보겠습니다 . Heroku는 인기가있을뿐만 아니라 무료 서비스 수준을 가지고 있기 때문에 나를 따를 수 있고 돈을 쓰지 않고도 완벽한 배치를 할 수 있기 때문에 Heroku를 선택했습니다.

*이 장의 GitHub 링크는 [Browse](https://github.com/miguelgrinberg/microblog/tree/v0.18) , [Zip](https://github.com/miguelgrinberg/microblog/archive/v0.18.zip) , [Diff](https://github.com/miguelgrinberg/microblog/compare/v0.17...v0.18) 입니다.*

## Heroku에서 호스팅

헤 로쿠는 서비스 제공 업체로서 최초의 플랫폼 중 하나였습니다. Ruby 기반 애플리케이션의 호스팅 옵션으로 시작했지만 Java, Node.js 및 물론 Python과 같은 다른 많은 언어를 지원하도록 성장했습니다.

`git`버전 관리 도구를 통해 Heroku에 웹 응용 프로그램을 배포 할 수 있으므로 응용 프로그램을 git 리포지토리에 있어야합니다. Heroku는 응용 프로그램을 시작하는 방법에 대한 지침을 보려면 응용 프로그램의 루트 디렉토리에서 *Procfile* 이라는 파일을 찾습니다 . Python 프로젝트의 경우 Heroku는 설치해야하는 모든 모듈 종속성을 나열 하는 *requirements.txt* 파일 도 예상합니다 . 응용 프로그램이 git을 통해 Heroku 서버에 업로드되면 기본적으로 완료되며 응용 프로그램이 온라인 상태가 될 때까지 몇 초 정도 기다려야합니다. 정말 간단합니다.

Heroku가 제공하는 다양한 서비스 계층을 사용하면 응용 프로그램에 필요한 컴퓨팅 성능과 시간을 선택할 수 있으므로 사용자층이 증가함에 따라 Heroku는 "dynos"라고하는 더 많은 컴퓨팅 장치를 구입해야합니다.

헤 로쿠를 사용할 준비가 되셨습니까? 시작하자!

## Heroku 계정 만들기

Heroku에 배포하려면 먼저 계정을 가지고 있어야합니다. [heroku.com을](https://id.heroku.com/signup) 방문 하여 무료 계정을 만드십시오. 계정이 있고 Heroku에 로그인하면 모든 애플리케이션이 나열된 대시 보드에 액세스 할 수 있습니다.

## Heroku CLI 설치

Heroku는 Windows, Mac OS X 및 Linux에서 사용 가능한 [Heroku CLI](https://devcenter.heroku.com/articles/heroku-cli) 라는 서비스와 상호 작용하기위한 명령 줄 도구를 제공 합니다. 설명서에는 지원되는 모든 플랫폼에 대한 설치 지침이 포함되어 있습니다. 서비스를 테스트하기 위해 애플리케이션을 배치 할 계획이면 시스템에 설치하십시오.

CLI가 설치되면 가장 먼저해야 할 일은 Heroku 계정에 로그인하는 것입니다.

```
$ heroku login
```

Heroku CLI는 이메일 주소와 계정 비밀번호를 입력하라는 메시지를 표시합니다. 인증 된 상태는 후속 명령에서 기억됩니다.

## 힘내 설정

이 `git`도구는 Heroku에 응용 프로그램을 배포하기위한 핵심 요소이므로 아직 설치하지 않은 경우 시스템에 설치해야합니다. 운영 체제에 사용할 수있는 패키지가없는 경우 [git 사이트](https://git-scm.com/) 를 방문하여 설치 프로그램을 다운로드 할 수 있습니다 .

`git`프로젝트에 사용하는 것이 많은 이유 가 있습니다. Heroku에 배포하려는 경우 Heroku에 배포하기 때문에 응용 프로그램이 `git`저장소에 있어야하므로 하나 더 있습니다 . Microblog 용 테스트 배포를 수행하려는 경우 GitHub에서 애플리케이션을 복제 할 수 있습니다.

```
$ git clone https://github.com/miguelgrinberg/microblog
$ cd microblog
$ git checkout v0.18
```

이 `git checkout`명령은 히스토리에서이 장에 해당하는 애플리케이션이있는 특정 커밋을 선택합니다.

대신 내 자신의 코드와 함께 작업하는 것을 선호하는 경우, 당신은에 자신의 프로젝트를 변환 할 수 있습니다 `git`실행하여 저장소 `git init .`최상위 디렉토리에 (후 기간에 유의 `init`현재 디렉토리에 저장소를 작성하려는 자식을 알려줍니다, ).

## Heroku 응용 프로그램 만들기

Heroku에 새 응용 프로그램을 등록하려면 응용 프로그램 `apps:create`의 루트 디렉토리에있는 명령 을 사용 하여 응용 프로그램 이름을 유일한 인수로 전달하십시오.

```
$ heroku apps:create flask-microblog
Creating flask-microblog... done
http://flask-microblog.herokuapp.com/ | https://git.heroku.com/flask-microblog.git
```

Heroku는 응용 프로그램의 이름이 고유해야합니다. `flask-microblog`위에서 사용한 이름 은 사용 중이므로 사용할 수 없으므로 배포에 다른 이름을 선택해야합니다.

이 명령의 출력에는 Heroku가 응용 프로그램에 할당 한 URL과 git 리포지토리가 포함됩니다. 로컬 git 저장소는 이라는 추가 *리모컨* 으로 구성됩니다 `heroku`. 다음 `git remote`명령으로 존재하는지 확인할 수 있습니다 .

```
$ git remote -v
heroku  https://git.heroku.com/flask-microblog.git (fetch)
heroku  https://git.heroku.com/flask-microblog.git (push)
```

git 리포지토리를 생성 한 방법에 따라 위 명령의 출력에라는 다른 리모트가 포함될 수도 있습니다 `origin`.

## 임시 파일 시스템

Heroku 플랫폼은 가상화 플랫폼에서 실행 되는 *임시* 파일 시스템을 갖추고 있다는 점에서 다른 배포 플랫폼과 다릅니다 . 그게 무슨 뜻이야? 즉, Heroku는 언제든지 서버가 실행되는 가상 서버를 깨끗한 상태로 재설정 할 수 있습니다. 파일 시스템에 저장 한 데이터가 지속될 것이라고 생각할 수 없으며 실제로 Heroku는 서버를 매우 자주 재활용합니다.

이러한 조건에서 작업하면 응용 프로그램에 몇 가지 파일을 사용하는 몇 가지 문제가 발생합니다.

- 기본 SQLite 데이터베이스 엔진은 디스크 파일에 데이터를 씁니다.
- 응용 프로그램에 대한 로그도 파일 시스템에 기록됩니다
- 컴파일 된 언어 번역 리포지토리도 로컬 파일에 기록됩니다

다음 섹션에서는이 세 가지 영역에 대해 설명합니다.

## Heroku Postgres 데이터베이스 작업

첫 번째 문제를 해결하기 위해 다른 데이터베이스 엔진으로 전환하겠습니다. 에서 [17 장](https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-xvii-deployment-on-linux) 당신이 날 우분투 배포 견고성을 추가하기 위해 MySQL 데이터베이스를 사용했다. Heroku는 Postgres 데이터베이스를 기반으로 자체 데이터베이스를 제공하므로 파일 기반 SQLite를 피하기 위해 해당 데이터베이스로 전환하겠습니다.

Heroku 애플리케이션 용 데이터베이스는 동일한 Heroku CLI로 프로비저닝됩니다. 이 경우 프리 티어에서 데이터베이스를 작성합니다.

```
$ heroku addons:add heroku-postgresql:hobby-dev
Creating heroku-postgresql:hobby-dev on flask-microblog... free
Database has been created and is available
 ! This database is empty. If upgrading, you can transfer
 ! data from another database with pg:copy
Created postgresql-parallel-56076 as DATABASE_URL
Use heroku addons:docs heroku-postgresql to view documentation
```

새로 작성된 데이터베이스의 URL `DATABASE_URL`은 애플리케이션이 실행될 때 사용 가능한 환경 변수에 저장 됩니다. 애플리케이션은 이미 해당 변수에서 데이터베이스 URL을 찾기 때문에 매우 편리합니다.

## stdout에 로깅

Heroku는 응용 프로그램이 직접 로그인 할 것으로 예상합니다 `stdout`. `heroku logs`명령 을 사용하면 응용 프로그램이 표준 출력으로 인쇄하는 모든 내용이 저장되고 반환됩니다 . 그래서 내가 `stdout`하고있는 것처럼 파일 에 로그인 해야하는지 또는 파일에 표시 해야하는지 나타내는 구성 변수를 추가 할 것입니다. 구성 변경은 다음과 같습니다.

*config.py* : stdout에 로그하는 옵션.

```
class Config(object):
    # ...
    LOG_TO_STDOUT = os.environ.get('LOG_TO_STDOUT')
```

그런 다음 응용 프로그램 팩토리 기능에서 응용 프로그램 로거를 구성하는 방법을 알기 위해이 구성을 확인할 수 있습니다.

*app / __ init__.py* : stdout 또는 파일에 로그하십시오.

```
def create_app(config_class=Config):
    # ...
    if not app.debug and not app.testing:
        # ...

        if app.config['LOG_TO_STDOUT']:
            stream_handler = logging.StreamHandler()
            stream_handler.setLevel(logging.INFO)
            app.logger.addHandler(stream_handler)
        else:
            if not os.path.exists('logs'):
                os.mkdir('logs')
            file_handler = RotatingFileHandler('logs/microblog.log',
                                               maxBytes=10240, backupCount=10)
            file_handler.setFormatter(logging.Formatter(
                '%(asctime)s %(levelname)s: %(message)s '
                '[in %(pathname)s:%(lineno)d]'))
            file_handler.setLevel(logging.INFO)
            app.logger.addHandler(file_handler)

        app.logger.setLevel(logging.INFO)
        app.logger.info('Microblog startup')

    return app
```

이제 `LOG_TO_STDOUT`응용 프로그램이 Heroku에서 실행될 때 환경 변수 를 설정해야 하지만 다른 구성에서는 그렇지 않습니다. Heroku CLI를 사용하면 런타임에 사용할 환경 변수를 설정할 수있는 옵션이 제공되므로이를 쉽게 수행 할 수 있습니다.

```
$ heroku config:set LOG_TO_STDOUT=1
Setting LOG_TO_STDOUT and restarting flask-microblog... done, v4
LOG_TO_STDOUT: 1
```

## 컴파일 된 번역

로컬 파일에 의존하는 Microblog의 세 번째 측면은 컴파일 된 언어 변환 파일입니다. 임시 파일 시스템에서 해당 파일이 사라지지 않도록하는보다 직접적인 옵션은 컴파일 된 언어 파일을 git 리포지토리에 추가하여 Heroku에 배포 된 후 응용 프로그램의 초기 상태의 일부가되는 것입니다.

내 생각에 더 우아한 옵션은 `flask translate compile`Heroku에 제공된 시작 명령에 명령 을 포함 시켜 서버를 다시 시작할 때마다 해당 파일이 다시 컴파일되도록하는 것입니다. 데이터베이스 마이그레이션도 실행해야하므로 시작 절차에 둘 이상의 명령이 필요하다는 것을 알고 있으므로이 옵션을 사용하겠습니다. 그래서 지금은이 문제를 제쳐 놓고 나중에 *Procfile을* 작성할 때 다시 살펴볼 것 입니다.

## Elasticsearch 호스팅

Elasticsearch는 Heroku 프로젝트에 추가 할 수있는 많은 서비스 중 하나이지만 Postgres와는 달리이 서비스는 Heroku에서 제공하는 서비스가 아니라 Heroku와 제휴하여 애드온을 제공하는 타사에서 제공합니다. 이 글을 쓰는 시점에는 통합 Elasticsearch 서비스를 제공하는 세 가지 다른 제공자가 있습니다.

Elasticsearch를 구성하기 전에 무료 계층 내에 있더라도 Heroku를 사용하려면 타사 애드온을 설치하기 전에 계정에 신용 카드가 있어야합니다. Heroku에 신용 카드를 제공하지 않으려면이 섹션을 건너 뛰십시오. 여전히 응용 프로그램을 배포 할 수는 있지만 검색 기능이 작동하지 않습니다.

추가 기능으로 제공되는 Elasticsearch 옵션 중에서 무료 시작 계획과 함께 제공되는 [SearchBox를 사용](https://elements.heroku.com/addons/searchbox) 하기로 결정했습니다 . 계정에 SearchBox를 추가하려면 Heroku에 로그인 한 상태에서 다음 명령을 실행해야합니다.

```
$ heroku addons:create searchbox:starter
```

이 명령은 Elasticsearch 서비스를 배포하고 서비스의 연결 URL을 `SEARCHBOX_URL`애플리케이션과 연결된 환경 변수 에 그대로 둡니다 . Heroku 계정에 신용 카드를 추가하지 않으면이 명령이 실패합니다.

[16 장](https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-xvi-full-text-search) 을 기억한다면 , 내 애플리케이션은 `ELASTICSEARCH_URL`변수 에서 Elasticsearch 연결 URL을 찾으 므로이 변수를 추가하고 SearchBox에서 할당 한 연결 URL로 설정해야합니다.

```
$ heroku config:get SEARCHBOX_URL
<your-elasticsearch-url>
$ heroku config:set ELASTICSEARCH_URL=<your-elasticsearch-url>
```

여기에서 먼저 Heroku에게 값을 인쇄하도록 요청한 `SEARCHBOX_URL`다음 이름 `ELASTICSEARCH_URL`이 같은 값으로 설정된 새로운 환경 변수를 추가했습니다 .

## 요구 사항 업데이트

Heroku는 의존성이 [15 장](https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-xv-a-better-application-structure) 에서 정의한 것처럼 *requirements.txt* 파일 에있을 것으로 예상합니다 . 그러나 응용 프로그램을 Heroku에서 실행하려면이 파일에 두 가지 새로운 종속성을 추가해야합니다.

Heroku는 자체 웹 서버를 제공하지 않습니다. 대신 응용 프로그램이 환경 변수에 지정된 포트 번호에서 자체 웹 서버를 시작할 것으로 예상합니다 `$PORT`. Flask 개발 웹 서버는 프로덕션 환경에 사용할만큼 강력하지 않기 때문에 Heroku가 Python 애플리케이션에 권장하는 서버 인 [gunicorn을](http://gunicorn.org/) 다시 사용 [하겠습니다](http://gunicorn.org/) .

응용 프로그램도 Postgres 데이터베이스에 연결되며 해당 SQLAlchemy를 사용하려면 `psycopg2`패키지를 설치 해야합니다 .

모두 `gunicorn`와 `psycopg2`필요가에 추가 할 *requirements.txt의* 파일.

## 프로필

Heroku는 응용 프로그램을 실행하는 방법을 알아야하며 응용 프로그램 의 루트 디렉토리에 *Procfile* 이라는 파일을 사용합니다 . 이 파일의 형식은 간단하며 각 줄에는 프로세스 이름, 콜론 및 프로세스를 시작하는 명령이 포함됩니다. Heroku에서 실행되는 가장 일반적인 유형의 응용 프로그램은 웹 응용 프로그램이며이 유형의 응용 프로그램의 경우 프로세스 이름은이어야합니다 `web`. 아래 는 마이크로 블로그 용 *Procfile* 입니다.

*Procfile* : Heroku Procfile.

```
web: flask db upgrade; flask translate compile; gunicorn microblog:app
```

여기서는 웹 응용 프로그램을 시작하는 명령을 순서대로 세 개의 명령으로 정의했습니다. 먼저 데이터베이스 마이그레이션 업그레이드를 실행 한 다음 언어 번역을 컴파일하고 마지막으로 서버를 시작합니다.

처음 두 개의 하위 명령은 명령을 기반으로하기 `flask`때문에 `FLASK_APP`환경 변수 를 추가해야 합니다.

```
$ heroku config:set FLASK_APP=microblog.py
Setting FLASK_APP and restarting flask-microblog... done, v4
FLASK_APP: microblog.py
```

이 응용 프로그램은 또한 이메일 서버 또는 실시간 번역을위한 토큰을 구성하는 환경과 같은 다른 환경 변수에 의존합니다. 추가 `heroku config:set`명령 으로 추가해야 합니다.

```
gunicorn`명령이 서버가 Heroku가 환경과 매우 좋은 통합을 가지고 있기 때문에 나는 우분투 배포에 사용하는 것보다 간단합니다. 예를 들어, `$PORT`환경 변수는 기본적으로 적용되며, `-w`작업자 수를 설정 하는 옵션을 사용하는 대신 , 제공되지 않을 때 사용 `WEB_CONCURRENCY`되는 이라는 변수를 추가하는 것이 좋습니다. Procfile을 수정합니다.`gunicorn``-w
```

## 응용 프로그램 배포

모든 준비 단계가 완료되었으므로 이제 배포를 실행할 차례입니다. 배포를 위해 응용 프로그램을 Heroku 서버에 업로드하려면 `git push`명령이 사용됩니다. 이것은 로컬 git 저장소의 변경 사항을 GitHub 또는 다른 원격 git 서버로 푸시하는 방법과 유사합니다.

그리고 이제 가장 흥미로운 부분에 도달하여 Heroku 호스팅 계정으로 응용 프로그램을 푸시합니다. 이것은 실제로 매우 간단 `git`합니다. 응용 프로그램을 Heroku git 저장소의 마스터 브랜치로 푸시하는 데 사용해야 합니다. git 저장소를 생성 한 방법에 따라이 작업을 수행하는 방법에는 몇 가지 변형이 있습니다. 내 `v0.18`코드를 사용하는 경우이 태그를 기반으로 분기를 만들고 다음과 같이 원격 마스터 분기로 푸시해야합니다.

```
$ git checkout -b deploy
$ git push heroku deploy:master
```

대신 자신의 저장소로 작업하는 경우 코드가 이미 `master`지점에 있으므로 변경 사항이 커밋되었는지 확인해야합니다.

```
$ git commit -a -m "heroku deployment changes"
```

그런 다음 다음을 실행하여 배포를 시작할 수 있습니다.

```
$ git push heroku master
```

지점을 어떻게 푸시하든 관계없이 Heroku의 다음 출력이 표시됩니다.

```
$ git push heroku deploy:master
Counting objects: 247, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (238/238), done.
Writing objects: 100% (247/247), 53.26 KiB | 3.80 MiB/s, done.
Total 247 (delta 136), reused 3 (delta 0)
remote: Compressing source files... done.
remote: Building source:
remote:
remote: -----> Python app detected
remote: -----> Installing python-3.6.2
remote: -----> Installing pip
remote: -----> Installing requirements with pip
...
remote:
remote: -----> Discovering process types
remote:        Procfile declares types -> web
remote:
remote: -----> Compressing...
remote:        Done: 57M
remote: -----> Launching...
remote:        Released v5
remote:        https://flask-microblog.herokuapp.com/ deployed to Heroku
remote:
remote: Verifying deploy... done.
To https://git.heroku.com/flask-microblog.git
 * [new branch]      deploy -> master
```

명령 `heroku`에서 사용한 레이블 `git push`은 응용 프로그램을 만들 때 Heroku CLI에 의해 자동으로 추가 된 리모컨입니다. `deploy:master`인수 수단은 나는이 참조하는 로컬 저장소에서 코드 밀어 해요 있음을 `deploy`받는 지점 `master`Heroku가 저장소에 지점을. 자신의 프로젝트로 작업 할 때 명령 `git push heroku master`을 사용하여 로컬 `master`지점 을 밀어 넣을 수 있습니다 . 이 프로젝트가 구성되는 방식 때문에 나는 아닌 지점을 추진하고 `master`있지만 Heroku 측의 대상 지점은 항상 `master`Heroku가 배포를 위해 수락하는 유일한 지점 이어야 합니다.

즉, 이제 응용 프로그램을 만든 명령의 출력에 지정된 URL에 응용 프로그램을 배포해야합니다. 필자의 경우 URL은 *https://flask-microblog.herokuapp.com* 이므로 응용 프로그램에 액세스하려면 입력해야합니다.

실행중인 응용 프로그램의 로그 항목을 보려면 `heroku logs`명령을 사용하십시오 . 어떤 이유로 든 응용 프로그램이 시작되지 않는 경우에 유용 할 수 있습니다. 오류가있는 경우 오류가 로그에 있습니다.

## 응용 프로그램 업데이트 배포

새 버전의 응용 프로그램을 배포하려면 `git push`새 코드로 새 명령 을 실행하면 됩니다. 이렇게하면 배포 프로세스가 반복되고 이전 배포가 오프라인 상태로 된 다음 새 코드로 바뀝니다. Procfile의 명령은 새 배치의 일부로 다시 실행되므로 프로세스 중에 새 데이터베이스 마이그레이션 또는 변환이 업데이트됩니다.



## [Part XIX: Deployment on Docker Containers](https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-xix-deployment-on-docker-containers)

이것은 Flask Mega-Tutorial 시리즈의 아홉 번째로, Docker 컨테이너 플랫폼에 Microblog를 배포 할 예정입니다.

[17 장](https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-xvii-deployment-on-linux) 에서는 서버 구성의 모든 작은 부분을 처리해야하는 기존 배포에 대해 배웠습니다. 그런 다음 [18 장](https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-xviii-deployment-on-heroku) 에서는 구성 및 배포 작업을 완전히 제어하여 응용 프로그램에 전적으로 집중할 수있는 서비스 인 Heroku를 소개 할 때 다른 극단으로 안내했습니다. 이 장에서는 *컨테이너* , 특히 [Docker](https://www.docker.com/) 컨테이너 플랫폼을 기반으로하는 세 번째 애플리케이션 배포 전략에 대해 설명합니다 . 이 세 번째 옵션은 사용자에게 필요한 배포 작업량 측면에서 다른 두 옵션 사이에 있습니다.

컨테이너는 경량 가상화 기술을 기반으로 구축되어 응용 프로그램과 해당 종속성 및 구성을 완전히 격리 된 상태로 실행할 수 있지만 가상 시스템과 같이 완전히 더 많은 가상화 솔루션을 사용할 필요가 없습니다. 호스트에 비해 성능이 크게 저하됩니다. 컨테이너 호스트로 구성된 시스템은 많은 컨테이너를 실행할 수 있으며 모든 컨테이너는 호스트의 커널을 공유하고 호스트 하드웨어에 직접 액세스합니다. 이는 CPU, 디스크, 기타 하드웨어, 커널 등을 포함한 완전한 시스템을 에뮬레이트해야하는 가상 머신과 대조적입니다.

커널을 공유해야하지만 컨테이너의 격리 수준은 매우 높습니다. 컨테이너에는 자체 파일 시스템이 있으며 컨테이너 호스트에서 사용하는 운영 체제와 다른 운영 체제를 기반으로 할 수 있습니다. 예를 들어, Fedora 호스트에서 Ubuntu Linux 기반 컨테이너를 실행할 수 있으며 그 반대도 가능합니다. 컨테이너는 Linux 운영 체제 고유의 기술이지만 가상화 덕분에 Windows 및 Mac OS X 호스트에서 Linux 컨테이너를 실행할 수도 있습니다. 이를 통해 개발 시스템에서 배포를 테스트하고 원하는 경우 개발 워크 플로에 컨테이너를 통합 할 수 있습니다.

*이 장의 GitHub 링크는 [Browse](https://github.com/miguelgrinberg/microblog/tree/v0.19) , [Zip](https://github.com/miguelgrinberg/microblog/archive/v0.19.zip) , [Diff](https://github.com/miguelgrinberg/microblog/compare/v0.18...v0.19) 입니다.*

## Docker CE 설치

Docker가 유일한 컨테이너 플랫폼은 아니지만 지금까지 가장 인기가 많으므로 이것이 나의 선택이 될 것입니다. Docker에는 무료 커뮤니티 에디션 (CE)과 가입 기반 엔터프라이즈 에디션 (EE)의 두 가지 에디션이 있습니다. 이 튜토리얼의 목적 상 Docker CE는 완벽하게 적합합니다.

Docker CE를 사용하려면 먼저 시스템에 설치해야합니다. [Docker 웹 사이트](https://www.docker.com/community-edition) 에는 Windows, Mac OS X 및 여러 Linux 배포판 용 설치 프로그램이 있습니다 . Microsoft Windows 시스템에서 작업하는 경우 Docker CE에는 Hyper-V가 필요합니다. 설치 프로그램이 필요한 경우이 기능을 활성화하지만 Hyper-V를 활성화하면 VirtualBox와 같은 다른 가상화 기술이 작동하지 않습니다.

Docker CE가 시스템에 설치되면 터미널 창 또는 명령 프롬프트에 다음 명령을 입력하여 설치가 성공했는지 확인할 수 있습니다.

```
$ docker version
Client:
 Version:      17.09.0-ce
 API version:  1.32
 Go version:   go1.8.3
 Git commit:   afdb6d4
 Built:        Tue Sep 26 22:40:09 2017
 OS/Arch:      darwin/amd64

Server:
 Version:      17.09.0-ce
 API version:  1.32 (minimum version 1.12)
 Go version:   go1.8.3
 Git commit:   afdb6d4
 Built:        Tue Sep 26 22:45:38 2017
 OS/Arch:      linux/amd64
 Experimental: true
```

## 컨테이너 이미지 빌드

마이크로 블로그 용 컨테이너를 만드는 첫 번째 단계는 *이미지* 를 만드는 것입니다. 컨테이너 이미지는 컨테이너를 만드는 데 사용되는 템플릿입니다. 컨테이너 파일 시스템의 완전한 표현과 네트워킹, 시작 옵션 등에 관한 다양한 설정을 포함합니다.

응용 프로그램의 컨테이너 이미지를 만드는 가장 기본적인 방법은 사용하려는 기본 운영 체제 (Ubuntu, Fedora 등)의 컨테이너를 시작하고 실행중인 bash 셸 프로세스에 연결 한 다음 수동으로 설치하는 것입니다. 기존 배포에 대해서는 [17 장](https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-xvii-deployment-on-linux) 에서 제시 한 지침을 따를 수 있습니다. 모든 것을 설치 한 후 컨테이너의 스냅 샷을 찍을 수 있으며 이미지가됩니다. 이 유형의 워크 플로는 `docker`명령에서 지원 되지만 새 이미지를 생성해야 할 때마다 응용 프로그램을 수동으로 설치하는 것이 편리하지 않기 때문에이 작업 과정에 대해서는 다루지 않겠습니다.

더 나은 방법은 스크립트를 통해 컨테이너 이미지를 생성하는 것입니다. 스크립트 컨테이너 이미지를 생성하는 명령은 `docker build`입니다. 이 명령은 *Dockerfile* 이라는 파일에서 빌드 명령을 읽고 실행합니다.이 명령은 작성해야합니다. Dockerfile은 기본적으로 설치 단계를 실행하여 응용 프로그램을 배포하고 일부 컨테이너 특정 설정을 실행하는 일종의 설치 관리자 스크립트입니다.

다음은 Microblog 의 기본 *Dockerfile* 입니다.

*Dockerfile* : 마이크로 블로그 용 Dockerfile

```
FROM python:3.6-alpine

RUN adduser -D microblog

WORKDIR /home/microblog

COPY requirements.txt requirements.txt
RUN python -m venv venv
RUN venv/bin/pip install -r requirements.txt
RUN venv/bin/pip install gunicorn

COPY app app
COPY migrations migrations
COPY microblog.py config.py boot.sh ./
RUN chmod +x boot.sh

ENV FLASK_APP microblog.py

RUN chown -R microblog:microblog ./
USER microblog

EXPOSE 5000
ENTRYPOINT ["./boot.sh"]
```

Dockerfile의 각 줄은 명령입니다. 이 `FROM`명령은 새 이미지가 빌드 될 기본 컨테이너 이미지를 지정합니다. 아이디어는 기존 이미지에서 시작하여 일부를 추가 또는 변경하고 파생 이미지로 끝나는 것입니다. 이미지는 콜론으로 구분 된 이름과 태그로 참조됩니다. 태그는 버전 관리 메커니즘으로 사용되어 컨테이너 이미지가 둘 이상의 변형을 제공 할 수 있습니다. 선택한 이미지의 이름은입니다 `python`. 이는 Python의 공식 Docker 이미지입니다. 이 이미지의 태그를 사용하면 운영체제 버전 및 기본 운영 체제를 지정할 수 있습니다. 그만큼`3.6-alpine`tag는 Alpine Linux에 설치된 Python 3.6 인터프리터를 선택합니다. 알파인 리눅스 배포판은 크기가 작기 때문에 우분투와 같은 인기있는 배포본 대신 자주 사용됩니다. [Python 이미지 저장소](https://hub.docker.com/r/library/python/tags/) 에서 Python 이미지에 사용할 수있는 태그를 확인할 수 있습니다 .

이 `RUN`명령은 컨테이너 컨텍스트에서 임의 의 명령을 실행합니다. 이것은 쉘 프롬프트에서 명령을 입력하는 것과 유사합니다. 이 `adduser -D microblog`명령은이라는 이름의 새 사용자를 만듭니다 `microblog`. 대부분의 컨테이너 이미지에는 `root`기본 사용자가 있지만 응용 프로그램을 루트로 실행하는 것은 좋지 않으므로 자신의 사용자를 만듭니다.

이 `WORKDIR`명령은 응용 프로그램을 설치할 기본 디렉토리를 설정합니다. `microblog`위에서 사용자를 만들 때 홈 디렉토리가 만들어 졌으므로 이제는 해당 디렉토리를 기본값으로 만들고 있습니다. 새로운 기본 디렉토리는 Dockerfile의 나머지 모든 명령에 적용되며 나중에 컨테이너가 실행될 때도 적용됩니다.

이 `COPY`명령은 시스템에서 컨테이너 파일 시스템으로 파일을 전송합니다. 이 명령은 둘 이상의 인수 인 소스 및 대상 파일 또는 디렉토리를 사용합니다. 소스 파일은 Dockerfile이있는 디렉토리에 상대적이어야합니다. 대상은 절대 경로이거나 이전 `WORKDIR`명령 에서 설정 한 디렉토리에 대한 상대 경로 일 수 있습니다 . 이 첫 번째 `COPY`명령에서는 *requirements.txt* 파일을 `microblog`컨테이너 파일 시스템 의 사용자 홈 디렉토리에 복사합니다 .

지금은 가지고 *requirements.txt의* 컨테이너 파일을, 나는 사용하여 가상 환경을 만들 수 있습니다 `RUN`명령을 사용합니다. 먼저 그것을 만든 다음 모든 요구 사항을 설치합니다. 요구 사항 파일에는 일반적인 종속성 만 포함되어 있으므로 웹 서버로 사용할 *gunicorn* 을 명시 적으로 설치 합니다. 또는 *requirements.txt* 파일 에 gunicorn을 추가 할 수 있습니다 .

다음에 나오는 세 가지 `COPY`명령은 응용 *프로그램* 패키지, 데이터베이스 마이그레이션 이 포함 된 *마이그레이션* 디렉토리 및 최상위 디렉토리에서 *microblog.py* 및 *config.py* 스크립트를 복사하여 컨테이너에 애플리케이션을 설치합니다 . 또한 아래에서 설명 할 새 파일 인 *boot.sh* 를 복사하고 있습니다.

`RUN chmod`명령이 새로운 보장 *boot.sh의* 파일이 올바르게 실행 파일로 설정됩니다. Unix 기반 파일 시스템에 있고 소스 파일이 이미 실행 가능으로 표시되어 있으면 복사 된 파일에도 실행 가능 비트가 설정됩니다. Windows에서는 실행 비트를 설정하기가 어렵 기 때문에 명시 적 세트를 추가했습니다. Mac OS X 또는 Linux에서 작업중인 경우이 설명이 필요하지 않지만 어쨌든 해치지 않습니다.

이 `ENV`명령은 컨테이너 내부에 환경 변수를 설정합니다. 명령 `FLASK_APP`을 사용 하려면을 설정해야합니다 `flask`.

다음 `RUN chown`명령은 */ home / microblog에* 저장된 모든 디렉토리 및 파일의 소유자를 새 `microblog`사용자로 설정합니다. Dockerfile 상단 근처 에서이 사용자를 만들었지 만 모든 명령의 기본 사용자가 남아 `root`있으므로 `microblog`컨테이너를 시작할 때이 사용자가 작업 할 수 있도록 모든 파일을 사용자 로 전환해야합니다 .

`USER`다음 줄 의 명령은이 새로운 `microblog`사용자를 이후의 지침 및 컨테이너가 시작될 때의 기본값으로 만듭니다 .

`EXPOSE`명령은이 컨테이너가 서버에 사용하게 될 포트를 구성합니다. Docker가 컨테이너의 네트워크를 적절하게 구성 할 수 있어야합니다. 표준 Flask 포트 5000을 선택했지만이 포트는 모든 포트가 될 수 있습니다.

마지막으로이 `ENTRYPOINT`명령은 컨테이너가 시작될 때 실행되어야하는 기본 명령을 정의합니다. 응용 프로그램 웹 서버를 시작하는 명령입니다. 일을 체계적으로 정리하기 위해 별도의 스크립트를 작성하기로 결정했으며 이는 이전에 컨테이너에 복사 한 *boot.sh* 파일입니다. 이 스크립트의 내용은 다음과 같습니다.

*boot.sh* : Docker 컨테이너 시작 스크립트.

```
#!/bin/sh
source venv/bin/activate
flask db upgrade
flask translate compile
exec gunicorn -b :5000 --access-logfile - --error-logfile - microblog:app
```

이 스크립트는 [17 ](https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-xvii-deployment-on-linux)[장](https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-xviii-deployment-on-heroku) 과 [18 ](https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-xviii-deployment-on-heroku)[장의](https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-xvii-deployment-on-linux) 배포 가 시작된 방법과 상당히 유사한 상당히 표준적인 시작 스크립트입니다 . 가상 환경을 활성화하고 마이그레이션 프레임 워크를 통해 데이터베이스를 업그레이드하고 언어 번역을 컴파일 한 다음 gunicorn으로 서버를 실행합니다.

노트 `exec`이 선행 gunicorn 명령을 사용합니다. 쉘 스크립트에서 스크립트를 `exec`실행하는 프로세스가 새 프로세스로 시작되지 않고 지정된 명령으로 대체되도록 트리거합니다. Docker는 컨테이너의 수명을 컨테이너에서 실행되는 첫 번째 프로세스와 연관시키기 때문에 중요합니다. 이와 같은 경우 시작 프로세스가 컨테이너의 기본 프로세스가 아닌 경우 메인 프로세스가 첫 번째 프로세스를 대신하여 컨테이너가 Docker에 의해 조기에 종료되지 않도록해야합니다.

Docker의 흥미로운 측면은 컨테이너가 `stdout`쓰거나 `stderr`컨테이너에 대한 로그로 캡처 및 저장되는 모든 항목입니다. 이러한 이유로 `--access-logfile`and `--error-logfile`는 둘 다 a로 구성되며 `-`, 로그는 표준 출력으로 전송되어 Docker에 의해 로그로 저장됩니다.

Dockerfile을 만들면 컨테이너 이미지를 만들 수 있습니다.

```
$ docker build -t microblog:latest .
```

`-t`나는에게주는거야 인수 `docker build`명령은 새 컨테이너 이미지의 이름과 태그를 설정합니다. 는 `.`컨테이너가 내장 될 기본 디렉토리를 나타냅니다. *Dockerfile* 이있는 디렉토리 입니다. 빌드 프로세스는 *Dockerfile의* 모든 명령을 평가하고 자신의 컴퓨터에 저장 될 이미지를 만듭니다.

다음 `docker images`명령 으로 로컬에있는 이미지 목록을 얻을 수 있습니다 .

```
$ docker images
REPOSITORY    TAG          IMAGE ID        CREATED              SIZE
microblog     latest       54a47d0c27cf    About a minute ago   216MB
python        3.6-alpine   a6beab4fa70b    3 months ago         88.7MB
```

이 목록에는 새 이미지와 이미지가 작성된 기본 이미지가 포함됩니다. 애플리케이션을 변경할 때마다 build 명령을 다시 실행하여 컨테이너 이미지를 업데이트 할 수 있습니다.

## 컨테이너 시작

이미지가 이미 생성 된 상태에서 이제 컨테이너 버전의 응용 프로그램을 실행할 수 있습니다. 이것은 `docker run`일반적으로 많은 수의 인수를 취하는 명령 으로 수행됩니다 . 나는 당신에게 기본적인 예를 보여 주면서 시작하겠습니다 :

```
$ docker run --name microblog -d -p 8000:5000 --rm microblog:latest
021da2e1e0d390320248abf97dfbbe7b27c70fefed113d5a41bb67a68522e91c
```

이 `--name`옵션은 새 컨테이너의 이름을 제공합니다. 이 `-d`옵션은 Docker에게 백그라운드에서 컨테이너를 실행하도록 지시합니다. `-d`컨테이너가 없으면 포 그라운드 응용 프로그램으로 실행되어 명령 프롬프트가 차단됩니다. 이 `-p`옵션은 컨테이너 포트를 호스트 포트에 매핑합니다. 첫 번째 포트는 호스트 컴퓨터의 포트이고 오른쪽의 포트는 컨테이너 내부의 포트입니다. 위의 예제는 호스트의 포트 8000에있는 컨테이너의 포트 5000을 표시하므로 내부적으로 컨테이너가 5000을 사용하더라도 8000의 애플리케이션에 액세스합니다.`--rm`옵션은 컨테이너가 종료되면 삭제합니다. 필수는 아니지만 완료되거나 중단 된 컨테이너는 더 이상 필요하지 않으므로 자동으로 삭제할 수 있습니다. 마지막 인수는 컨테이너에 사용할 컨테이너 이미지 이름과 태그입니다. 위 명령을 실행 한 후 *http : // localhost : 8000* 에서 애플리케이션에 액세스 할 수 있습니다 .

의 출력은 `docker run`새 컨테이너에 지정된 ID입니다. 이것은 긴 16 진 문자열로, 후속 명령에서 컨테이너를 참조해야 할 때마다 사용할 수 있습니다. 실제로 ID를 고유하게 만들려면 처음 몇 자만 필요합니다.

어떤 컨테이너가 실행 중인지 보려면 다음 `docker ps`명령을 사용할 수 있습니다 .

```
$ docker ps
CONTAINER ID  IMAGE             COMMAND      PORTS                   NAMES
021da2e1e0d3  microblog:latest  "./boot.sh"  0.0.0.0:8000->5000/tcp  microblog
```

`docker ps`명령으로 도 컨테이너 ID가 줄어드는 것을 볼 수 있습니다 . 컨테이너를 중지하려면 다음을 사용할 수 있습니다 `docker stop`.

```
$ docker stop 021da2e1e0d3
021da2e1e0d3
```

리콜하면 응용 프로그램 구성에 환경 변수에서 제공되는 여러 옵션이 있습니다. 예를 들어, Flask 비밀 키, 데이터베이스 URL 및 전자 메일 서버 옵션은 모두 환경 변수에서 가져옵니다. 위의 `docker run`예에서 나는 이것에 대해 걱정하지 않았으므로 모든 구성 옵션은 기본값을 사용합니다.

보다 현실적인 예에서는 컨테이너 내에서 해당 환경 변수를 설정합니다. 이전 섹션 `ENV`에서 *Dockerfile* 의 명령이 환경 변수를 설정 한다는 것을 알았으며 정적 변수에 대한 편리한 옵션입니다. 그러나 설치에 의존하는 변수의 경우 상당히 이식 가능한 컨테이너 이미지를 원하므로 빌드 프로세스의 일부로 변수를 갖는 것이 편리하지 않습니다. 다른 사람에게 응용 프로그램을 컨테이너 이미지로 제공하려면 해당 사람이 그대로 사용하고 다른 변수로 다시 작성하지 않아도됩니다.

따라서 빌드 시간 환경 변수가 유용 할 수 있지만 `docker run`명령을 통해 설정할 수있는 런타임 환경 변수가 있어야 하며 이러한 변수에 대해 `-e`옵션을 사용할 수 있습니다. 다음 예는 비밀 키를 설정하고 Gmail 계정을 통해 이메일을 보냅니다.

```
$ docker run --name microblog -d -p 8000:5000 --rm -e SECRET_KEY=my-secret-key \
    -e MAIL_SERVER=smtp.googlemail.com -e MAIL_PORT=587 -e MAIL_USE_TLS=true \
    -e MAIL_USERNAME=<your-gmail-username> -e MAIL_PASSWORD=<your-gmail-password> \
    microblog:latest
```

`docker run`많은 환경 변수 정의로 인해 명령 행이 매우 길어 지는 경우는 드 un니다 .

## 타사 "컨테이너화 된"서비스 사용

마이크로 블로그의 컨테이너 버전은 좋아 보이지만 실제로 스토리지에 대해서는별로 생각하지 않았습니다. 실제로 `DATABASE_URL`환경 변수를 설정하지 않았으므로 응용 프로그램은 디스크의 파일에서 지원하는 기본 SQLite 데이터베이스를 사용하고 있습니다. 컨테이너를 중지하고 삭제할 때 해당 SQLite 파일에 어떤 일이 일어날 것이라고 생각하십니까? 파일이 사라질 것입니다!

컨테이너의 파일 시스템은 *임시입니다* . 즉, 컨테이너가 사라지면 사라집니다. 파일 시스템에 데이터를 쓸 수 있고 컨테이너가 데이터를 읽어야하는 경우 데이터가있을 수 있지만, 어떤 이유로 든 컨테이너를 재활용하여 새 컨테이너로 교체해야합니다 (애플리케이션이 저장 한 모든 데이터) 디스크에 영원히 손실됩니다.

컨테이너 응용 프로그램을위한 좋은 디자인 전략은 응용 프로그램 컨테이너를 *상태 비 저장* 으로 만드는 것 입니다. 응용 프로그램 코드가 있고 데이터가없는 컨테이너가있는 경우 컨테이너를 버리고 아무런 문제없이 새 것으로 교체 할 수 있습니다. 컨테이너는 실제로 폐기 할 수있게되어 업그레이드 배포를 단순화하는 데 큰 도움이됩니다.

그러나 이것은 데이터가 응용 프로그램 컨테이너 외부에 있어야한다는 것을 의미합니다. 환상적인 Docker 생태계가 시작됩니다. Docker Container Registry에는 다양한 컨테이너 이미지가 포함되어 있습니다. 필자는 이미 마이크로 컨테이너 컨테이너의 기본 이미지로 사용하는 Python 컨테이너 이미지에 대해 설명했습니다. 또한 Docker는 Docker 레지스트리에서 다른 많은 언어, 데이터베이스 및 기타 서비스에 대한 이미지를 유지 관리하며, 충분하지 않은 경우 레지스트리를 통해 회사는 해당 제품의 컨테이너 이미지를 게시 할 수 있으며 또한 나와 같은 일반 사용자도 게시 할 수 있습니다 자신의 이미지를 게시합니다. 즉, 타사 서비스를 설치하려는 노력이 레지스트리에서 적절한 이미지를 찾고 `docker run`적절한 인수가 있는 명령으로 시작하기 위해 줄어 듭니다 .

이제 제가해야 할 일은 두 개의 추가 컨테이너를 만드는 것입니다. 하나는 MySQL 데이터베이스 용이고 다른 하나는 Elasticsearch 서비스를위한 것입니다. 그런 다음 옵션으로 Microblog 컨테이너를 시작하는 명령 줄을 더 길게 만들 것입니다. 이 두 개의 새로운 컨테이너에 액세스 할 수 있도록합니다.

### MySQL 컨테이너 추가

다른 많은 제품 및 서비스와 마찬가지로 MySQL에는 Docker 레지스트리에서 사용 가능한 공용 컨테이너 이미지가 있습니다. 내 마이크로 블로그 컨테이너와 마찬가지로 MySQL은에 전달해야하는 환경 변수에 의존합니다 `docker run`. 이것들은 암호, 데이터베이스 이름 등을 구성합니다. 레지스트리에 많은 MySQL 이미지가 있지만 MySQL 팀이 공식적으로 관리하는 이미지를 사용하기로 결정했습니다. MySQL 컨테이너 이미지에 대한 자세한 정보는 레지스트리 페이지 ( *https://hub.docker.com/r/mysql/mysql-server/)* 에서 찾을 수 있습니다 .

[17 장](https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-xvii-deployment-on-linux) 에서 MySQL을 설정하는 힘든 과정을 기억한다면 , MySQL을 배포하는 것이 얼마나 쉬운 지 알면 Docker에 감사 할 것입니다. 다음은 `docker run`MySQL 서버를 시작하는 명령입니다.

```
$ docker run --name mysql -d -e MYSQL_RANDOM_ROOT_PASSWORD=yes \
    -e MYSQL_DATABASE=microblog -e MYSQL_USER=microblog \
    -e MYSQL_PASSWORD=<database-password> \
    mysql/mysql-server:5.7
```

그게 다야! Docker가 설치된 모든 컴퓨터에서 위의 명령을 실행할 수 있으며 임의로 생성 된 루트 암호,라는 새로운 데이터베이스 `microblog`및 full로 구성된 동일한 이름의 사용자로 완전히 설치된 MySQL 서버를 얻을 수 있습니다 데이터베이스에 액세스 할 수있는 권한 `MYSQL_PASSWORD`환경 변수 의 값으로 올바른 비밀번호를 입력해야 합니다.

이제 응용 프로그램 쪽에서 우분투의 전통적인 배포와 마찬가지로 MySQL 클라이언트 패키지를 추가해야합니다. *Dockerfile에*`pymysql` 추가 할 수있는 다시 한 번 사용 *하겠습니다* .

*Dockerfile* : pymysql을 Dockerfile에 추가하십시오.

```
# ...
RUN venv/bin/pip install gunicorn pymysql
# ...
```

애플리케이션 또는 *Dockerfile* 을 변경할 때마다 컨테이너 이미지를 다시 빌드해야합니다.

```
$ docker build -t microblog:latest .
```

이제 Microblog를 다시 시작할 수 있지만 이번에는 데이터베이스 컨테이너에 대한 링크를 통해 둘 다 네트워크를 통해 통신 할 수 있습니다.

```
$ docker run --name microblog -d -p 8000:5000 --rm -e SECRET_KEY=my-secret-key \
    -e MAIL_SERVER=smtp.googlemail.com -e MAIL_PORT=587 -e MAIL_USE_TLS=true \
    -e MAIL_USERNAME=<your-gmail-username> -e MAIL_PASSWORD=<your-gmail-password> \
    --link mysql:dbserver \
    -e DATABASE_URL=mysql+pymysql://microblog:<database-password>@dbserver/microblog \
    microblog:latest
```

이 `--link`옵션은 Docker에게 다른 컨테이너에 액세스 할 수 있도록합니다. 인수는 콜론으로 구분 된 두 개의 이름을 포함합니다. 첫 번째 부분은 연결할 컨테이너의 이름 또는 ID이며,이 경우 `mysql`위에서 만든 이름 입니다. 두 번째 부분은이 컨테이너에서 연결된 이름을 참조하기 위해 사용할 수있는 호스트 이름을 정의합니다. 여기서는 `dbserver`데이터베이스 서버를 나타내는 일반 이름으로 사용 하고 있습니다.

두 컨테이너 사이의 연결이 설정되면 `DATABASE_URL`SQLAlchemy가 다른 컨테이너에서 MySQL 데이터베이스를 사용하도록 환경 변수를 설정할 수 있습니다 . 데이터베이스 URL은 `dbserver`데이터베이스 호스트 이름, `microblog`데이터베이스 이름 및 사용자 및 MySQL을 시작할 때 선택한 비밀번호로 사용됩니다.

MySQL 컨테이너를 실험 할 때 알아 차린 한 가지 사항은이 컨테이너가 완전히 실행되고 데이터베이스 연결을 받아 들일 준비가되기까지 몇 초가 걸린다는 것입니다. MySQL 컨테이너를 시작한 다음 즉시 애플리케이션 컨테이너를 시작하면 *boot.sh* 스크립트가 실행을 시도 할 때 `flask db upgrade`데이터베이스가 연결을 수락 할 준비가되지 않아 실패 할 수 있습니다. 솔루션을보다 강력하게 만들기 위해 *boot.sh에* 재시도 루프를 추가하기로 결정했습니다 .

*boot.sh* : 데이터베이스 연결을 재 시도하십시오.

```
#!/bin/sh
source venv/bin/activate
while true; do
    flask db upgrade
    if [[ "$?" == "0" ]]; then
        break
    fi
    echo Upgrade command failed, retrying in 5 secs...
    sleep 5
done
flask translate compile
exec gunicorn -b :5000 --access-logfile - --error-logfile - microblog:app
```

이 루프는 `flask db upgrade`명령 의 종료 코드를 확인하고 , 0이 아닌 경우 문제가 있다고 가정하여 5 초 동안 기다렸다가 다시 시도합니다.

### Elasticsearch 컨테이너 추가

[부두 노동자에 대한 Elasticsearch 문서](https://www.elastic.co/guide/en/elasticsearch/reference/current/docker.html) 개발을위한 단일 노드로 서비스를 실행하고, 두 개의 노드로 생산 준비 배포 등의 방법을 보여줍니다. 지금은 단일 노드 옵션으로 가서 오픈 소스 엔진 만있는 "oss"이미지를 사용하겠습니다. 컨테이너는 다음 명령으로 시작됩니다.

```
$ docker run --name elasticsearch -d -p 9200:9200 -p 9300:9300 --rm \
    -e "discovery.type=single-node" \
    docker.elastic.co/elasticsearch/elasticsearch-oss:6.1.1
```

이 `docker run`명령은 마이크로 블로그 및 MySQL에서 사용한 것과 비슷하지만 몇 가지 흥미로운 차이점이 있습니다. 첫째, 두 가지 `-p`옵션이 있습니다. 즉,이 컨테이너는 하나가 아닌 두 개의 포트에서 수신 대기합니다. 포트 9200 및 9300은 모두 호스트 시스템의 동일한 포트에 매핑됩니다.

다른 차이점은 컨테이너 이미지를 참조하는 데 사용되는 구문입니다. 내가 로컬로 구축 한 이미지의 경우 구문은 `:`입니다. MySQL 컨테이너는 형식이 약간 더 완전한 구문을 사용 `/:`하며 이는 Docker 레지스트리에서 컨테이너 이미지를 참조하는 데 적합합니다. 내가 사용하는 Elasticsearch 이미지 `//:`는 첫 번째 구성 요소로 레지스트리 주소를 포함하는 패턴을 따릅니다 . 이 구문은 Docker 레지스트리에서 호스팅되지 않은 이미지에 사용됩니다. 이 경우 Elasticsearch는 Docker가 유지 관리하는 기본 레지스트리를 사용하는 대신 *docker.elastic.co* 에서 자체 컨테이너 레지스트리 서비스를 실행합니다 .

이제 Elasticsearch 서비스를 시작하고 실행 했으므로 Microblog 컨테이너의 시작 명령을 수정하여 해당 링크를 작성하고 Elasticsearch 서비스 URL을 설정할 수 있습니다.

```
$ docker run --name microblog -d -p 8000:5000 --rm -e SECRET_KEY=my-secret-key \
    -e MAIL_SERVER=smtp.googlemail.com -e MAIL_PORT=587 -e MAIL_USE_TLS=true \
    -e MAIL_USERNAME=<your-gmail-username> -e MAIL_PASSWORD=<your-gmail-password> \
    --link mysql:dbserver \
    -e DATABASE_URL=mysql+pymysql://microblog:<database-password>@dbserver/microblog \
    --link elasticsearch:elasticsearch \
    -e ELASTICSEARCH_URL=http://elasticsearch:9200 \
    microblog:latest
```

이 명령을 실행하기 전에 이전 Microblog 컨테이너가 아직 실행중인 경우 중지하십시오. 또한 명령의 올바른 위치에 데이터베이스 및 Elasticsearch 서비스의 올바른 비밀번호를 설정하는 데주의하십시오.

이제 *http : // localhost : 8000* 을 방문 하여 검색 기능을 사용할 수 있어야 합니다. 오류가 발생하면 컨테이너 로그를보고 오류를 해결할 수 있습니다. Python 스택 추적이 표시되는 Microblog 컨테이너의 로그를 보려고 할 것입니다.

```
$ docker logs microblog
```

## 도커 컨테이너 레지스트리

이제 3 개의 컨테이너를 사용하여 Docker에서 완전한 응용 프로그램을 실행하고 있습니다.이 중 2 개는 공개적으로 사용 가능한 타사 이미지에서 제공됩니다. 자신의 컨테이너 이미지를 다른 사람이 사용할 수있게하려면 누구나 이미지를 얻을 수있는 Docker 레지스트리 로 *푸시* 해야합니다.

Docker 레지스트리에 액세스하려면 *https://hub.docker.com* 으로 이동하여 자신의 계정을 만들어야합니다. 게시하는 모든 이미지에 사용되므로 원하는 사용자 이름을 선택해야합니다.

명령 행에서 계정에 액세스하려면 다음 명령으로 로그인해야합니다 `docker login`.

```
$ docker login
```

내 지시를 따른다면 이제 `microblog:latest`컴퓨터에 로컬로 저장된 이미지가 있습니다. 이 이미지를 Docker 레지스트리로 푸시하려면 MySQL의 이미지와 같은 계정을 포함하도록 이름을 바꿔야합니다. 이것은 다음 `docker tag`명령 으로 수행됩니다 .

```
$ docker tag microblog:latest <your-docker-registry-account>/microblog:latest
```

이미지를 다시 나열 `docker images`하면 Microblog에 대한 두 개의 항목 (원본 `microblog:latest`이름과 계정 이름도 포함 된 새 항목)이 표시됩니다. 이들은 실제로 동일한 이미지에 대한 두 개의 별명입니다.

Docker 레지스트리에 이미지를 게시하려면 다음 `docker push`명령을 사용하십시오 .

```
$ docker push <your-docker-registry-account>/microblog:latest
```

이제 이미지를 공개적으로 사용할 수 있으며 MySQL 및 다른 사람들과 동일한 방식으로 Docker 레지스트리에서 이미지를 설치하고 실행하는 방법을 문서화 할 수 있습니다.

## 컨테이너화 된 응용 프로그램 배포

Docker 컨테이너에서 응용 프로그램을 실행하는 데 가장 좋은 점 중 하나는 컨테이너를 로컬에서 테스트 한 후에 Docker 지원을 제공하는 모든 플랫폼으로 가져올 수 있다는 것입니다. 예를 들어 [17 장](https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-xvii-deployment-on-linux) 에서 Digital Ocean, Linode 또는 Amazon Lightsail에서 권장 한 것과 동일한 서버를 사용할 수 있습니다 . 이러한 공급자가 제공하는 가장 저렴한 제품조차도 소수의 컨테이너로 Docker를 실행하기에 충분합니다.

[아마존 컨테이너 서비스 (ECS)는](https://aws.amazon.com/ecs/) 당신을위한 개인 컨테이너 레지스트리를 사용하는 스케일링 및로드 밸런싱을 지원하는 완벽하게 통합 된 AWS 환경에서, 당신의 용기를 실행할 수있는 용기 호스트의 클러스터를 만들 수있는 능력, 플러스 옵션을 제공합니다 컨테이너 이미지.

마지막으로 [Kubernetes](https://kubernetes.io/) 와 같은 컨테이너 오케스트레이션 플랫폼 은로드 밸런싱, 스케일링, 비밀의 안전한 관리 및 롤링 업그레이드를 통해 YAML 형식의 간단한 텍스트 파일로 다중 컨테이너 배포를 설명 할 수있어 훨씬 더 높은 수준의 자동화 및 편의성을 제공합니다.



## [Part XX: Some JavaScript Magic](https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-xx-some-javascript-magic)

이것은 Flask Mega-Tutorial 시리즈의 20 번째 설치이며, 사용자의 닉네임 위에 마우스를 올릴 때 멋진 팝업을 추가 할 것입니다.

요즘에는 적어도 약간의 JavaScript를 사용하지 않는 웹 애플리케이션을 구축하는 것은 불가능합니다. 잘 아시다시피, 그 이유는 JavaScript가 웹 브라우저에서 기본적으로 실행되는 유일한 언어이기 때문입니다. [14 장](https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-xiv-ajax) 에서는 Flask 템플릿에 간단한 JavaScript 가능 링크를 추가하여 블로그 게시물의 실시간 언어 번역을 제공하는 것을 보았습니다. 이 장에서는 주제에 대해 더 깊이 파고 들어 응용 프로그램을 사용자에게 더 흥미롭고 흥미롭게 만드는 또 다른 유용한 JavaScript 트릭을 보여줄 것입니다.

사용자가 서로 상호 작용할 수있는 소셜 사이트의 일반적인 사용자 인터페이스 패턴은 사용자 이름 위에 페이지를 가리킬 때 팝업 패널에 사용자의 빠른 요약을 표시하는 것입니다. 이것에주의를 기울이지 않은 경우 Twitter, Facebook, LinkedIn 또는 기타 주요 소셜 네트워크로 이동하고 사용자 이름이 표시되면 마우스 포인터를 몇 초 동안 그대로두면 팝업이 나타납니다. . 이 장에서는 Microblog 용 기능을 구축하는 데 중점을두고 있으며, 아래에서 미리 볼 수 있습니다.

![사용자 팝업](.\images\mega-tutorial/ch20-demo.png)

*이 장의 GitHub 링크는 [Browse](https://github.com/miguelgrinberg/microblog/tree/v0.20) , [Zip](https://github.com/miguelgrinberg/microblog/archive/v0.20.zip) , [Diff](https://github.com/miguelgrinberg/microblog/compare/v0.19...v0.20) 입니다.*

## 서버 측 지원

클라이언트 측을 파고 들기 전에 이러한 사용자 팝업을 지원하는 데 필요한 약간의 서버 작업을 해보자. 사용자 팝업의 내용은 기존 사용자 프로필 경로의 단순화 된 버전이 될 새로운 경로로 반환됩니다. 보기 기능은 다음과 같습니다.

*app / main / routes.py* : 사용자 팝업보기 기능.

```
@bp.route('/user/<username>/popup')
@login_required
def user_popup(username):
    user = User.query.filter_by(username=username).first_or_404()
    return render_template('user_popup.html', user=user)
```

이 경로는 */ user /  / popup* URL에 연결되며 요청 된 사용자를로드 한 다음 템플릿을 렌더링합니다. 템플리트는 사용자 프로파일 페이지에 사용되는 짧은 버전입니다.

*app / templates / user_popup.html* : 사용자 팝업 템플릿.

```
<table class="table">
    <tr>
        <td width="64" style="border: 0px;"><img src="{{ user.avatar(64) }}"></td>
        <td style="border: 0px;">
            <p>
                <a href="{{ url_for('main.user', username=user.username) }}">
                    {{ user.username }}
                </a>
            </p>
            <small>
                {% if user.about_me %}<p>{{ user.about_me }}</p>{% endif %}
                {% if user.last_seen %}
                <p>{{ _('Last seen on') }}: 
                   {{ moment(user.last_seen).format('lll') }}</p>
                {% endif %}
                <p>{{ _('%(count)d followers', count=user.followers.count()) }},
                   {{ _('%(count)d following', count=user.followed.count()) }}</p>
                {% if user != current_user %}
                    {% if not current_user.is_following(user) %}
                    <a href="{{ url_for('main.follow', username=user.username) }}">
                        {{ _('Follow') }}
                    </a>
                    {% else %}
                    <a href="{{ url_for('main.unfollow', username=user.username) }}">
                        {{ _('Unfollow') }}
                    </a>
                    {% endif %}
                {% endif %}
            </small>
        </td>
    </tr>
</table>
```

다음 섹션에서 작성할 JavaScript 코드는 사용자가 마우스 포인터를 사용자 이름 위에 놓을 때이 경로를 호출합니다. 이에 대한 응답으로 서버는 팝업에 대한 HTML 컨텐츠를 리턴하고 클라이언트는이를 표시합니다. 사용자가 마우스를 움직이면 팝업이 제거됩니다. 간단하게 들리나요?

팝업 모양에 대한 아이디어가 필요하면 이제 응용 프로그램을 실행하고 사용자 프로필 페이지로 이동 한 다음 주소 표시 줄의 URL에 */ popup* 을 추가 하여 전체 화면 버전의 팝업 내용을 볼 수 있습니다. .

## 부트 스트랩 팝 오버 구성 요소 소개

[11 장](https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-xi-facelift) 에서는 멋진 웹 페이지를 만드는 편리한 방법으로 Bootstrap 프레임 워크를 소개했습니다. 지금까지이 프레임 워크의 최소한의 부분 만 사용했습니다. 부트 스트랩에는 많은 공통 UI 요소가 번들로 제공되며 *https://getbootstrap.com* 의 부트 스트랩 문서에 데모와 예제가 *있습니다* . 이러한 구성 요소 중 하나는 [Popover](https://getbootstrap.com/docs/3.3/javascript/#popovers) 이며, 이는 문서에서 "보조 정보를 수용하기위한 작은 컨텐츠 오버레이"로 설명됩니다. 정확히 내가 필요한 것!

대부분의 부트 스트랩 구성 요소는 멋진 스타일을 추가하는 부트 스트랩 CSS 정의를 참조하는 HTML 마크 업을 통해 정의됩니다. 가장 고급 기술 중 일부는 JavaScript가 필요합니다. 응용 프로그램이 웹 페이지에 이러한 구성 요소를 포함하는 표준 방법은 HTML을 적절한 위치에 추가 한 다음 스크립팅 지원이 필요한 구성 요소에 대해 초기화 또는 활성화하는 JavaScript 함수를 호출하는 것입니다. 팝 오버 구성 요소에는 JavaScript 지원이 필요합니다.

팝 오버를 수행하는 HTML 부분은 정말 간단합니다. 팝 오버를 표시 할 요소를 정의하기 만하면됩니다. 필자의 경우 각 블로그 게시물에 표시되는 클릭 가능한 사용자 이름으로 이동합니다. *응용 프로그램 / 템플릿 / _post.html* 서브 템플릿은 이미 정의 된 이름이 있습니다 :

```
            <a href="{{ url_for('main.user', username=post.author.username) }}">
                {{ post.author.username }}
            </a>
```

이제 popover documentation `popover()`에 따르면 페이지에 나타나는 위의 링크와 같은 각 링크 에서 JavaScript 함수 를 호출 하면 팝업이 초기화됩니다. 초기화 호출은 팝업에 표시 할 내용을 전달하는 옵션, 팝업을 표시하거나 사라지게하는 데 사용할 방법 (클릭, 요소 위로 마우스 이동 등)을 포함하여 팝업을 구성하는 여러 옵션을 허용합니다. ), 콘텐츠가 일반 텍스트 또는 HTML 인 경우 문서 페이지에서 볼 수있는 몇 가지 옵션이 더 있습니다. 불행히도,이 정보를 읽은 후에는 대답보다 더 많은 질문이 생겼습니다.이 구성 요소는 필요한 방식으로 작동하도록 설계되지 않았기 때문입니다. 다음은이 기능을 구현하기 위해 해결해야 할 문제 목록입니다.

- 페이지에는 표시되는 각 블로그 게시물마다 하나씩 많은 사용자 이름 링크가 있습니다. 페이지가 렌더링 된 후 JavaScript에서 이러한 링크를 모두 찾아서 팝 오버로 초기화 할 수있는 방법이 필요합니다.
- 부트 스트랩 문서의 팝업 예제는 모두 `data-content`대상 HTML 요소에 추가 된 속성으로 팝업 컨텐츠를 제공 하므로 호버 이벤트가 트리거되면 모든 부트 스트랩이 팝업을 표시해야합니다. 콘텐츠를 얻기 위해 서버에 Ajax 호출을하고 싶기 때문에 서버의 응답이 수신 될 때만 팝업이 나타나기를 원하기 때문에 정말 불편합니다.
- "호버"모드를 사용하는 경우 대상 요소 내에 마우스 포인터를두면 팝업이 계속 표시됩니다. 마우스를 움직이지 않으면 팝업이 사라집니다. 이는 사용자가 마우스 포인터를 팝업 자체로 이동하려고하면 팝업이 사라지는 추악한 부작용이 있습니다. 팝업을 포함하도록 호버 동작을 확장하는 방법을 찾아야 사용자가 팝업으로 이동하여 링크를 클릭 할 수 있습니다.

브라우저 기반 응용 프로그램으로 작업 할 때 상황이 정말 복잡 해지는 것은 실제로 드문 일이 아닙니다. DOM 요소가 서로 상호 작용하는 방식과 관련하여 사용자에게 좋은 경험을 제공하는 방식으로 매우 구체적으로 생각해야합니다.

## 페이지로드시 기능 실행

각 페이지가로드되는 즉시 JavaScript 코드를 실행해야한다는 것은 분명합니다. 내가 실행할 기능은 페이지에서 사용자 이름에 대한 모든 링크를 검색하고 Bootstrap의 팝 오버 구성 요소를 사용하여 구성합니다.

jQuery JavaScript 라이브러리는 Bootstrap의 종속성으로로드되므로이를 활용할 것입니다. jQuery를 사용하는 경우 페이지를로 묶어서 페이지를로드 할 때 실행할 함수를 등록 할 수 있습니다 `$( ... )`. *app / templates / base.html* 템플릿 에 이것을 추가 하여 애플리케이션의 모든 페이지에서 실행될 수 있습니다.

*app / templates / base.html* : 페이지로드 후 기능을 실행합니다.

```
...
<script>
    // ...

    $(function() {
        // write start up code here
    });
</script>
```

보시다시피, [14 장](https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-xiv-ajax)`` 에서 `translate()`함수를 정의한 요소 안에 시작 함수를 추가했습니다 .

## 선택기를 사용하여 DOM 요소 찾기

첫 번째 문제는 페이지에서 모든 사용자 링크를 찾는 JavaScript 함수를 만드는 것입니다. 이 기능은 페이지로드가 완료되면 실행되며 완료되면 모든 페이지에 대한 호버링 및 팝업 동작을 구성합니다. 지금은 링크를 찾는 데 집중할 것입니다.

[14 장](https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-xiv-ajax) 에서 기억한다면 , 라이브 번역에 관련된 HTML 요소는 고유 한 ID를가집니다. 예를 들어 ID가 123 인 게시물에는 `id="post123"`속성이 추가되었습니다. 그런 다음 jQuery `$('#post123')`를 사용하여 JavaScript에서 표현식 을 사용하여 DOM에서이 요소를 찾습니다. 이 `$()`기능은 매우 강력하며 [CSS Selectors를](https://api.jquery.com/category/selectors/) 기반으로하는 DOM 요소를 검색 할 수있는 매우 정교한 쿼리 언어가 있습니다.

번역 기능에 사용한 선택기는 고유 식별자가 `id`속성으로 설정된 하나의 특정 요소를 찾도록 설계되었습니다 . 요소를 식별하는 또 다른 옵션 `class`은 페이지의 여러 요소에 할당 할 수있는 속성 을 사용하는 것입니다. 예를 들어, 모든 사용자 링크를로 표시 `class="user_popup"`한 다음 JavaScript에서 링크 목록을 가져올 수 있습니다 `$('.user_popup')`(CSS 선택기에서는 `#`접두사가 ID로 `.`검색되고 접두사가 클래스로 검색 됨). 이 경우 반환 값은 클래스가있는 모든 요소의 모음입니다.

## 팝 오버와 DOM

Bootstrap 문서에서 popover 예제를 사용하고 브라우저 디버거에서 DOM을 검사하여 Bootstrap이 popover 구성 요소를 DOM에서 대상 요소의 형제로 작성한다고 결정했습니다. 위에서 언급했듯이, 이는 마우스 오버 이벤트의 동작에 영향을 미치며 사용자가 마우스를 ``링크에서 팝업으로 이동하자마자 "마우스 아웃"을 트리거 합니다.

팝 오버를 포함하도록 호버 이벤트를 확장하는 데 사용할 수있는 트릭은 호버 이벤트가 상속되는 방식으로 팝 오버를 대상 요소의 하위로 만드는 것입니다. 설명서에서 팝 오버 옵션을 살펴보면 옵션에서 상위 요소를 전달하여이를 수행 할 수 있습니다 `container`.

팝업 요소를 호버링 된 요소의 자식으로 만들면 버튼 또는 일반 요소 ``또는 ``기반 요소에서 잘 작동 하지만 제 경우에는 팝업의 대상 ``이 사용자 이름의 클릭 가능한 링크를 표시 하는 요소가됩니다. 팝 오버를 ``요소 의 자식으로 만드는 문제 는 팝 오버가 ``부모 의 링크 동작을 획득한다는 것 입니다. 최종 결과는 다음과 같습니다.

```
        <a href="..." class="user_popup">
            username
            <div> ... popover elements here ... </div>
        </a>
```

팝 오버가 ``요소 내부에있는 것을 피하기 위해 사용하는 또 다른 트릭입니다. ``요소 내부의 ``요소 를 래핑 한 다음 호버 이벤트와 팝 오버를에 연결합니다 ``. 결과 구조는 다음과 같습니다.

```
        <span class="user_popup">
            <a href="...">
                username
            </a>
            <div> ... popover elements here ... </div>
        </span>
```

<div>과 <span>그들이하는 데 사용할에 큰 요소를 구성하고 DOM을 구조는 그래서 요소는 보이지 않습니다. <div>요소는 인 블록 요소 그동안, 정렬 HTML 문서의 단락 등으로, <span>요소가 있습니다 인라인 요소 단어와 비교할 것이다. 이 경우 래핑하는 요소도 인라인 요소 <span>이므로 요소 와 함께하기로 결정했습니다 <a>.

계속해서 *app / templates / _post.html* 하위 *템플릿을* 리팩터링 하여 ``요소 를 포함시킵니다 .

```
...
                {% set user_link %}
                    <span class="user_popup">
                        <a href="{{ url_for('main.user', username=post.author.username) }}">
                            {{ post.author.username }}
                        </a>
                    </span>
                {% endset %}
...
```

popover HTML 요소가 어디에 있는지 궁금하다면 좋은 소식은 그것에 대해 걱정할 필요가 없다는 것입니다. 방금 만든 요소 에서 `popover()`초기화 함수 를 호출하면 ``Bootstrap 프레임 워크가 팝업 구성 요소를 동적으로 삽입합니다.

## 호버 이벤트

위에서 언급했듯이 Bootstrap의 popover 구성 요소가 사용하는 호버 동작은 내 요구를 수용하기에 충분히 유연하지 않지만 `trigger`옵션 에 대한 설명서를 보면 "호버"는 가능한 값 중 하나 일뿐입니다. 내 눈은 JavaScript 호출을 통해 팝 오버를 수동으로 표시하거나 제거 할 수있는 "수동"모드였습니다.이 모드를 사용하면 호버 논리를 직접 구현할 수 있으므로 해당 옵션을 사용하여 내가 원하는 방식으로 작동하는 자체 호버 이벤트 핸들러.

다음 단계는 "호버"이벤트를 페이지의 모든 링크에 첨부하는 것입니다. jQuery를 사용하면을 호출하여 호버 이벤트를 HTML 요소에 첨부 할 수 있습니다 `element.hover(handlerIn, handlerOut)`. 이 함수가 요소 컬렉션에서 호출되면 jQuery는 모든 요소에 이벤트를 편리하게 연결합니다. 두 개의 인수는 사용자가 마우스 포인터를 대상 요소 안팎으로 이동할 때 호출되는 두 가지 함수입니다.

*app / templates / base.html* : 호버 이벤트.

```
    $(function() {
        $('.user_popup').hover(
            function(event) {
                // mouse in event handler
                var elem = $(event.currentTarget);
            },
            function(event) {
                // mouse out event handler
                var elem = $(event.currentTarget);
            }
        )
    });
```

`event`인수는 유용한 정보가 들어있는 이벤트 객체입니다. 이 경우을 사용하여 이벤트의 대상이 된 요소를 추출합니다 `event.currentTarget`.

마우스가 영향을받는 요소에 들어간 직후 브라우저는 호버 이벤트를 전달합니다. 팝업의 경우 마우스가 요소에 머무르는 짧은 시간 동안 기다린 후에 만 활성화하려고합니다. 마우스 포인터가 요소를 잠깐 지나가지만 위에 머 무르지 않으면 팝업이 깜박이지 않습니다. . 이 이벤트에는 지연에 대한 지원이 제공되지 않으므로 이것이 나 자신을 구현해야 할 또 다른 것입니다. "mouse in"이벤트 핸들러에 1 초 타이머를 추가하겠습니다.

*app / templates / base.html* : 호버 지연.

```
    $(function() {
        var timer = null;
        $('.user_popup').hover(
            function(event) {
                // mouse in event handler
                var elem = $(event.currentTarget);
                timer = setTimeout(function() {
                    timer = null;
                    // popup logic goes here
                }, 1000);
            },
            function(event) {
                // mouse out event handler
                var elem = $(event.currentTarget);
                if (timer) {
                    clearTimeout(timer);
                    timer = null;
                }
            }
        )
    });
```

이 `setTimeout()`기능은 브라우저 환경에서 사용할 수 있습니다. 함수와 시간 (밀리 초)의 두 가지 인수가 필요합니다. 결과 `setTimeout()`는 주어진 지연 후에 함수가 호출된다는 것입니다. 그래서 지금은 비어있는 함수를 추가했습니다.이 함수는 호버 이벤트가 전달 된 후 1 초 후에 호출됩니다. JavaScript 언어의 클로저 덕분에이 함수는와 같은 외부 범위에서 정의 된 변수에 액세스 할 수 있습니다 `elem`.

타이머 개체를 "mouse out"처리기에서도 액세스 할 수 있도록 호출 `timer`외부에서 정의한 변수에 타이머 개체를 저장하고 `hover()`있습니다. 이것이 필요한 이유는 다시 한 번 좋은 사용자 경험을 제공하기 위해서입니다. 사용자가 마우스 포인터를 이러한 사용자 링크 중 하나로 이동하여 예를 들어 이동하기 전에 0.5 초 동안 유지하면 타이머가 계속 꺼져 팝업을 표시하는 기능을 호출하지 않습니다. 따라서 마우스 아웃 이벤트 핸들러는 활성 타이머 객체가 있는지 확인하고 객체가 있으면 취소합니다.

## 아약스 요청

Ajax 요청은 실시간 언어 번역 기능의 일부로 [14 장](https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-xiv-ajax) 에서이 주제를 다시 소개 했으므로 새로운 주제가 아닙니다 . jQuery를 사용할 때이 `$.ajax()`함수는 서버에 비동기 요청을 보냅니다.

서버로 보내려는 요청에는 */ user /  / popup* URL이 *있으며이* URL은이 장의 시작 부분에 응용 프로그램에 추가되었습니다. 이 요청의 응답에는 팝업에 삽입해야하는 HTML이 포함됩니다.

이 요청에 대한 나의 즉각적인 문제 `username`는 URL에 포함해야하는 가치가 무엇인지 아는 것입니다 . 이벤트 핸들러 함수의 마우스는 일반적이며 페이지에있는 모든 사용자 링크에 대해 실행되므로 함수는 컨텍스트에서 사용자 이름을 결정해야합니다.

`elem`변수는 마우스 오버 이벤트에서 대상 요소가 포함되어 ``감쌈 요소 ``요소를하지만, 내가 사용하고 `$()`이것은 하나 개의 항목리스트가 될 것입니다, 그래서 일치하는 결과의 목록을 반환 jQuery를 기능을. 사용자 이름을 추출하기 위해의 첫 번째 항목에서 시작 `elem`하여 ``요소 인 첫 번째 자식으로 이동 한 다음 URL에서 사용해야하는 사용자 이름 인 텍스트를 추출 하여 DOM을 탐색 할 수 있습니다. . jQuery의 DOM 순회 기능을 사용하면 실제로 쉽습니다.

```
elem.first().text().trim()
```

`first()`DOM의 목록에 적용되는 기능은 반환에게 첫 번째 노드. 이 `text()`함수는 HTML 태그를 포함하지 않고 노드의 텍스트 내용과 모든 하위 항목을 결합하여 반환합니다. 이 기능을 사용하면이있는 경우, 그래서 예를 들어, 어떤 텍스트의 트리밍을하지 않는 ``한 줄, 다음 줄의 텍스트에서, 그리고 ``다른 라인에, `text()`을 걸러 ``하고 ``있지만를 둘러싼 모든 공백을 반환합니다 본문. 모든 공백을 제거하고 텍스트 만 남기려면 `trim()`JavaScript 함수를 사용합니다 .

그리고 이것이 서버에 요청을 발행하는 데 필요한 모든 정보입니다.

*app / templates / base.html* : XHR 요청.

```
    $(function() {
        var timer = null;
        var xhr = null;
        $('.user_popup').hover(
            function(event) {
                // mouse in event handler
                var elem = $(event.currentTarget);
                timer = setTimeout(function() {
                    timer = null;
                    xhr = $.ajax(
                        '/user/' + elem.first().text().trim() + '/popup').done(
                            function(data) {
                                xhr = null
                                // create and display popup here
                            }
                        );
                }, 1000);
            },
            function(event) {
                // mouse out event handler
                var elem = $(event.currentTarget);
                if (timer) {
                    clearTimeout(timer);
                    timer = null;
                }
                else if (xhr) {
                    xhr.abort();
                    xhr = null;
                }
                else {
                    // destroy popup here
                }
            }
        )
    });
```

여기서는 외부 범위에서 새 변수를 정의했습니다 `xhr`. 이 변수는에 대한 호출에서 초기화하는 비동기 요청 객체를 보유합니다 `$.ajax()`. 불행히도 JavaScript 측에서 직접 URL을 작성할 때 `url_for()`from Flask를 사용할 수 없으므로이 경우 URL 부분을 명시 적으로 연결해야합니다.

이 `$.ajax()`호출은 비동기 작업을 나타내는이 특수 JavaScript 객체 인 promise를 반환합니다. 을 추가하여 완료 콜백을 첨부 할 수 `.done(function)`있으므로 요청이 완료되면 콜백 함수가 호출됩니다. 콜백 함수는 응답을 인수로받습니다 `data`. 위 코드에서 이름을 알 수 있습니다 . 이것은 팝 오버에 넣을 HTML 내용이 될 것입니다.

그러나 팝 오버에 도달하기 전에 사용자에게 좋은 경험을 제공하는 것과 관련된 또 다른 세부 사항이 있습니다. "mouse out"이벤트 핸들러 함수에 로직을 추가하여 사용자가 마우스 포인터를에서 밖으로 이동 한 경우 1 초 시간 초과를 취소한다는 것을 상기하십시오 ``. 비동기식 요청에도 동일한 아이디어를 적용해야하므로 `xhr`요청 객체가 있으면 중단하기 위해 두 번째 절을 추가 했습니다.

## 팝 오버 생성 및 파괴

마지막으로 `data`Ajax 콜백 함수에서 전달 된 인수를 사용하여 popover 컴포넌트를 작성할 수 있습니다 .

*app / templates / base.html* : *팝업* 표시

```
                                function(data) {
                                    xhr = null;
                                    elem.popover({
                                        trigger: 'manual',
                                        html: true,
                                        animation: false,
                                        container: elem,
                                        content: data
                                    }).popover('show');
                                    flask_moment_render_all();
                                }
```

팝업의 실제 생성은 매우 간단 `popover()`합니다. Bootstrap 의 기능은 설정에 필요한 모든 작업을 수행합니다. 팝 오버 옵션이 인수로 제공됩니다. "수동"트리거 모드, HTML 컨텐츠, 페이드 애니메이션 없음 (더 빠르게 나타나고 사라짐)으로이 팝 오버를 구성했으며, 상위 ``요소를 요소 자체 로 설정 하여 호버 동작이 상속에 의한 팝 오버. 마지막으로 `data`인수를 인수로 Ajax 콜백에 `content`전달합니다.

`popover()`호출 의 리턴은 새로 작성된 popover 구성 요소이며, 이상한 이유 때문에이를 호출 `popover()`하는 데 사용되는 또 다른 메소드가 있습니다 . `popover('show')`팝업을 페이지에 표시하려면 두 번째 호출 을 추가해야했습니다 .

팝업 내용에는 "마지막으로 본"날짜가 포함되며,이 날짜는 [12 장](https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-xii-dates-and-times) 에서 설명 된대로 Flask-Moment 플러그인을 통해 생성됩니다 . 확장 기능에 [설명](https://github.com/miguelgrinberg/Flask-Moment#ajax-support) 된 대로 Ajax를 통해 새 Flask-Moment 요소를 추가하면 `flask_moment_render_all()`해당 요소를 적절하게 렌더링하기 위해 함수를 호출해야합니다.

이제 남은 것은 마우스 아웃 이벤트 핸들러에서 팝업 제거를 처리하는 것입니다. 이 핸들러는 사용자가 대상 요소 밖으로 마우스를 이동하여 중단 된 경우 팝 오버 조작을 중단시키는 로직을 이미 가지고 있습니다. 해당 조건이 적용되지 않는 경우 이는 현재 팝 오버가 표시되고 사용자가 대상 영역을 벗어나고 있음을 의미하므로 `popover('destroy')`대상 요소에 대한 호출은 적절한 제거 및 정리를 수행합니다.

*app / templates / base.html* : 팝 오버 제거

```
                function(event) {
                    // mouse out event handler
                    var elem = $(event.currentTarget);
                    if (timer) {
                        clearTimeout(timer);
                        timer = null;
                    }
                    else if (xhr) {
                        xhr.abort();
                        xhr = null;
                    }
                    else {
                        elem.popover('destroy');
                    }
                }
```



## [Part XXI: User Notifications](https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-xxi-user-notifications)

이것은 Flask Mega-Tutorial 시리즈의 21 번째 작품으로, 페이지를 새로 고칠 필요없이 탐색 표시 줄에 나타나는 사용자 알림과 함께 개인 메시지 기능을 추가 할 것입니다.

이 장에서는 Microblog 응용 프로그램의 사용자 경험을 개선하기 위해 계속 노력하고 싶습니다. 많은 응용 프로그램에 적용되는 한 가지 측면은 사용자에게 경고 또는 알림을 표시하는 것입니다. 소셜 애플리케이션은 이러한 알림을 표시하여 일반적으로 맨 위 탐색 표시 줄에 작은 배지를 표시하여 새로운 멘션 또는 개인 메시지가 있음을 알려줍니다. 이것이 가장 명백한 사용법이지만, 알림 패턴을 다른 많은 유형의 응용 프로그램에 적용하여 사용자에게주의가 필요하다는 것을 알릴 수 있습니다.

그러나 사용자 알림 작성과 관련된 기술을 보여주기 위해 Microblog를 활용할 수있는 기능으로 Microblog를 확장해야했기 때문에이 장의 첫 부분에서는 모든 사용자가 보낼 수있는 사용자 메시징 시스템을 구축 할 것입니다. 다른 사용자에게 개인 메시지. 이것은 실제로는 소리보다 단순하며, Flask 핵심 관행에 대한 좋은 정보와 Flask를 사용한 효율적이고 효율적인 프로그래밍이 가능한 방법을 상기시켜줍니다. 그리고 메시징 시스템이 완성되면 읽지 않은 메시지 수를 표시하는 알림 배지를 구현하는 몇 가지 옵션에 대해 설명하겠습니다.

*이 장의 GitHub 링크는 [Browse](https://github.com/miguelgrinberg/microblog/tree/v0.21) , [Zip](https://github.com/miguelgrinberg/microblog/archive/v0.21.zip) , [Diff](https://github.com/miguelgrinberg/microblog/compare/v0.20...v0.21) 입니다.*

## 개인 메시지

구현하려는 개인 메시징 기능은 매우 간단합니다. 사용자의 프로필 페이지를 방문하면 해당 사용자에게 개인 메시지를 보낼 수있는 링크가 있습니다. 링크는 웹 양식이 메시지를 가져 오는 새 페이지로 연결됩니다. 귀하에게 전송 된 메시지를 읽으려면 페이지 상단의 탐색 막대에 새로운 "메시지"링크가 생겨서 색인 또는 탐색 페이지와 구조가 유사하지만 블로그 게시물을 표시하는 대신 페이지로 이동합니다. 다른 사용자가 보낸 메시지를 표시합니다.

다음 섹션에서는이 기능을 구현하기 위해 수행 한 단계를 설명합니다.

### 개인 메시지에 대한 데이터베이스 지원

첫 번째 작업은 개인 메시지를 지원하도록 데이터베이스를 확장하는 것입니다. 새로운 `Message`모델 은 다음과 같습니다 .

*app / models.py* : 메시지 모델.

```
class Message(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    sender_id = db.Column(db.Integer, db.ForeignKey('user.id'))
    recipient_id = db.Column(db.Integer, db.ForeignKey('user.id'))
    body = db.Column(db.String(140))
    timestamp = db.Column(db.DateTime, index=True, default=datetime.utcnow)

    def __repr__(self):
        return '<Message {}>'.format(self.body)
```

이 모델 클래스는 모델과 유사하지만 `Post`발신자와 수신자를위한 두 개의 사용자 외부 키가 있다는 점만 다릅니다. 이 `User`모델은이 두 사용자의 관계와 사용자가 개인 메시지를 마지막으로 읽은 시간을 나타내는 새 필드를 얻을 수 있습니다.

*app / models.py* : 사용자 모델에서 개인 메시지 지원.

```
class User(UserMixin, db.Model):
    # ...
    messages_sent = db.relationship('Message',
                                    foreign_keys='Message.sender_id',
                                    backref='author', lazy='dynamic')
    messages_received = db.relationship('Message',
                                        foreign_keys='Message.recipient_id',
                                        backref='recipient', lazy='dynamic')
    last_message_read_time = db.Column(db.DateTime)

    # ...

    def new_messages(self):
        last_read_time = self.last_message_read_time or datetime(1900, 1, 1)
        return Message.query.filter_by(recipient=self).filter(
            Message.timestamp > last_read_time).count()
```

두 관계는 주어진 사용자에 대해주고받은 메시지를 반환 `Message`하며 관계 측면에서 참조를 추가 `author`하고 `recipient`다시 보냅니다 . `author`더 적절한 대신 역 참조를 사용한 이유 `sender`는 `author`블로그 게시물에 사용하는 것과 동일한 논리를 사용하여 이러한 메시지를 렌더링 할 수 있기 때문입니다. 이 `last_message_read_time`필드는 사용자가 메시지 페이지를 마지막으로 방문한 시간을 가지며 읽지 않은 메시지가 있는지 판별하는 데 사용되며이 메시지는 모두이 필드보다 최신 시간 소인이 있습니다. `new_messages()`도우미 방법은 실제로 사용자가 얼마나 많은 읽지 않은 메시지 반환이 필드를 사용합니다. 이 장을 마치면 페이지 상단의 탐색 막대에이 번호가 멋진 배지로 표시됩니다.

데이터베이스 변경이 완료되었으므로 이제 새로운 마이그레이션을 생성하고 데이터베이스를 업그레이드 할 차례입니다.

```
(venv) $ flask db migrate -m "private messages"
(venv) $ flask db upgrade
```

### 개인 메시지 보내기

다음으로 메시지를 보내겠습니다. 메시지를 수락하는 간단한 웹 양식이 필요합니다.

*app / main / forms.py* : 개인 메시지 양식 클래스.

```
class MessageForm(FlaskForm):
    message = TextAreaField(_l('Message'), validators=[
        DataRequired(), Length(min=0, max=140)])
    submit = SubmitField(_l('Submit'))
```

또한이 양식을 웹 페이지에 렌더링하는 HTML 템플릿도 필요합니다.

*app / templates / send_message.html* : 비공개 메시지 HTML 템플릿을 보냅니다.

```
{% extends "base.html" %}
{% import 'bootstrap/wtf.html' as wtf %}

{% block app_content %}
    <h1>{{ _('Send Message to %(recipient)s', recipient=recipient) }}</h1>
    <div class="row">
        <div class="col-md-4">
            {{ wtf.quick_form(form) }}
        </div>
    </div>
{% endblock %}
```

다음으로 개인 메시지의 실제 전송을 처리하기 위해 새로운 */ send_message / * 경로 를 추가 *하겠습니다* .

*app / main / routes.py* : 개인 메시지 경로를 보냅니다.

```
from app.main.forms import MessageForm
from app.models import Message

# ...

@bp.route('/send_message/<recipient>', methods=['GET', 'POST'])
@login_required
def send_message(recipient):
    user = User.query.filter_by(username=recipient).first_or_404()
    form = MessageForm()
    if form.validate_on_submit():
        msg = Message(author=current_user, recipient=user,
                      body=form.message.data)
        db.session.add(msg)
        db.session.commit()
        flash(_('Your message has been sent.'))
        return redirect(url_for('main.user', username=recipient))
    return render_template('send_message.html', title=_('Send Message'),
                           form=form, recipient=recipient)
```

이 뷰 함수의 논리는 대부분 설명이 필요하다고 생각합니다. 개인 메시지를 보내는 작업은 `Message`데이터베이스에 새 인스턴스를 추가하여 간단하게 수행 됩니다.

모든 것을 하나로 묶는 마지막 변경 사항은 사용자 프로필 페이지에서 위 경로에 대한 링크를 추가 한 것입니다.

*app / templates / user.html* : 사용자 프로필 페이지에서 개인 메시지 링크를 보냅니다.

```
                {% if user != current_user %}
                <p>
                    <a href="{{ url_for('main.send_message',
                                        recipient=user.username) }}">
                        {{ _('Send private message') }}
                    </a>
                </p>
                {% endif %}
```

### 개인 메시지보기

이 기능의 두 번째 큰 부분은 개인 메시지를 보는 것입니다. 이를 위해 */ messages* 에 색인과 상당히 유사한 방식으로 작동하고 페이지 매김에 대한 전체 지원을 포함하여 페이지를 탐색하는 다른 경로를 추가하겠습니다 .

*app / main / routes.py* : 메시지 경로를 봅니다.

```
@bp.route('/messages')
@login_required
def messages():
    current_user.last_message_read_time = datetime.utcnow()
    db.session.commit()
    page = request.args.get('page', 1, type=int)
    messages = current_user.messages_received.order_by(
        Message.timestamp.desc()).paginate(
            page, current_app.config['POSTS_PER_PAGE'], False)
    next_url = url_for('main.messages', page=messages.next_num) \
        if messages.has_next else None
    prev_url = url_for('main.messages', page=messages.prev_num) \
        if messages.has_prev else None
    return render_template('messages.html', messages=messages.items,
                           next_url=next_url, prev_url=prev_url)
```

이 뷰 함수에서 가장 먼저하는 일은 `User.last_message_read_time`현재 시간으로 필드를 업데이트하는 것 입니다. 기본적으로이 사용자에게 보낸 모든 메시지를 읽은 것으로 표시합니다. 그런 다음 `Message`메시지 목록에 대해 모델을 쿼리하여 최신에서 오래된 타임 스탬프로 정렬합니다. `POSTS_PER_PAGE`게시물과 메시지가있는 페이지가 매우 비슷하게 보이기 때문에 구성 항목 을 다시 사용하기로 결정 했지만 물론 페이지가 다른 경우 메시지에 대해 별도의 구성 변수를 추가하는 것이 좋습니다. 페이지 매김 논리는 내가 게시물에 사용한 것과 동일하므로 모두 친숙 할 것입니다.

위의보기 기능 은 아래에서 볼 수 있는 새로운 */app/templates/messages.html* 템플릿 파일 을 렌더링하여 종료됩니다 .

*app / templates / messages.html* : 메시지 HTML 템플릿을 봅니다.

```
{% extends "base.html" %}

{% block app_content %}
    <h1>{{ _('Messages') }}</h1>
    {% for post in messages %}
        {% include '_post.html' %}
    {% endfor %}
    <nav aria-label="...">
        <ul class="pager">
            <li class="previous{% if not prev_url %} disabled{% endif %}">
                <a href="{{ prev_url or '#' }}">
                    <span aria-hidden="true">&larr;</span> {{ _('Newer messages') }}
                </a>
            </li>
            <li class="next{% if not next_url %} disabled{% endif %}">
                <a href="{{ next_url or '#' }}">
                    {{ _('Older messages') }} <span aria-hidden="true">&rarr;</span>
                </a>
            </li>
        </ul>
    </nav>
{% endblock %}
```

여기서 나는 또 다른 작은 트릭에 의지했다. 추가 관계 를 얻는 것을 제외 `Post`하고 `Message`인스턴스 와 거의 동일한 구조를 가지고 있음을 알았 `Message`습니다 `recipient`(메시지는 항상 현재 사용자이므로 메시지 페이지에 표시 할 필요가 없습니다). 그래서 개인 메시지도 렌더링 하기 위해 *app / templates / _post.html* 하위 *템플릿* 을 재사용하기로 결정했습니다 . 이러한 이유로이 템플릿은 이상한 for-loop `for post in messages`을 사용하므로 `post`하위 템플릿에서 모든 참조 가 메시지와 함께 작동합니다.

사용자에게 새로운보기 기능에 대한 액세스 권한을 부여하기 위해 탐색 페이지에 새로운 "메시지"링크가 표시됩니다.

*app / templates / base.html* : 탐색 모음의 메시지 링크

```
                    {% if current_user.is_anonymous %}
                    ...
                    {% else %}
                    <li>
                        <a href="{{ url_for('main.messages') }}">
                            {{ _('Messages') }}
                        </a>
                    </li>
                    ...
                    {% endif %}
```

이 기능은 이제 완성되었지만 이러한 모든 변경 사항의 일부로 몇 군데에 추가 된 새로운 텍스트가 있었으며 언어 번역에 통합해야합니다. 첫 번째 단계는 모든 언어 카탈로그를 업데이트하는 것입니다.

```
(venv) $ flask translate update
```

그런 다음 *앱 / 번역* 의 각 언어 에는 새로운 번역으로 업데이트 된 *messages.po* 파일 이 있어야합니다 . 이 프로젝트의 GitHub 저장소 또는 [다운로드 zip 파일](https://github.com/miguelgrinberg/microblog/archive/version-0.21.zip) 에서 스페인어 번역을 찾을 수 있습니다 .

## 정적 메시지 알림 배지

이제 개인 메시지 기능이 구현되었지만 사용자에게 개인 메시지를 읽고 있음을 알리는 것은 없습니다. 부트 스트랩 배지 위젯을 사용하여 탐색 모음 표시기의 가장 간단한 구현을 기본 템플릿의 일부로 렌더링 할 수 있습니다.

*app / templates / base.html* : 탐색 모음의 정적 메시지 수 배지

```
                    ...
                    <li>
                        <a href="{{ url_for('main.messages') }}">
                            {{ _('Messages') }}
                            {% set new_messages = current_user.new_messages() %}
                            {% if new_messages %}
                            <span class="badge">{{ new_messages }}</span>
                            {% endif %}
                        </a>
                    </li>
                    ...
```

여기 에서는 템플릿에서 직접 위 `new_messages()`의 `User`모델에 추가 한 메서드 를 호출하고 해당 `new_messages`변수를 템플릿 변수 에 저장 합니다. 그런 다음 해당 변수가 0이 아닌 경우 메시지 링크 옆에 숫자가있는 배지를 추가하면됩니다. 이것이 페이지에서 어떻게 보이는지 보여줍니다 :

![메시지 배지](.\images\mega-tutorial/ch21-badge.png)

## 동적 메시지 알림 배지

이전 섹션에 제시된 솔루션은 알림을 표시하기에 적당하고 간단한 방법이지만 새 페이지가로드 될 때만 배지가 표시되는 단점이 있습니다. 사용자가 링크를 클릭하지 않고 한 페이지의 내용을 읽는 데 오랜 시간을 소비 한 경우 사용자가 링크를 클릭하고 새 페이지를로드 할 때까지 해당 시간 동안 오는 새 메시지가 표시되지 않습니다.

이 응용 프로그램을 내 사용자에게 더 유용하게 만들기 위해 사용자가 링크를 클릭하고 새 페이지를로드 할 필요없이 배지에서 읽지 않은 메시지 수를 자체적으로 업데이트하려고합니다. 이전 섹션의 솔루션에서 한 가지 문제점은로드 된 페이지의 메시지 수가 0이 아닌 경우에만 배지가 페이지에 렌더링된다는 것입니다. 가장 편리한 방법은 항상 탐색 표시 줄에 배지를 포함시키고 메시지 수가 0 일 때 숨겨진 것으로 표시하는 것입니다. 그러면 JavaScript를 사용하여 배지를 쉽게 볼 수 있습니다.

*app / templates / base.html* : JavaScript 친화적 인 읽지 않은 메시지 배지

```
                    <li>
                        <a href="{{ url_for('main.messages') }}">
                            {{ _('Messages') }}
                            {% set new_messages = current_user.new_messages() %}
                            <span id="message_count" class="badge"
                                  style="visibility: {% if new_messages %}visible
                                                     {% else %}hidden {% endif %};">
                                {{ new_messages }}
                            </span>
                        </a>
                    </li>
```

배지의이 버전, 난 항상 그것을 포함하지만, `visibility`CSS 속성으로 설정 `visible`하면 `new_messages`제로가 아닌, 또는 `hidden`제로됩니다. 또한 jQuery 선택기를 사용하여이 요소를 쉽게 처리 할 수 있도록 배지를 나타내는 요소에 `id`속성을 추가했습니다 .```$('#message_count')`

다음으로이 배지를 새로운 숫자로 업데이트하는 간단한 JavaScript 함수를 코딩 할 수 있습니다.

*app / templates / base.html* : 탐색 모음의 정적 메시지 수 배지

```
...
{% block scripts %}
    <script>
        // ...
        function set_message_count(n) {
            $('#message_count').text(n);
            $('#message_count').css('visibility', n ? 'visible' : 'hidden');
        }
    </script>
{% endblock %}
```

이 새로운 `set_message_count()`기능은 배지 요소의 메시지 수를 설정하고 카운트가 0 일 때 배지가 숨겨지고 그렇지 않으면 표시되도록 가시성을 조정합니다.

## 고객에게 알림 전달

남은 것은 클라이언트가 읽지 않은 메시지 수에 관한 정기적 인 업데이트를 클라이언트가받는 메커니즘을 추가하는 것입니다. 이러한 업데이트 중 하나가 발생하면 클라이언트는 `set_message_count()`함수를 호출 하여 업데이트를 사용자에게 알립니다.

실제로 서버가 클라이언트에 이러한 업데이트를 제공하는 방법에는 두 가지가 있으며, 추측 할 수 있듯이 장단점이 있으므로 선택할 수있는 방법은 프로젝트에 크게 좌우됩니다. 첫 번째 방법에서는 클라이언트가 비동기 요청을 보내 서버에 주기적으로 업데이트를 요청합니다. 이 요청의 응답은 클라이언트가 읽지 않은 메시지 수 배지와 같은 페이지의 다른 요소를 업데이트하는 데 사용할 수있는 업데이트 목록입니다. 두 번째 방법은 서버와 클라이언트 사이에 데이터를 자유롭게 푸시 할 수있는 클라이언트와 서버 간의 특수한 연결 유형이 필요합니다. 접근 방식에 관계없이 알림을 일반 엔터티로 취급하므로 읽지 않은 메시지 배지 외에 다른 유형의 이벤트를 지원하도록이 프레임 워크를 확장 할 수 있습니다.

첫 번째 솔루션의 가장 큰 장점은 구현하기 쉽다는 것입니다. JSON 알림 목록을 반환하는 */ notifications* 와 같이 응용 프로그램에 또 다른 경로를 추가 하기 만하면됩니다. 그런 다음 클라이언트 응용 프로그램은 알림 목록을 살펴보고 각 페이지에 필요한 변경 사항을 적용합니다. 이 솔루션의 단점은 클라이언트가 정기적으로 알림 목록을 요청하기 때문에 실제 이벤트와 알림 사이에 지연이 발생한다는 것입니다. 예를 들어, 클라이언트가 10 초마다 알림을 요청하는 경우 최대 10 초까지 알림을받을 수 있습니다.

두 번째 솔루션은 프로토콜 수준에서 변경이 필요합니다. HTTP에는 클라이언트가 요청하지 않고 서버가 클라이언트에 데이터를 전송하는 조항이 없기 때문입니다. 서버에서 시작된 메시지를 구현하는 가장 일반적인 방법은 서버를 확장하여 [WebSocket](https://en.wikipedia.org/wiki/WebSocket) 을 지원하는 것입니다.HTTP 외에 연결. WebSocket은 HTTP와 달리 서버와 클라이언트 사이에 영구적 인 연결을 설정하는 프로토콜입니다. 서버와 클라이언트는 상대방이 요구하지 않고 언제든지 상대방에게 데이터를 보낼 수 있습니다. 이 메커니즘의 장점은 클라이언트가 관심있는 이벤트가 발생할 때마다 지연없이 서버가 알림을 보낼 수 있다는 것입니다. 단점은 서버가 각각의 모든 클라이언트와 영구적 인 연결을 유지해야하기 때문에 WebSocket은 HTTP보다 복잡한 설정이 필요하다는 것입니다. 예를 들어 4 개의 작업자 프로세스가있는 서버는 일반적으로 수백 개의 HTTP 클라이언트에 서비스를 제공 할 수 있습니다. HTTP의 연결은 수명이 짧고 지속적으로 재활용되기 때문입니다. 동일한 서버는 단 4 개의 WebSocket 클라이언트를 처리 할 수 있습니다. 대다수의 경우에 충분하지 않을 것입니다. 이러한 제한 때문에 WebSocket 응용 프로그램은 일반적으로이 서버는 많은 수의 작업자 및 활성 연결을보다 효율적으로 관리하기 때문에 *비동기 서버* .

좋은 소식은 사용하는 방법에 관계없이 클라이언트에서 업데이트 목록과 함께 호출되는 콜백 함수를 갖게된다는 것입니다. 따라서 구현하기가 훨씬 쉬운 첫 번째 솔루션으로 시작할 수 있으며 나중에 충분하지 않은 경우 WebSocket 서버로 마이그레이션하여 동일한 클라이언트 콜백을 호출하도록 구성 할 수 있습니다. 제 생각에는 이러한 유형의 응용 프로그램에 대한 첫 번째 솔루션이 실제로 허용됩니다. WebSocket 기반 구현은 거의 지연 시간없이 업데이트를 제공해야하는 응용 프로그램에 유용합니다.

궁금한 점이 있으면 Twitter는 탐색 표시 줄 알림에 첫 번째 방법을 사용합니다. Facebook은 [long polling](https://en.wikipedia.org/wiki/Push_technology#Long_polling) 이라는 변형을 사용하는데 , 이는 HTTP 요청을 사용하면서 스트레이트 폴링의 일부 제한을 해결합니다. 스택 오버플로와 Trello는 알림을 위해 WebSocket을 구현하는 두 사이트입니다. 브라우저 디버거의 네트워크 탭에서 모든 사이트에서 발생하는 백그라운드 활동 유형을 찾을 수 있습니다.

계속해서 폴링 솔루션을 구현해 봅시다. 먼저 사용자 모델의 관계와 함께 모든 사용자의 알림을 추적하기 위해 새 모델을 추가하겠습니다.

*app / models.py* : 알림 모델.

```
import json
from time import time

# ...

class User(UserMixin, db.Model):
    # ...
    notifications = db.relationship('Notification', backref='user',
                                    lazy='dynamic')

    # ...

class Notification(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(128), index=True)
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'))
    timestamp = db.Column(db.Float, index=True, default=time)
    payload_json = db.Column(db.Text)

    def get_data(self):
        return json.loads(str(self.payload_json))
```

알림에는 이름, 관련 사용자, 유닉스 타임 스탬프 및 페이로드가 있습니다. 타임 스탬프는 `time.time()`함수 에서 기본값을 가져옵니다 . 페이로드는 각 유형의 알림마다 다를 것이므로 목록, 사전 또는 숫자 또는 문자열과 같은 단일 값을 쓸 수 있도록 JSON 문자열로 작성합니다. `get_data()`호출자가 JSON 역 직렬화에 대해 걱정할 필요가 없도록 메소드를 편의상 추가했습니다 .

이러한 변경 사항은 새 데이터베이스 마이그레이션에 포함되어야합니다.

```
(venv) $ flask db migrate -m "notifications"
(venv) $ flask db upgrade
```

편의상, 새로운 컨텍스트 `Message`와 `Notification`모델을 쉘 컨텍스트 에 추가 하여 `flask shell`명령 으로 쉘을 시작할 때 모델 클래스를 자동으로 가져옵니다.

*microblog.py* : 메시지 컨텍스트를 쉘 컨텍스트에 추가합니다.

```
# ...
from app.models import User, Post, Notification, Message

# ...

@app.shell_context_processor
def make_shell_context():
    return {'db': db, 'User': User, 'Post': Post, 'Message': Message,
            'Notification': Notification}
```

또한 `add_notification()`사용자 모델에 도우미 객체를 추가하여 이러한 객체를보다 쉽게 사용할 수 있도록하겠습니다.

*app / models.py* : 알림 모델.

```
class User(UserMixin, db.Model):
    # ...

    def add_notification(self, name, data):
        self.notifications.filter_by(name=name).delete()
        n = Notification(name=name, payload_json=json.dumps(data), user=self)
        db.session.add(n)
        return n
```

이 방법은 데이터베이스에 사용자에 대한 알림을 추가 할뿐만 아니라 동일한 이름의 알림이 이미 존재하는 경우 먼저 제거되도록합니다. 내가 작업 할 알림은이라고 `unread_message_count`합니다. 데이터베이스에이 이름의 알림 (예 : 값 3)이 이미있는 경우 사용자가 새 메시지를 받고 메시지 수가 4가 될 때마다 이전 알림을 바꾸고 싶습니다.

읽지 않은 메시지 수가 변경되는 곳에서는 `add_notification()`사용자에 대한 알림이 업데이트되도록 전화해야합니다 . 이 부분이 바뀌는 두 곳이 있습니다. 먼저 사용자가 새 개인 메시지를 받으면 `send_message()`보기 기능에서 다음을 수행하십시오.

*app / main / routes.py* : 사용자 알림을 업데이트합니다.

```
@bp.route('/send_message/<recipient>', methods=['GET', 'POST'])
@login_required
def send_message(recipient):
    # ...
    if form.validate_on_submit():
        # ...
        user.add_notification('unread_message_count', user.new_messages())
        db.session.commit()
        # ...
    # ...
```

사용자에게 알리는 두 번째 장소는 사용자가 메시지 페이지로 이동하는 시점이며 읽지 않은 횟수는 0으로 돌아갑니다.

*app / main / routes.py* : 메시지 경로를 봅니다.

```
@bp.route('/messages')
@login_required
def messages():
    current_user.last_message_read_time = datetime.utcnow()
    current_user.add_notification('unread_message_count', 0)
    db.session.commit()
    # ...
```

이제 사용자에 대한 모든 알림이 데이터베이스에 유지되므로 클라이언트가 로그인 한 사용자에 대한 알림을 검색하는 데 사용할 수있는 새로운 경로를 추가 할 수 있습니다.

*app / main / routes.py* : 알림보기 기능.

```
from app.models import Notification

# ...

@bp.route('/notifications')
@login_required
def notifications():
    since = request.args.get('since', 0.0, type=float)
    notifications = current_user.notifications.filter(
        Notification.timestamp > since).order_by(Notification.timestamp.asc())
    return jsonify([{
        'name': n.name,
        'data': n.get_data(),
        'timestamp': n.timestamp
    } for n in notifications])
```

이것은 사용자에 대한 알림 목록과 함께 JSON 페이로드를 반환하는 상당히 간단한 함수입니다. 각 알림은 알림 이름, 알림과 관련된 추가 데이터 (예 : 메시지 수) 및 타임 스탬프의 세 가지 요소가 포함 된 사전으로 제공됩니다. 통지는 작성된 순서대로 가장 오래된 것부터 최신 것까지 전달됩니다.

고객이 반복되는 알림을받지 않도록하기 위해 지정된 시간 이후 알림 만 요청할 수있는 옵션을 제공합니다. `since`옵션은 부동 소수점 숫자로 시작 시간의 유닉스 타임 스탬프와 요청 URL의 쿼리 문자열에 포함 할 수 있습니다. 이 인수가 포함 된 경우이 시간 이후에 발생한 알림 만 반환됩니다.

이 기능을 완성하는 마지막 단계는 클라이언트에서 실제 폴링을 구현하는 것입니다. 이를 수행하는 가장 좋은 장소는 기본 템플리트에 있으며 모든 페이지가 자동으로 동작을 상속합니다.

*app / templates / base.html* : 알림 폴링.

```
...
{% block scripts %}
    <script>
        // ...
        {% if current_user.is_authenticated %}
        $(function() {
            var since = 0;
            setInterval(function() {
                $.ajax('{{ url_for('main.notifications') }}?since=' + since).done(
                    function(notifications) {
                        for (var i = 0; i < notifications.length; i++) {
                            if (notifications[i].name == 'unread_message_count')
                                set_message_count(notifications[i].data);
                            since = notifications[i].timestamp;
                        }
                    }
                );
            }, 10000);
        });
        {% endif %}
    </script>
```

이 기능은 사용자가 로그인 할 때만 새 메시지를 폴링하기 위해 템플릿 조건부로 묶여 있습니다. 로그인하지 않은 사용자의 경우이 기능이 포함되지 않습니다.

이미 [20 장](https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-xx-some-javascript-magic)`$(function() { ...})` 에서 jQuery의 패턴을 보았습니다 . 페이지가로드 된 후 실행할 함수를 등록하는 방법입니다. 이 기능을 위해 페이지로드시해야 할 일은 사용자에게 알림을받는 일반 타이머를 설정하는 것입니다. 또한 특정 시간이 지난 후 인수로 제공된 함수를 실행 하는 JavaScript 함수를 보았습니다 . 이 함수는와 동일한 인수를 사용 하지만 타이머를 한 번만 실행하는 대신 규칙적인 간격으로 콜백 함수를 계속 호출합니다. 이 경우 내 간격은 10 초 (밀리 초 단위)로 설정되므로 분당 약 6 회 정도 배지가 업데이트됩니다.`setTimeout()``setInterval()``setTimeout()`

간격 타이머와 관련된 기능은 새 알림 경로에 대한 Ajax 요청을 발행하고 완료 콜백에서는 알림 목록을 반복합니다. 이름 `unread_message_count`이 포함 된 알림 이 수신되면 알림에 지정된 개수로 위에 정의 된 기능을 호출하여 메시지 개수 배지가 조정됩니다.

내가 `since`인수를 처리하는 방식 은 혼란 스러울 수 있습니다. 나는 인수는 항상 요청 URL에 포함되어 0이 인수를 초기화하여 시작,하지만 난 플라스크의를 사용하여 쿼리 문자열을 생성 할 수 없습니다 `url_for()`내가 전에 일 때문에 것 같은 `url_for()`한 번 서버에서 실행을하고, 나는 필요 `since`에 인수 동적으로 업데이트합니다. 처음에는 요청이 */ notifications? since = 0* 으로 전송 되지만 알림을 받자 마자 `since`타임 스탬프로 업데이트 됩니다. 이렇게하면 내가 마지막으로 본 알림 이후에 발생한 알림을 항상 받도록 요청하기 때문에 중복을받지 않습니다. 또한 내가 선언 한 것을 주목하는 것이 중요합니다`since` 이 함수가 로컬 변수가되기를 원하지 않기 때문에 모든 호출에 동일한 변수가 사용되기를 원합니다.

가장 쉬운 방법은 두 개의 다른 브라우저를 사용하는 것입니다. 다른 사용자를 사용하여 두 브라우저에서 모두 Microblog에 로그인하십시오. 그런 다음 브라우저 중 하나에서 하나 이상의 메시지를 다른 사용자에게 보냅니다. 다른 브라우저의 탐색 표시 줄이 10 초 이내에 보낸 메시지 수를 표시하도록 업데이트되어야합니다. 메시지 링크를 클릭하면 읽지 않은 메시지 수가 0으로 다시 재설정됩니다.



## [Part XXII: Background Jobs](https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-xxii-background-jobs)

Flask Mega-Tutorial 시리즈의 스물 두 번째 기사입니다. 웹 서버와 독립적으로 실행되는 백그라운드 작업을 만드는 방법을 알려 드리겠습니다.

이 장은 응용 프로그램의 일부로 실행해야하는 길거나 복잡한 프로세스의 구현에 전념합니다. 이러한 프로세스는 작업 기간 동안 클라이언트에 대한 응답을 차단하기 때문에 요청 컨텍스트에서 동 기적으로 실행될 수 없습니다. [10 장](https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-x-email-support) 에서이 주제에 대해 간략하게 살펴 보았습니다. 이메일 발송을 백그라운드 스레드로 이동하여 클라이언트가 이메일을 보내는 데 걸리는 3-4 초 동안 기다리지 않아도되도록했습니다. 전자 메일에 스레드를 사용할 수는 있지만 문제의 프로세스가 훨씬 길면이 솔루션이 제대로 확장되지 않습니다. 허용되는 방법은 긴 작업을 작업자 프로세스 또는 그 풀에 오프로드하는 것입니다.

장시간 실행되는 작업의 필요성을 정당화하기 위해 사용자가 모든 블로그 게시물과 함께 데이터 파일을 요청할 수있는 내보내기 기능을 Microblog에 도입하려고합니다. 사용자가이 옵션을 사용하면 응용 프로그램은 내보내기 작업을 시작하여 모든 사용자의 게시물이 포함 된 JSON 파일을 생성 한 다음 전자 메일로 사용자에게 보냅니다. 이 모든 활동은 작업자 프로세스에서 진행되며,이 과정에서 완료율을 보여주는 알림이 표시됩니다.

*이 장의 GitHub 링크는 [Browse](https://github.com/miguelgrinberg/microblog/tree/v0.22) , [Zip](https://github.com/miguelgrinberg/microblog/archive/v0.22.zip) , [Diff](https://github.com/miguelgrinberg/microblog/compare/v0.21...v0.22) 입니다.*

## 작업 대기열 소개

작업 대기열은 응용 프로그램이 *작업자 프로세스에* 의해 작업 실행을 요청하는 편리한 솔루션을 제공합니다 . 작업자 프로세스는 응용 프로그램과 독립적으로 실행되며 다른 시스템에 위치 할 수도 있습니다. 응용 프로그램과 작업자 간의 통신은 *메시지 큐를* 통해 수행 *됩니다* . 응용 프로그램은 작업을 제출 한 후 큐와 상호 작용하여 진행 상황을 모니터합니다. 다음 다이어그램은 일반적인 구현을 보여줍니다.

![작업 대기열 다이어그램](.\images\mega-tutorial/ch22-queue-diagram.png)

Python에서 가장 많이 사용되는 작업 대기열은 [Celery](http://www.celeryproject.org/) 입니다. 이것은 많은 옵션을 가지고 있으며 여러 메시지 대기열을 지원하는 상당히 정교한 패키지입니다. 널리 사용되는 또 다른 Python 작업 대기열은 [Redis 대기열](http://python-rq.org/) 또는 RQ이며, [Redis](https://redis.io/) 메시지 대기열 만 지원하는 등 일부 유연성을 희생 하지만 대신 Celery보다 설정이 훨씬 간단합니다.

Celery와 RQ는 Flask 응용 프로그램에서 백그라운드 작업을 지원하기에 완벽하게 적합하므로이 응용 프로그램에 대한 선택은 RQ의 단순성을 선호합니다. 그러나 Celery와 동일한 기능을 구현하는 것은 비교적 쉽습니다. RQ 이상의 Celery에 관심이 있다면 블로그에있는 [Celery with Flask 사용](https://blog.miguelgrinberg.com/post/using-celery-with-flask) 기사를 읽을 수 있습니다 .

## RQ 사용

RQ는 표준 Python 패키지이며 `pip`다음 과 함께 설치됩니다 .

```
(venv) $ pip install rq
(venv) $ pip freeze > requirements.txt
```

앞에서 언급했듯이 애플리케이션과 RQ 작업자 간의 통신은 Redis 메시지 대기열에서 수행되므로 Redis 서버를 실행해야합니다. 한 번의 클릭으로 설치 프로그램에서 소스 코드를 다운로드하여 시스템에서 직접 컴파일하는 방법에 이르기까지 Redis 서버를 설치하고 실행하는 많은 옵션이 있습니다. Windows를 사용하는 경우 Microsoft는 [여기에서](https://github.com/MicrosoftArchive/redis/releases) 설치 관리자를 유지 관리 [합니다](https://github.com/MicrosoftArchive/redis/releases) . Linux에서는 운영 체제의 패키지 관리자를 통해 패키지로 얻을 수 있습니다. Mac OS X 사용자는 명령을 사용 `brew install redis`하여 서비스를 수동으로 실행 한 다음 시작할 수 있습니다 `redis-server`.

서비스가 실행 중이고 RQ에 액세스 할 수 있도록하는 것 외에는 Redis와 상호 작용할 필요가 없습니다.

RQ는 Windows 기본 Python 인터프리터에서 실행되지 않습니다. Windows 플랫폼을 사용하는 경우 Unix 에뮬레이션에서만 RQ를 실행할 수 있습니다. Windows 사용자에게 권장하는 두 가지 Unix 에뮬레이션 계층은 [Cygwin](https://cygwin.org/) 및 [Linux 용 Windows 서브 시스템 (WSL)](https://msdn.microsoft.com/en-us/commandline/wsl/about) 이며 둘 다 RQ와 호환됩니다.

### 작업 만들기

RQ를 통해 간단한 작업을 실행하여 익숙해지는 방법을 보여 드리겠습니다. 작업은 파이썬 함수에 지나지 않습니다. 다음은 새로운 *app / tasks.py* 모듈 에 넣을 예제 작업입니다 .

*app / tasks.py* : 백그라운드 작업 예.

```
import time

def example(seconds):
    print('Starting task')
    for i in range(seconds):
        print(i)
        time.sleep(1)
    print('Task completed')
```

이 작업은 인수로 몇 초가 걸린 다음 해당 시간 동안 대기하여 1 초에 카운터를 인쇄합니다.

### RQ 작업자 운영

이제 작업이 준비되었으므로 작업자를 시작할 수 있습니다. 이것은 다음 `rq worker`명령 으로 수행됩니다 .

```
(venv) $ rq worker microblog-tasks
18:55:06 RQ worker 'rq:worker:miguelsmac.90369' started, version 0.9.1
18:55:06 Cleaning registries for queue: microblog-tasks
18:55:06
18:55:06 *** Listening on microblog-tasks...
```

작업자 프로세스가 이제 Redis에 연결되고라는 대기열에서 할당 된 작업을 감시합니다 `microblog-tasks`. 여러 작업자가 더 많은 처리량을 갖기를 원할 경우 `rq worker`, 동일한 대기열에 연결된 더 많은 인스턴스를 실행하기 만하면 됩니다. 그런 다음 작업이 대기열에 표시되면 사용 가능한 작업자 프로세스가 작업을 선택합니다. 프로덕션 환경에서는 최소한 사용 가능한 CPU 수만큼 작업자를 원할 것입니다.

### 작업 실행

이제 두 번째 터미널 창을 열고 가상 환경을 활성화하십시오. 셸 세션을 사용 `example()`하여 작업자 의 작업 을 시작하겠습니다 .

```
>>> from redis import Redis
>>> import rq
>>> queue = rq.Queue('microblog-tasks', connection=Redis.from_url('redis://'))
>>> job = queue.enqueue('app.tasks.example', 23)
>>> job.get_id()
'c651de7f-21a8-4068-afd5-8b982a6f6d32'
```

`Queue`RQ 의 클래스는 응용 프로그램 측에서 볼 때 작업 대기열을 나타냅니다. 인수는 대기열 이름과 `Redis`연결 객체이며,이 경우 기본 URL로 초기화됩니다. Redis 서버가 다른 호스트 또는 포트 번호에서 실행중인 경우 다른 URL을 사용해야합니다.

`enqueue()`큐 의 메소드는 큐에 작업을 추가하는 데 사용됩니다. 첫 번째 인수는 함수 객체 또는 가져 오기 문자열로 직접 제공 할 실행하려는 작업의 이름입니다. 문자열 옵션이 훨씬 편리하다는 것을 알았습니다. 응용 프로그램 측에서 함수를 가져올 필요가 없기 때문입니다. 주어진 나머지 인수 `enqueue()`는 워커에서 실행되는 함수로 전달됩니다.

`enqueue()`전화를 걸 자마자 RQ 작업자를 실행하는 첫 번째 터미널 창에서 일부 활동을 알 수 있습니다. 이제 `example()`기능이 실행 중이며 초당 1 회 카운터를 인쇄하는 것을 볼 수 있습니다. 동시에 다른 터미널은 차단되지 않으며 쉘에서 표현식을 계속 평가할 수 있습니다. 위의 예 `job.get_id()`에서 작업에 할당 된 고유 식별자를 얻기 위해 메서드를 호출했습니다 . `job`객체로 시도 할 수있는 또 다른 흥미로운 표현 은 작업자의 기능이 완료되었는지 확인하는 것입니다.

```
>>> job.is_finished
False
```

`23`위의 예제에서와 같이 전달 하면 함수가 약 23 초 동안 실행됩니다. 그 후에는 `job.is_finished`표현이됩니다 `True`. 꽤 멋지지 않습니까? RQ의 단순함을 정말 좋아합니다.

기능이 완료되면 작업자는 새 작업을 기다리는 상태로 돌아가므로 `enqueue()`더 많은 실험을 원할 경우 다른 인수로 호출을 반복 할 수 있습니다 . 작업과 관련하여 대기열에 저장된 데이터는 일정 시간 (기본적으로 500 초) 동안 유지되지만 결국 제거됩니다. 작업 대기열이 실행 된 작업 기록을 보존하지 않는 것이 중요합니다.

### 보고 작업 진행

위에서 사용한 예제 작업은 비현실적으로 간단합니다. 일반적으로 장기 실행 작업의 경우 응용 프로그램에서 일종의 진행 정보를 사용하여 사용자에게 표시 할 수 있습니다. RQ는 `meta`작업 오브젝트 의 속성을 사용하여이를 지원 합니다. `example()`진행률 보고서를 작성하기 위해 작업을 다시 작성하겠습니다 .

*app / tasks.py* : 진행중인 백그라운드 작업 예.

```
import time
from rq import get_current_job

def example(seconds):
    job = get_current_job()
    print('Starting task')
    for i in range(seconds):
        job.meta['progress'] = 100.0 * i / seconds
        job.save_meta()
        print(i)
        time.sleep(1)
    job.meta['progress'] = 100
    job.save_meta()
    print('Task completed')
```

이 새 버전 `example()`은 RQ의 `get_current_job()`기능을 사용 하여 작업 인스턴스를 가져옵니다. 이는 작업을 제출할 때 응용 프로그램으로 리턴되는 것과 유사합니다. `meta`작업 오브젝트 의 속성은 태스크가 애플리케이션과 통신하려는 사용자 정의 데이터를 작성할 수있는 사전입니다. 이 예에서는 `progress`작업 완료율을 나타내는 항목을 작성하고 있습니다. 진행 상황이 업데이트 될 때마다 `job.save_meta()`RQ에게 데이터를 Redis에 쓰도록 지시합니다.

응용 프로그램 측 (현재는 Python 쉘) 에서이 작업을 실행 한 다음 다음과 같이 진행 상황을 모니터링 할 수 있습니다.

```
>>> job = queue.enqueue('app.tasks.example', 23)
>>> job.meta
{}
>>> job.refresh()
>>> job.meta
{'progress': 13.043478260869565}
>>> job.refresh()
>>> job.meta
{'progress': 69.56521739130434}
>>> job.refresh()
>>> job.meta
{'progress': 100}
>>> job.is_finished
True
```

위에서 볼 수 있듯이이 측면에서 `meta`속성을 읽을 수 있습니다. `refresh()`방법은 내용이 레디 스에서 업데이트 될 때까지 호출 할 필요가있다.

## 작업의 데이터베이스 표현

위의 예에서는 작업을 시작하고 실행하는 것으로 충분했습니다. 웹 응용 프로그램의 경우 이러한 작업 중 하나가 요청의 일부로 시작되면 요청이 종료되고 해당 작업의 모든 컨텍스트가 손실되므로 상황이 조금 더 복잡해집니다. 응용 프로그램에서 각 사용자가 실행중인 작업을 추적하기를 원하므로 데이터베이스 테이블을 사용하여 일부 상태를 유지해야합니다. 아래에서 새로운 `Task`모델 구현을 볼 수 있습니다 .

*app / models.py* : 작업 모델.

```
# ...
import redis
import rq

class User(UserMixin, db.Model):
    # ...
    tasks = db.relationship('Task', backref='user', lazy='dynamic')

# ...

class Task(db.Model):
    id = db.Column(db.String(36), primary_key=True)
    name = db.Column(db.String(128), index=True)
    description = db.Column(db.String(128))
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'))
    complete = db.Column(db.Boolean, default=False)

    def get_rq_job(self):
        try:
            rq_job = rq.job.Job.fetch(self.id, connection=current_app.redis)
        except (redis.exceptions.RedisError, rq.exceptions.NoSuchJobError):
            return None
        return rq_job

    def get_progress(self):
        job = self.get_rq_job()
        return job.meta.get('progress', 0) if job is not None else 100
```

이 모델과 이전 모델의 흥미로운 차이점은 `id`기본 키 필드는 정수가 아니라 문자열이라는 것입니다. 이 모델의 경우 데이터베이스 자체의 기본 키 생성에 의존하지 않고 RQ에서 생성 한 작업 식별자를 사용하기 때문입니다.

모델은 작업의 정규화 된 이름 (RQ에 전달됨), 사용자에게 표시하기에 적합한 작업에 대한 설명, 작업을 요청한 사용자와의 관계 및 작업이 완료되었는지 여부를 나타내는 부울을 저장합니다. 또는 아닙니다. `complete`실행중인 작업은 진행률 업데이트를 표시하기 위해 특별한 처리가 필요하므로이 필드 의 목적은 현재 실행중인 작업과 종료 된 작업을 분리하는 것입니다.

이 `get_rq_job()`메소드는 `Job`주어진 작업 ID에서 RQ 인스턴스 를로드하는 도우미 메소드이며 모델에서 얻을 수 있습니다. 이 작업 은 Redis에 존재하는 데이터 `Job.fetch()`에서 `Job`인스턴스 를로드하는 로 수행됩니다 . 이 `get_progress()`메소드 `get_rq_job()`는 작업 위에 빌드되고 진행률을 반환합니다. 이 방법에는 몇 가지 흥미로운 가정이 있습니다. 모델의 작업 ID가 RQ 큐에 없으면 작업이 이미 완료되고 데이터가 만료되어 큐에서 제거 된 것이므로이 경우 반환 된 백분율은 100입니다. 작업이 존재하지만 관련 정보가 없습니다.`meta` 속성이있는 경우 작업이 실행되도록 예약되었지만 아직 시작할 기회를 얻지 못했다고 가정하는 것이 안전하므로 해당 상황에서 0이 진행 상태로 리턴됩니다.

데이터베이스 스키마에 변경 사항을 적용하려면 새 마이그레이션을 생성 한 후 데이터베이스를 업그레이드해야합니다.

```
(venv) $ flask db migrate -m "tasks"
(venv) $ flask db upgrade
```

새로운 모델을 쉘 컨텍스트에 추가하여 모델을 가져 오지 않고도 쉘 세션에서 액세스 할 수 있습니다.

*microblog.py* : 쉘 컨텍스트에 태스크 모델을 추가하십시오.

```
from app import create_app, db, cli
from app.models import User, Post, Message, Notification, Task

app = create_app()
cli.register(app)

@app.shell_context_processor
def make_shell_context():
    return {'db': db, 'User': User, 'Post': Post, 'Message': Message,
            'Notification': Notification, 'Task': Task}
```

## Flask 애플리케이션과 RQ 통합

Redis 서비스의 연결 URL을 구성에 추가해야합니다.

```
class Config(object):
    # ...
    REDIS_URL = os.environ.get('REDIS_URL') or 'redis://'
```

항상 그렇듯이 Redis 연결 URL은 환경 변수에서 제공되며 변수가 정의되지 않은 경우 서비스가 동일한 호스트 및 기본 포트에서 실행되고 있다고 가정하는 기본 URL이 사용됩니다.

애플리케이션 팩토리 기능은 Redis 및 RQ 초기화를 담당합니다.

*app / __ init__.py* : RQ 통합.

```
# ...
from redis import Redis
import rq

# ...

def create_app(config_class=Config):
    # ...
    app.redis = Redis.from_url(app.config['REDIS_URL'])
    app.task_queue = rq.Queue('microblog-tasks', connection=app.redis)

    # ...
```

는 `app.task_queue`작업이 제출 된 큐가 될 것입니다. 응용 프로그램에 대기열을 첨부하면 응용 프로그램의 어느 곳에서나 `current_app.task_queue`액세스 할 수 있기 때문에 편리 합니다. 응용 프로그램의 어느 부분에서나 작업을 쉽게 제출하거나 확인할 수 있도록 `User`모델 에서 몇 가지 도우미 메서드를 만들 수 있습니다 .

*app / models.py* : 사용자 모델의 작업 도우미 메서드

```
# ...

class User(UserMixin, db.Model):
    # ...

    def launch_task(self, name, description, *args, **kwargs):
        rq_job = current_app.task_queue.enqueue('app.tasks.' + name, self.id,
                                                *args, **kwargs)
        task = Task(id=rq_job.get_id(), name=name, description=description,
                    user=self)
        db.session.add(task)
        return task

    def get_tasks_in_progress(self):
        return Task.query.filter_by(user=self, complete=False).all()

    def get_task_in_progress(self, name):
        return Task.query.filter_by(name=name, user=self,
                                    complete=False).first()
```

이 `launch_task()`메소드는 태스크를 데이터베이스에 추가하면서 RQ 큐에 태스크를 제출합니다. `name`에 정의 된 인수는 함수 이름입니다 *응용 프로그램 / tasks.py* . RQ에 제출할 때 함수는 `app.tasks.`이 이름 앞에 추가 하여 완전한 함수 이름을 빌드합니다. `description`인수는 사용자에게 제공 될 수있는 작업의 친절한 설명입니다. 블로그 게시물을 내보내는 함수의 이름 `export_posts`과 설명을 로 설정합니다 `Exporting posts...`. 나머지 인수는 작업에 전달 될 위치 및 키워드 인수입니다. 함수는 `enqueue()`작업을 제출하기 위해 큐의 메소드를 호출하여 시작합니다 . 반환 된 작업 객체에는 RQ에 의해 할당 된 작업 ID가 포함되어 있으므로 해당 작업 객체를 생성하는 데 사용할 수 있습니다`Task` 내 데이터베이스의 개체.

참고 `launch_task()`세션에 새 작업 개체를 추가하지만 그것은 커밋 발행하지 않습니다. 일반적으로 하위 레벨 기능으로 작성된 여러 갱신 사항을 단일 트랜잭션으로 결합 할 수 있으므로 상위 레벨 기능으로 데이터베이스 세션에서 작동하는 것이 가장 좋습니다. 이것은 엄격한 규칙이 아니며 실제로이 장의 후반에 하위 함수에서 커밋이 발행되는 예외를 보게 될 것입니다.

이 `get_tasks_in_progress()`메소드는 사용자에게 미해결 된 전체 기능 목록을 리턴합니다. 나중에이 방법을 사용하여 사용자에게 렌더링되는 페이지에서 작업 실행에 대한 정보를 포함시키는 것을 볼 수 있습니다.

마지막으로, `get_task_in_progress()`특정 작업을 반환하는 이전 버전보다 간단한 버전입니다. 사용자가 동일한 유형의 둘 이상의 작업을 동시에 시작하지 못하도록하므로 작업을 시작하기 전에이 방법을 사용하여 이전 작업이 현재 실행 중인지 확인할 수 있습니다.

## RQ 작업에서 이메일 보내기

이것은 주요 주제를 산만하게하는 것처럼 보일 수 있지만 백그라운드 내보내기 작업이 완료되면 모든 게시물이 포함 된 JSON 파일과 함께 전자 메일이 사용자에게 전송된다고 위에서 말했습니다. [11 장](https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-xi-facelift) 에서 만든 전자 메일 기능 은 두 가지 방법으로 확장해야합니다. 먼저 파일 첨부에 대한 지원을 추가해야 JSON 파일을 첨부 할 수 있습니다. 둘째,이 `send_email()`함수는 백그라운드 스레드를 사용하여 항상 전자 메일을 비동기 적으로 보냅니다. 이미 비동기적인 백그라운드 작업에서 전자 메일을 보내려고 할 때 스레드를 기반으로 두 번째 수준의 백그라운드 작업을 수행하는 것은 의미가 없으므로 동기 및 비동기 전자 메일 전송을 모두 지원해야합니다.

다행히 Flask-Mail은 첨부 파일을 지원하므로 `send_email()`추가 인수로 가져 와서 `Message`객체 에서 구성 하는 기능을 확장 하기 만하면됩니다 . 선택적으로 포 그라운드에서 이메일을 보내려면 부울 `sync`인수 를 추가하면됩니다 .

*app / email.py* : 첨부 파일이있는 이메일을 보냅니다.

```
# ...

def send_email(subject, sender, recipients, text_body, html_body,
               attachments=None, sync=False):
    msg = Message(subject, sender=sender, recipients=recipients)
    msg.body = text_body
    msg.html = html_body
    if attachments:
        for attachment in attachments:
            msg.attach(*attachment)
    if sync:
        mail.send(msg)
    else:
        Thread(target=send_async_email,
            args=(current_app._get_current_object(), msg)).start()
```

클래스 의 `attach()`메소드 `Message`는 첨부 파일을 정의하는 세 개의 인수, 파일 이름, 매체 유형 및 실제 파일 데이터를 허용합니다. 파일 이름은받는 사람이 첨부 파일과 관련된 이름 일 뿐이므로 실제 파일 일 필요는 없습니다. 미디어 유형은이 유형의 첨부 파일을 정의하므로 전자 메일 리더가이를 적절하게 렌더링하는 데 도움이됩니다. 예를 들어 `image/png`미디어 유형으로 전송 하는 경우 전자 메일 리더는 첨부 파일이 이미지임을 알 수 있으며이 경우 이미지를 그대로 표시 할 수 있습니다. 블로그 게시물 데이터 파일에는 `application/json`미디어 형식을 사용하는 JSON 형식을 사용하겠습니다 . 세 번째 및 마지막 인수는 첨부 내용이 포함 된 문자열 또는 바이트 시퀀스입니다.

간단히하기 위해 `attachments`인수 `send_email()`는 튜플 목록이되고 각 튜플에는의 세 인수에 해당하는 세 가지 요소가 `attach()`있습니다. 따라서이 목록의 각 요소에 대해 튜플을 인수로 보내야합니다 `attach()`. 파이썬에서 함수로 보내려는 인수가있는 목록이나 튜플이 `func(*args)`있는 경우과 같은 지루한 구문을 사용하지 않고 해당 인수를 실제 인수 목록으로 확장 할 수 있습니다 `func(args[0], args[1], args[2])`. 예를 들어,가있는 경우 `args = [1, 'foo']`호출은 호출 한 것과 같은 두 개의 인수를 보냅니다 `func(1, 'foo')`. 이 없으면 `*`호출에는 목록이 될 단일 인수가 있습니다.

전자 메일을 동기식으로 보내는 한, 내가해야 할 일은 is 일 `mail.send(msg)`때 직접 전화로 되 돌리는 것 `sync`입니다 `True`.

## 작업 도우미

그동안 `example()`내가 위에서 사용하는 작업이 간단한 스탠드 얼론 기능이고, 수출이 게시물을 블로그하는 기능은 데이터베이스와 이메일 전송 기능에 액세스 할 수처럼, 내가 응용 프로그램에서이 기능의 일부를 필요로 할 것이다. 이 작업은 별도의 프로세스에서 실행되므로 Flask-SQLAlchemy 및 Flask-Mail을 초기화해야합니다. Flask-SQLAlchemy 및 Flask-Mail은 구성을 가져 오는 Flask 응용 프로그램 인스턴스가 필요합니다. 따라서 *app / tasks.py* 모듈 의 맨 위에 Flask 응용 프로그램 인스턴스 및 응용 프로그램 컨텍스트를 추가 *하겠습니다* .

*app / tasks.py* : 응용 프로그램 및 컨텍스트를 만듭니다.

```
from app import create_app

app = create_app()
app.app_context().push()
```

RQ 작업자가 가져올 유일한 모듈이기 때문에이 모듈에서 애플리케이션이 작성됩니다. `flask`명령 을 사용하면 루트 디렉토리 의 *microblog.py* 모듈이 애플리케이션을 작성하지만 RQ 작업자는 이에 대해 아무것도 알지 못하므로 태스크 기능에 필요한 경우 자체 애플리케이션 인스턴스를 작성해야합니다. 당신은 본 `app.app_context()`문맥을 밀어하면 응용 프로그램이 "현재"응용 프로그램 인스턴스가 될 수 있습니다, 이것은 사용하는 등 플라스크-SQLAlchemy의 등의 확장을 가능하게 이미 장소의 몇 방법을 `current_app.config`자신의 구성을 얻었다. 컨텍스트가 없으면 `current_app`표현식은 오류를 리턴합니다.

그런 다음이 기능이 실행되는 동안 진행 상황을보고 할 방법에 대해 생각하기 시작했습니다. `job.meta`사전을 통해 진행 정보를 전달하는 것 외에도 사용자에게 페이지를 새로 고치지 않고도 완료 비율을 동적으로 업데이트 할 수 있도록 알림을 클라이언트에 푸시하고 싶습니다. 이를 위해 [21 장](https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-xxi-user-notifications) 에서 만든 알림 메커니즘을 사용하겠습니다 . 업데이트는 읽지 않은 메시지 배지와 매우 유사한 방식으로 작동합니다. 서버가 템플릿을 렌더링 할 때 템플릿에서 얻은 "정적"진행 정보가 포함됩니다.`job.meta`페이지가 클라이언트 브라우저에 있으면 알림은 알림을 사용하여 백분율을 동적으로 업데이트합니다. 알림으로 인해 실행중인 작업의 진행률 업데이트가 이전 예제에서 수행 한 방법보다 약간 더 복잡해 지므로 진행률 업데이트 전용 래퍼 함수를 만듭니다.

*app / tasks.py* : 작업 진행률을 설정합니다.

```
from rq import get_current_job
from app import db
from app.models import Task

# ...

def _set_task_progress(progress):
    job = get_current_job()
    if job:
        job.meta['progress'] = progress
        job.save_meta()
        task = Task.query.get(job.get_id())
        task.user.add_notification('task_progress', {'task_id': job.get_id(),
                                                     'progress': progress})
        if progress >= 100:
            task.complete = True
        db.session.commit()
```

내보내기 작업은 `_set_task_progress()`진행률을 기록하기 위해 호출 할 수 있습니다 . 이 함수는 먼저 `job.meta`사전에 백분율을 기록하고 이를 Redis에 저장 한 다음 데이터베이스에서 해당 작업 개체를로드 `task.user`하고 기존 `add_notification()`방법을 사용하여 작업을 요청한 사용자에게 알림을 보내는 데 사용합니다 . 알림의 이름 `task_progress`은이고 알림 과 관련된 데이터는 작업 식별자와 진행 번호의 두 항목이 포함 된 사전이됩니다. 나중에이 새로운 알림 유형에 적용 할 JavaScript 코드를 추가 할 것입니다.

함수는 진행률이 함수가 완료되었음을 표시하는지 확인하고이 경우 `complete`데이터베이스에서 태스크 오브젝트 의 속성 도 업데이트 합니다. 데이터베이스 커밋 호출은 작업과 추가 된 알림 개체 `add_notification()`가 모두 데이터베이스에 즉시 저장되도록합니다. 이 커밋 호출은 데이터베이스를 변경하지 않도록 부모 작업을 디자인하는 방법에 매우주의를 기울여야했습니다.

## 내보내기 작업 구현

이제 모든 기능이 내보내기 기능을 작성할 수 있도록 준비되었습니다. 이 기능의 상위 레벨 구조는 다음과 같습니다.

*app / tasks.py* : 게시물 일반 구조를 내 *보냅니다* .

```
def export_posts(user_id):
    try:
        # read user posts from database
        # send email with data to user
    except:
        # handle unexpected errors
```

전체 작업을 try / except 블록으로 감싸는 이유는 무엇입니까? Flask 자체가 예외를 포착 한 다음 응용 프로그램에 대해 설정 한 오류 처리기와 로깅 구성을 관찰하여 요청 처리기에 존재하는 응용 프로그램 코드가 예기치 않은 오류로부터 보호됩니다. 그러나이 기능은 Flask가 아닌 RQ에 의해 제어되는 별도의 프로세스에서 실행되므로 예기치 않은 오류가 발생하면 작업이 중단되고 RQ는 오류를 콘솔에 표시 한 다음 다시 새 항목을 기다립니다. 직업. 따라서 기본적으로 RQ 작업자의 출력을 보거나 파일에 로깅하지 않으면 오류가 없다는 것을 알 수 없습니다.

위의 주석으로 표시된 세 섹션을 가장 간단한 섹션으로 시작해 봅시다. 마지막 부분의 오류 처리입니다.

*app / tasks.py* : 게시물 게시 오류 처리.

```
import sys
# ...

def export_posts(user_id):
    try:
        # ...
    except:
        _set_task_progress(100)
        app.logger.error('Unhandled exception', exc_info=sys.exc_info())
```

예기치 않은 오류가 발생할 때마다 진행률을 100 %로 설정하여 작업을 완료된 것으로 표시 한 다음 Flask 응용 프로그램의 로거 개체를 사용하여 스택 추적과 함께 오류를 기록합니다. `sys.exc_info()`전화. Flask 응용 프로그램 로거를 사용하여 오류를 기록 할 때의 좋은 점은 Flask 응용 프로그램에 대해 구현 한 로깅 메커니즘이 관찰된다는 것입니다. 예를 들어, [7 장](https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-vii-error-handling) 에서 관리자 이메일 주소로 오류가 전송되도록 구성했습니다. 사용하여 `app.logger`이러한 오류에 대한 동작도 얻습니다.

다음으로 데이터베이스 내보내기를 실행하고 결과를 루프로 안내하여 사전에 누적하는 실제 내보내기를 코딩합니다.

*app / tasks.py* : 데이터베이스에서 사용자 게시물을 읽습니다.

```
import time
from app.models import User, Post

# ...

def export_posts(user_id):
    try:
        user = User.query.get(user_id)
        _set_task_progress(0)
        data = []
        i = 0
        total_posts = user.posts.count()
        for post in user.posts.order_by(Post.timestamp.asc()):
            data.append({'body': post.body,
                         'timestamp': post.timestamp.isoformat() + 'Z'})
            time.sleep(5)
            i += 1
            _set_task_progress(100 * i // total_posts)

        # send email with data to user
    except:
        # ...
```

각 게시물에 대해 함수에는 게시물 본문과 게시물이 작성된 시간이라는 두 가지 요소가 포함 된 사전이 포함됩니다. 시간은 [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) 표준 으로 작성 될 예정 입니다. `datetime`내가 사용하는 Python의 객체는 시간대를 저장하지 않으므로 ISO 형식으로 시간을 내 보낸 후 UTC를 나타내는 'Z'를 추가합니다.

진행 상황을 추적해야하기 때문에 코드가 약간 복잡해집니다. 카운터를 유지하고 `i`루프 수를 입력하여 `total_posts`게시물 수를 늘리기 전에 추가 데이터베이스 쿼리를 발행해야합니다 . 사용 `i`하고 `total_posts`, 각 루프 반복은 0에서 100까지의 숫자와 작업 진행 상황을 업데이트 할 수 있습니다.

`time.sleep(5)`각 루프 반복마다 호출을 추가했음을 알 수 있습니다 . 내가 잠을 더한 주된 이유는 내보내기 작업이 더 오래 지속되고 내보내기가 블로그 게시물의 일부만 다루더라도 진행 상황이 올라가는 것을 볼 수 있기 때문입니다.

아래에서 함수의 마지막 부분을 볼 수 `data`있으며, 첨부 파일로 수집 된 모든 정보가 포함 된 전자 메일을 사용자에게 보냅니다 .

*app / tasks.py* : 사용자에게 게시물을 이메일로 *보냅니다* .

```
import json
from flask import render_template
from app.email import send_email

# ...

def export_posts(user_id):
    try:
        # ...

        send_email('[Microblog] Your blog posts',
                sender=app.config['ADMINS'][0], recipients=[user.email],
                text_body=render_template('email/export_posts.txt', user=user),
                html_body=render_template('email/export_posts.html', user=user),
                attachments=[('posts.json', 'application/json',
                              json.dumps({'posts': data}, indent=4))],
                sync=True)
    except:
        # ...
```

이것은 단순히 `send_email()`함수를 호출하는 것입니다. 첨부 파일은 세 가지 요소가 포함 된 튜플로 정의 된 다음 `attach()`Flask-Mail의 `Message`개체 메서드 로 전달됩니다 . 튜플의 세 번째 요소는 첨부 파일 내용으로, Python `json.dumps()`함수 로 생성됩니다 .

전자 메일 본문의 내용을 일반 텍스트 및 HTML 형식으로 제공하는 새로운 템플릿 쌍이 여기에 참조됩니다. 다음은 텍스트 템플릿입니다.

*app / templates / email / export_posts.txt* : 게시물 텍스트 이메일 템플릿 내보내기.

```
Dear {{ user.username }},

Please find attached the archive of your posts that you requested.

Sincerely,

The Microblog Team
```

이메일의 HTML 버전은 다음과 같습니다.

*app / templates / email / export_posts.html* : 게시물 HTML 이메일 템플릿 내보내기

```
<p>Dear {{ user.username }},</p>
<p>Please find attached the archive of your posts that you requested.</p>
<p>Sincerely,</p>
<p>The Microblog Team</p>
```

## 응용 프로그램의 내보내기 기능

백그라운드 익스포트 작업을 지원하는 모든 핵심 요소가 이제 제자리에 있습니다. 남은 것은이 기능을 애플리케이션에 연결하여 사용자가 게시물을 이메일로 요청하도록 할 수 있다는 것입니다.

아래에서 새로운 `export_posts`보기 기능을 볼 수 있습니다.

*app / main / routes.py* : 게시물 경로 및보기 기능 내보내기

```
@bp.route('/export_posts')
@login_required
def export_posts():
    if current_user.get_task_in_progress('export_posts'):
        flash(_('An export task is currently in progress'))
    else:
        current_user.launch_task('export_posts', _('Exporting posts...'))
        db.session.commit()
    return redirect(url_for('main.user', username=current_user.username))
```

이 기능은 먼저 사용자에게 미해결 내보내기 작업이 있는지 확인하고이 경우 메시지를 깜박입니다. 동일한 사용자에 대해 두 개의 내보내기 작업을 동시에 수행하는 것은 실제로 의미가 없으므로 이것이 방지됩니다. `get_task_in_progress()`앞서 구현 한 방법을 사용하여이 조건을 확인할 수 있습니다 .

사용자가 아직 내보내기를 실행하지 않은 경우 내보내기 `launch_task()`를 시작하도록 호출됩니다. 첫 번째 인수는 접두사가 붙은 RQ 워커에 전달 될 함수의 이름입니다 `app.tasks.`. 두 번째 인수는 사용자에게 표시되는 친숙한 텍스트 설명입니다. 두 값 모두 `Task`데이터베이스 의 개체에 기록 됩니다. 이 기능은 사용자 프로필 페이지로 리디렉션됩니다.

이제 사용자가 내보내기를 요청하기 위해 액세스 할 수있는이 경로에 대한 링크를 공개해야합니다. 이 작업을 수행하기에 가장 적합한 장소는 사용자 프로필 페이지에 있으며 사용자가 "프로필 수정"링크 바로 아래에 자신의 페이지를 볼 때만 링크를 표시 할 수 있습니다.

*app / templates / user.html* : 사용자 프로필 페이지에서 내보내기 링크.

```
                ...
                <p>
                    <a href="{{ url_for('main.edit_profile') }}">
                        {{ _('Edit your profile') }}
                    </a>
                </p>
                {% if not current_user.get_task_in_progress('export_posts') %}
                <p>
                    <a href="{{ url_for('main.export_posts') }}">
                        {{ _('Export your posts') }}
                    </a>
                </p>
                ...
                {% endif %}
```

이 링크는 사용자가 이미 내보내기가 진행 중일 때 표시되지 않기 때문에 조건부와 연결되어 있습니다.

이 시점에서 백그라운드 작업은 작동하지만 사용자에게 피드백을 제공하지 않아야합니다. 이를 시도하려면 다음과 같이 애플리케이션 및 RQ 작업자를 시작할 수 있습니다.

- Redis를 실행하고 있는지 확인하십시오
- 첫 번째 터미널 창에서 하나 이상의 RQ 작업자 인스턴스를 시작하십시오. 이를 위해서는 다음 명령을 사용해야합니다`rq worker microblog-tasks`
- 두 번째 터미널 창에서 다음을 사용하여 Flask 응용 프로그램을 시작하십시오 `flask run`( `FLASK_APP`먼저 설정해야 함 )

## 진행 알림

이 기능을 마무리하기 위해 완료 비율을 포함하여 백그라운드 작업이 실행 중일 때 사용자에게 알리고 싶습니다. Bootstrap 구성 요소 옵션을 살펴보면서 탐색 표시 줄 아래에 경고를 사용하기로 결정했습니다. 경고는 사용자에게 정보를 표시하는 이러한 색상 가로 막대입니다. 파란색 경고 상자는 깜박이는 메시지를 렌더링하는 데 사용하는 것입니다. 이제 진행 상태를 표시하기 위해 녹색을 추가하겠습니다. 아래에서 그 모습을 볼 수 있습니다.

![진행 경고](.\images\mega-tutorial/ch22-progress-alert.png)

*app / templates / base.html* : 기본 템플릿에서 진행률 알림을 내 *보냅니다* .

```
...
{% block content %}
    <div class="container">
        {% if current_user.is_authenticated %}
        {% with tasks = current_user.get_tasks_in_progress() %}
        {% if tasks %}
            {% for task in tasks %}
            <div class="alert alert-success" role="alert">
                {{ task.description }}
                <span id="{{ task.id }}-progress">{{ task.get_progress() }}</span>%
            </div>
            {% endfor %}
        {% endif %}
        {% endwith %}
        {% endif %}
        ...
{% endblock %}
...
```

작업 경고를 렌더링하는 방법은 깜박이는 메시지와 거의 동일합니다. 외부 조건은 사용자가 로그인하지 않은 경우 모든 경고 관련 마크 업을 건너 뜁니다. 로그인 한 사용자의 경우 `get_tasks_in_progress()`앞에서 만든 메서드 를 호출하여 현재 진행중인 작업 목록을 얻 습니다. 현재 버전의 응용 프로그램에서는 한 번에 둘 이상의 활성 내보내기를 허용하지 않기 때문에 하나의 결과 만 얻을 수 있지만 앞으로는 공존 할 수있는 다른 유형의 작업을 지원하고자 할 수 있습니다. 이것을 일반적인 방식으로 작성하면 나중에 시간을 절약 할 수 있습니다.

각 작업마다 경고 요소를 페이지에 씁니다. 경고의 색상은 두 번째 CSS 스타일로 제어 `alert-success`되며이 경우에는 플래시 메시지의 경우입니다 `alert-info`. [부트 스트랩 문서는](https://getbootstrap.com/docs/3.3/components/#alerts) 경고의 HTML 구조에 대한 세부 사항이 포함되어 있습니다. 경고 텍스트에는 모델에 `description`저장된 필드 `Task`와 완료율이 표시됩니다.

백분율은 속성 ``이있는 요소 로 래핑됩니다 `id`. 그 이유는 알림을받을 때 JavaScript에서 백분율을 새로 고치려고하기 때문입니다. 주어진 작업에 사용중인 ID `-progress`는 끝에 추가 된 작업 ID로 구성 됩니다. 알림이 도착하면 작업 ID가 포함되므로 ``에 대한 선택기로 업데이트 할 올바른 요소를 쉽게 찾을 수 있습니다 `#-progress`.

이 시점에서 응용 프로그램을 시도하면 새 페이지로 이동할 때마다 "정적"진행률 업데이트가 표시됩니다. 내보내기 작업을 시작한 후 응용 프로그램의 다른 페이지를 자유롭게 탐색 할 수 있으며 실행중인 작업의 상태가 항상 재 호출됩니다.

백분율 ``요소에 동적 업데이트를 적용 할 준비를하기 위해 JavaScript 쪽에서 약간의 도우미 함수를 작성하겠습니다.

*app / templates / base.html* : 작업 진행 상황을 동적으로 업데이트하는 도우미 기능.

```
...
{% block scripts %}
    ...
    <script>
        ...
        function set_task_progress(task_id, progress) {
            $('#' + task_id + '-progress').text(progress);
        }
    </script>
    ...
{% endblock %}
```

이 함수는 작업 `id`과 진행 값을 가져오고 jQuery를 사용 ``하여이 작업 의 요소 를 찾고 새 진행을 내용으로 작성합니다. 주어진 선택자와 함께 요소가 없으면 jQuery는 아무것도하지 않기 때문에 요소가 페이지에 존재하는지 확인할 필요가 없습니다.

진행 상황이 업데이트 될 때마다 *app / tasks.py* 의 `_set_task_progress()`함수가 호출 되므로 알림이 이미 브라우저에 도착하고 있습니다. 이 알림이 아무런 조치를 취하지 않고 브라우저에 도달하는 방법에 대해 혼란 스러우면 [21 장](https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-xxi-user-notifications) 에서 알림 기능을 완전히 일반적인 방식으로 구현하는 것이 현명하기 때문입니다 . 메소드를 통해 추가 된 모든 알림은 정기적으로 서버에 알림 업데이트를 요청할 때 브라우저에 표시됩니다.`add_notification()``add_notification()`

그러나 이러한 알림을 처리하는 JavaScript 코드는 `unread_message_count`이름 이있는 알림 만 인식 하고 나머지는 무시합니다. 지금해야 할 일은 위에서 정의한 함수 `task_progress`를 호출하여 알림을 처리하도록 해당 함수를 확장하는 것 `set_task_progress()`입니다. 다음은 JavaScript의 알림을 처리하는 업데이트 된 루프 버전입니다.

*app / templates / base.html* : 알림 핸들러.

```
                        for (var i = 0; i < notifications.length; i++) {
                            switch (notifications[i].name) {
                                case 'unread_message_count':
                                    set_message_count(notifications[i].data);
                                    break;
                                case 'task_progress':
                                    set_task_progress(
                                        notifications[i].data.task_id,
                                        notifications[i].data.progress);
                                    break;
                            }
                            since = notifications[i].timestamp;
                        }
```

이제 두 가지 다른 알림을 처리해야 `if`하므로 `unread_message_count`알림 이름 을 확인한 `switch`문을 지금 지원해야하는 각 알림에 대해 하나의 섹션이 포함 된 문 으로 대체하기로 결정했습니다 . "C"언어 제품군에 익숙하지 않은 경우 이전에 switch 문을 보지 못했을 수 있습니다. 이것들은 긴 `if/elseif`문장 체인을 대체하는 편리한 구문을 제공합니다 . 더 많은 알림을 지원해야하므로 추가 `case`블록 으로 계속 추가 할 수 있기 때문에 좋습니다 .

RQ 태스크가 `task_progress`알림에 첨부하는 데이터는 두 가지 요소가있는 사전 `task_id`이며 `progress`, 호출하는 데 사용해야하는 두 가지 인수입니다 `set_task_progress()`.

지금 응용 프로그램을 실행하면 알림이 클라이언트에 전달되므로 녹색 경고 상자의 진행률 표시기가 10 초마다 새로 고쳐집니다.

이 장에서 번역 가능한 새로운 문자열을 소개 했으므로 번역 파일을 업데이트해야합니다. 영어 이외의 언어 파일을 유지 관리하는 경우 Flask-Babel을 사용하여 번역 파일을 새로 고친 다음 새 번역을 추가해야합니다.

```
(venv) $ flask translate update
```

스페인어 번역을 사용하는 경우 번역 작업을 완료 *했으므로이* 장의 [다운로드 패키지](https://github.com/miguelgrinberg/microblog/archive/version-0.22.zip) 에서 *app / translations / es / LC_MESSAGES / messages.po* 파일을 추출 하여 프로젝트에 추가하면됩니다.

번역이 완료되면 번역 파일을 컴파일해야합니다.

```
(venv) $ flask translate compile
```

## 배포 고려 사항

이 장을 완료하기 위해 응용 프로그램의 배포가 어떻게 변경되는지 논의하고 싶습니다. 백그라운드 작업을 지원하기 위해 스택에 두 가지 새로운 구성 요소, Redis 서버 및 하나 이상의 RQ 작업자를 추가했습니다. 분명히 이들은 배포 전략에 포함되어야하므로 이전 장에서 다룬 다양한 배포 옵션과 이러한 변경에 따른 영향에 대해 간단히 살펴 보겠습니다.

### Linux 서버에 배포

Linux 서버에서 애플리케이션을 실행중인 경우 운영 체제에서이 패키지를 설치하는 것만 큼 Redis를 추가하는 것이 간단해야합니다. Ubuntu Linux의 경우을 실행해야합니다 `sudo apt-get install redis-server`.

RQ 작업자 프로세스를 실행하려면 [17 장의](https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-xvii-deployment-on-linux) "Gunicorn 및 Supervisor 설정"섹션에 따라 `rq worker microblog-tasks`대신 두 번째 Supervisor 구성을 생성 할 수 있습니다 `gunicorn`. 둘 이상의 작업자를 실행하려는 경우 (그리고 아마도 프로덕션 환경에서 사용해야하는 경우) Supervisor의 `numprocs`지시문을 사용 하여 동시에 실행하려는 인스턴스 수를 나타낼 수 있습니다 .

### Heroku에 배포

Heroku에 애플리케이션을 배포하려면 계정에 Redis 서비스를 추가해야합니다. 이것은 Postgres 데이터베이스를 추가하는 데 사용한 프로세스와 유사합니다. Redis에는 프리 티어가 있으며 다음 명령으로 추가 할 수 있습니다.

```
$ heroku addons:create heroku-redis:hobby-dev
```

새로운 redis 서비스의 액세스 URL이 `REDIS_URL`변수 로 Heroku 환경에 추가 될 것입니다. 이는 애플리케이션이 정확히 예상하는 것입니다.

Heroku의 무료 플랜은 하나의 웹 다이노와 하나의 작업자 다이노를 허용하므로 `rq`비용을 들이지 않고 응용 프로그램과 함께 단일 작업자를 호스팅 할 수 있습니다 . 이를 위해 procfile에서 별도의 줄에 작업자를 선언해야합니다.

```
web: flask db upgrade; flask translate compile; gunicorn microblog:app
worker: rq worker -u $REDIS_URL microblog-tasks
```

이러한 변경 사항으로 배포 한 후 다음 명령을 사용하여 작업자를 시작할 수 있습니다.

```
$ heroku ps:scale worker=1
```

### Docker에 배포

Docker 컨테이너에 애플리케이션을 배포하는 경우 먼저 Redis 컨테이너를 작성해야합니다. 이를 위해 Docker 레지스트리의 공식 Redis 이미지 중 하나를 사용할 수 있습니다.

```
$ docker run --name redis -d -p 6379:6379 redis:3-alpine
```

애플리케이션을 실행할 때 redis 컨테이너를 연결 `REDIS_URL`하고 MySQL 컨테이너가 연결되는 방식과 비슷한 환경 변수를 설정해야 합니다. 다음은 redis 링크를 포함하여 응용 프로그램을 시작하는 전체 명령입니다.

```
$ docker run --name microblog -d -p 8000:5000 --rm -e SECRET_KEY=my-secret-key \
    -e MAIL_SERVER=smtp.googlemail.com -e MAIL_PORT=587 -e MAIL_USE_TLS=true \
    -e MAIL_USERNAME=<your-gmail-username> -e MAIL_PASSWORD=<your-gmail-password> \
    --link mysql:dbserver --link redis:redis-server \
    -e DATABASE_URL=mysql+pymysql://microblog:<database-password>@dbserver/microblog \
    -e REDIS_URL=redis://redis-server:6379/0 \
    microblog:latest
```

마지막으로 RQ 작업자를 위해 하나 이상의 컨테이너를 실행해야합니다. 작업자는 기본 응용 프로그램과 동일한 코드를 기반으로하기 때문에 웹 응용 프로그램 대신 작업자가 시작되도록 시작 명령을 재정 의하여 응용 프로그램에 사용하는 것과 동일한 컨테이너 이미지를 사용할 수 있습니다. 다음은 `docker run`워커를 시작 하는 예제 명령입니다.

```
$ docker run --name rq-worker -d --rm -e SECRET_KEY=my-secret-key \
    -e MAIL_SERVER=smtp.googlemail.com -e MAIL_PORT=587 -e MAIL_USE_TLS=true \
    -e MAIL_USERNAME=<your-gmail-username> -e MAIL_PASSWORD=<your-gmail-password> \
    --link mysql:dbserver --link redis:redis-server \
    -e DATABASE_URL=mysql+pymysql://microblog:<database-password>@dbserver/microblog \
    -e REDIS_URL=redis://redis-server:6379/0 \
    --entrypoint venv/bin/rq \
    microblog:latest worker -u redis://redis-server:6379/0 microblog-tasks
```

Docker 이미지의 기본 시작 명령을 재정의하는 것은 명령이 두 부분으로 제공되어야하기 때문에 약간 까다 롭습니다. `--entrypoint`인수는 실행 파일 이름이 필요하지만 인수 (있는 경우) 명령 줄의 끝에, 이미지와 태그 다음에 제공 될 필요가있다. 주의 `rq`요구 사항은 다음과 같이 부여 될 수 `venv/bin/rq`있으므로이 활성화 가상 환경을하지 않고 작동하는지.



## [Part XXIII: Application Programming Interfaces (APIs)](https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-xxiii-application-programming-interfaces-apis)

Flask Mega-Tutorial 시리즈의 23 번째이자 마지막 버전으로, 클라이언트가 응용 프로그램을 더 많이 사용하기 위해 사용할 수있는 응용 프로그래밍 인터페이스 (또는 API)를 사용하여 마이크로 블로그를 확장하는 방법을 알려 드리겠습니다. 전통적인 웹 브라우저 워크 플로보다 직접적인 방법입니다.

지금까지이 응용 프로그램을 위해 구축 한 모든 기능은 웹 브라우저라는 특정 유형의 클라이언트를위한 것입니다. 그러나 다른 유형의 고객은 어떻습니까? 예를 들어 Android 또는 iOS 앱을 만들고 싶다면 두 가지 주요 방법이 있습니다. 가장 쉬운 해결책은 Microblog 웹 사이트가로드 된 전체 화면을 채우는 웹보기 구성 요소를 사용하여 간단한 앱을 작성하는 것이지만 장치의 웹 브라우저에서 응용 프로그램을 여는 것보다 이점이 거의 없습니다. 더 나은 솔루션 (훨씬 더 힘들지만)은 기본 응용 프로그램을 작성하는 것이지만이 응용 프로그램은 HTML 페이지 만 반환하는 서버와 어떻게 상호 작용할 수 있습니까?

응용 프로그래밍 인터페이스 (또는 API)가 도움을 줄 수있는 문제 영역입니다. API는 응용 프로그램의 하위 수준 진입 점으로 설계된 HTTP 경로 모음입니다. API는 웹 브라우저에서 소비 할 HTML을 반환하는 경로 및 뷰 함수를 정의하는 대신 클라이언트가 응용 프로그램의 *리소스를* 직접 사용 하여 정보를 사용자에게 완전히 클라이언트에게 제공하는 방법을 결정하지 못하도록합니다 . 예를 들어, Microblog의 API는 사용자 및 블로그 게시물 정보를 클라이언트에 제공 할 수 있으며이 로직을 HTML과 혼합하지 않고도 사용자가 기존 블로그 게시물을 편집 할 수 있지만 데이터 레벨에서만 편집 할 수 있습니다.

현재 응용 프로그램에 정의 된 모든 경로를 연구하면 위에서 사용한 API의 정의에 맞는 몇 가지가 있음을 알 수 있습니다. 당신은 그들을 찾았습니까? [14 장](https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-xiv-ajax) 에서 정의한 */ translate* 경로 와 같이 JSON을 반환하는 몇 가지 경로에 대해 이야기하고 있습니다. 요청 에서 JSON 형식으로 제공되는 텍스트, 소스 및 대상 언어를 사용하는 경로입니다 . 이 요청에 대한 응답은 해당 텍스트를 JSON 형식으로 번역 한 것입니다. 서버는 요청 된 정보 만 반환하므로 클라이언트는이 정보를 사용자에게 제공 할 책임이 있습니다.`POST`

애플리케이션의 JSON 라우트에는 API "느낌"이 있지만 브라우저에서 실행되는 웹 애플리케이션을 지원하도록 설계되었습니다. 스마트 폰 앱이 이러한 경로를 사용하려는 경우 로그인 한 사용자가 필요하기 때문에 로그인 할 수 없으며 HTML 양식을 통해서만 로그인 할 수 있습니다. 이 장에서는 웹 브라우저에 의존하지 않는 API를 작성하는 방법과 어떤 종류의 클라이언트가 연결되는지에 대한 가정을 제시하지 않겠습니다.

*이 장의 GitHub 링크는 [Browse](https://github.com/miguelgrinberg/microblog/tree/v0.23) , [Zip](https://github.com/miguelgrinberg/microblog/archive/v0.23.zip) , [Diff](https://github.com/miguelgrinberg/microblog/compare/v0.22...v0.23) 입니다.*

## API 디자인의 기초로서의 REST

어떤 사람들은 */ translate* 및 다른 JSON 경로는 API 경로 라는 위의 진술에 크게 동의하지 않을 수 있습니다 . 다른 사람들은 면책 조항에 따라 잘못 설계된 API라고 생각할 수 있습니다. 그렇다면 잘 설계된 API의 특징은 무엇이며 JSON이 해당 카테고리에서 라우팅되지 않는 이유는 무엇입니까?

[REST API](https://en.wikipedia.org/wiki/Representational_state_transfer) 라는 용어를 들었을 수 있습니다 . Representational State Transfer의 약자 인 REST는 [박사 학위 논문](http://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm) 에서 Roy Fielding 박사가 제안한 아키텍처 입니다. Fielding 박사는 그의 연구에서 REST의 6 가지 특징을 상당히 추상적이고 일반적인 방식으로 제시합니다.

Dr. Fielding의 논문 외에 REST에 대한 권위있는 사양은 없으며, 독자가 해석 할 수있는 많은 세부 사항이 남습니다. 주어진 API가 REST를 준수하는지 아닌지에 대한 주제는 종종 REST "순수 자"사이의 격렬한 논쟁의 원천입니다. 이들은 REST API가 REST "실용 주의자"에 비해 6 가지 특성을 모두 관찰하고 매우 구체적인 방식으로 수행해야한다고 생각합니다. 박사는 Fielding 박사가 논문으로 제시 한 아이디어를 지침 또는 권장 사항으로 취합니다. Dr. Fielding은 순교자 캠프와 함께 블로그 게시물과 온라인 댓글에서 자신의 비전에 대한 추가 통찰력을 제공했습니다.

현재 구현 된 대다수의 API는 "실용적인"REST 구현을 따릅니다. 여기에는 Facebook, GitHub, Twitter 등과 같은 "빅 플레이어"의 대부분의 API가 포함됩니다. 순수 REST로 만장일치로 간주되는 퍼블릭 API는 거의 없습니다. 대부분의 API는 순수 주의자가 반드시 고려해야하는 특정 구현 세부 사항을 놓치기 때문입니다. 있다. Dr. Fielding 박사와 다른 REST 순수 주의자들은 REST API가 무엇인지 아닌지에 대한 엄격한 견해에도 불구하고 소프트웨어 업계에서는 실용적인 의미에서 REST를 참조하는 것이 일반적입니다.

REST 논문의 내용에 대한 아이디어를 제공하기 위해 다음 섹션에서는 Fielding 박사가 열거 한 6 가지 원칙에 대해 설명합니다.

### 클라이언트 서버

클라이언트-서버 원칙은 REST API에서 클라이언트와 서버의 역할을 명확하게 구분해야한다고 간단하게 설명하기 때문에 매우 간단합니다. 실제로 이것은 클라이언트와 서버가 전송을 통해 통신하는 별도의 프로세스에 있음을 의미하며, 대부분의 경우 TCP 네트워크를 통한 HTTP 프로토콜입니다.

### 계층화 된 시스템

계층화 된 시스템 원칙에 따르면 클라이언트가 서버와 통신해야 할 경우 실제 서버가 아닌 중개자에 연결될 수 있습니다. 아이디어는 클라이언트의 경우 서버에 직접 연결되지 않은 경우 요청을 보내는 방식에 절대 차이가 없어야한다는 것입니다. 실제로 대상 서버에 연결되어 있는지 여부를 알지 못할 수도 있습니다. 마찬가지로이 원칙은 서버가 클라이언트가 아닌 중개자로부터 클라이언트 요청을 수신 할 수 있으므로 연결의 다른 쪽이 클라이언트라고 가정해서는 안됩니다.

중개 노드를 추가 할 수 있으므로 애플리케이션 아키텍트는로드 밸런서, 캐시, 프록시 서버 등을 사용하여 대량의 요청을 충족시킬 수있는 크고 복잡한 네트워크를 설계 할 수 있으므로 REST의 중요한 기능입니다.

### 은닉처

이 원칙은 서버 또는 중개자가 시스템 성능을 향상시키기 위해 자주받는 요청에 대한 응답을 캐시 할 수 있음을 명시 적으로 표시하여 계층화 된 시스템을 확장합니다. 모든 웹 브라우저의 캐시에 익숙한 캐시 구현이 있습니다. 웹 브라우저 캐시 계층은 종종 이미지와 같은 동일한 파일을 반복해서 요청하지 않도록하는 데 사용됩니다.

API의 목적으로, 대상 서버 는 클라이언트로 다시 이동할 때 중개자가 응답을 캐시 할 수있는 경우 *캐시 제어를* 사용하여 표시해야합니다 . 보안상의 이유로 프로덕션에 배포 된 API는 암호화를 사용해야하므로이 노드 가 SSL 연결을 *종료* 하거나 암호 해독 및 재 암호화를 수행 하지 않는 한 일반적으로 중간 노드에서 캐싱을 수행하지 않습니다 .

### 주문형 코드

이것은 서버가 클라이언트에 대한 응답으로 실행 코드를 제공 할 수 있음을 나타내는 선택적 요구 사항입니다. 이 원칙은 클라이언트가 실행할 수있는 실행 코드 종류에 대해 서버와 클라이언트간에 계약이 필요하므로 API에서는 거의 사용되지 않습니다. 서버는 웹 브라우저 클라이언트가 실행할 JavaScript 코드를 리턴 할 수 있지만 REST는 웹 브라우저 클라이언트를 대상으로하지 않습니다. 예를 들어, 클라이언트가 iOS 또는 Android 장치 인 경우 JavaScript를 실행하면 문제가 발생할 수 있습니다.

### 무국적

무국적 원칙은 REST 순수 주의자와 실용 주의자 사이의 대부분의 논쟁 중심에있는 두 가지 중 하나입니다. REST API는 주어진 클라이언트가 요청을 보낼 때마다 호출 할 클라이언트 상태를 저장해서는 안된다고 명시합니다. 이는 웹 개발에서 사용자가 응용 프로그램 페이지를 탐색 할 때 "기억"하는 일반적인 메커니즘을 사용할 수 없음을 의미합니다. 상태 비 저장 API에서 모든 요청에는 서버가 클라이언트를 식별 및 인증하고 요청을 수행하는 데 필요한 정보가 포함되어야합니다. 또한 서버가 클라이언트 연결과 관련된 데이터를 데이터베이스 또는 다른 형식의 저장소에 저장할 수 없음을 의미합니다.

REST에 스테이트리스 서버가 필요한 이유가 궁금한 경우, 스테이트리스 서버를 확장하기가 매우 쉬운 이유는로드 밸런서 뒤에서 서버의 여러 인스턴스를 실행하기 만하면됩니다. 서버가 클라이언트 상태를 저장하는 경우 여러 서버가 해당 상태에 액세스하고 업데이트 할 수있는 방법을 알아 내거나 주어진 클라이언트가 항상 동일한 서버 (일반적으로 *고정 세션* 이라고 함)로 처리되는지 확인해야하므로 더 복잡해집니다 .

이 장의 소개에서 논의 된 */ translate* 경로를 다시 고려한다면 , 해당 경로와 관련된보기 기능 은 Flask-Login 의 데코레이터에 의존하기 때문에 *RESTful* 로 간주 될 수 없다는 것을 알게 될 것입니다. `@login_required`Flask 사용자 세션에서 사용자의

### 균일 한 인터페이스

마지막으로 가장 중요하고 가장 논쟁이 많고 모호하게 문서화 된 REST 원칙은 균일 한 인터페이스입니다. Dr. Fielding은 REST 유니폼 인터페이스의 고유 한 자원 식별자, 자원 표현, 자기 설명 메시지 및 하이퍼 미디어의 네 가지 특징을 열거합니다.

고유 한 자원 식별자는 각 자원에 고유 한 URL을 할당하여 달성됩니다. 예를 들어 지정된 사용자와 관련된 URL은 */ api / users / * 일 수 있습니다. 여기서 ** 는 데이터베이스 테이블의 기본 키에서 사용자에게 할당 된 식별자입니다. 이것은 대부분의 API에 의해 합리적으로 잘 구현됩니다.

자원 표현의 사용은 서버와 클라이언트가 자원에 대한 정보를 교환 할 때 합의 된 형식을 사용해야한다는 것을 의미합니다. 대부분의 최신 API의 경우 JSON 형식이 리소스 표현을 작성하는 데 사용됩니다. API는 여러 리소스 표현 형식을 지원하도록 선택할 수 있으며이 경우 HTTP 프로토콜 의 *콘텐츠 협상* 옵션은 클라이언트와 서버가 모두 같은 형식에 동의 할 수있는 메커니즘입니다.

자체 설명 메시지는 클라이언트와 서버간에 교환 된 요청 및 응답에 상대방이 필요로하는 모든 정보가 포함되어야 함을 의미합니다. 전형적인 예로서, HTTP 요청 방법은 클라이언트가 서버가 어떤 작업을 수행하기를 원하는지를 나타내는 데 사용됩니다. `GET`요청은, 클라이언트가 자원에 대한 정보를 검색하고자하는 것을 나타냅니다 `POST`요청은 클라이언트가 새로운 자원을 만들려고, 표시 `PUT`또는 `PATCH`요청이 기존 자원에 대한 수정을 정의하고, `DELETE`자원을 제거하는 요청을 나타냅니다. 대상 자원은 요청 헤더로 표시되며 HTTP 헤더, URL의 쿼리 문자열 부분 또는 요청 본문에 추가 정보가 제공됩니다.

하이퍼 미디어 요구 사항은이 세트에서 가장 논쟁적인 주제이며, API를 거의 구현하지 않는 API이며,이를 구현하는 API는 REST 순수 주의자를 만족시키는 방식으로 거의 수행하지 않습니다. 응용 프로그램의 리소스는 모두 서로 관련되어 있기 때문에이 요구 사항은 해당 관계가 리소스 표현에 포함되도록 요구하므로 클라이언트는 웹 응용 프로그램에서 새 페이지를 검색하는 것과 거의 같은 방식으로 관계를 탐색하여 새 리소스를 검색 할 수 있습니다. 한 페이지에서 다음 페이지로 연결되는 링크를 클릭하여 아이디어는 클라이언트가 리소스에 대한 사전 지식없이 API를 입력하고 하이퍼 미디어 링크를 따라 간단히 배울 수 있다는 것입니다. 이 요구 사항의 구현을 복잡하게 만드는 측면 중 하나는 HTML 및 XML과 달리[JSON-API](http://jsonapi.org/) , [HAL](http://stateless.co/hal_specification.html) , [JSON-LD](https://json-ld.org/) 또는 유사.

## API 블루 프린트 구현

API 개발과 관련된 내용을 맛볼 수 있도록 Microblog에 API를 추가하겠습니다. 이것은 완전한 API가 아니며 사용자와 관련된 모든 기능을 구현하고 블로그 게시물과 같은 다른 리소스의 구현을 독자에게 연습으로 남겨 두겠습니다.

일을 체계적으로 유지하고 [15 장](https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-xv-a-better-application-structure) 에서 설명한 구조를 따르기 위해 모든 API 라우트를 포함 할 새로운 청사진을 작성하겠습니다. 이제이 블루 프린트가 존재하는 디렉토리를 만들어 봅시다 :

```
(venv) $ mkdir app/api
```

블루 프린트의 *__init__.py* 파일은 애플리케이션의 다른 블루 프린트와 유사한 블루 프린트 오브젝트를 작성합니다.

*app / api / __ init__.py* : API 블루 프린트 생성자.

```
from flask import Blueprint

bp = Blueprint('api', __name__)

from app.api import users, errors, tokens
```

순환 종속성 오류를 피하기 위해 가져 오기를 맨 아래로 이동해야 할 수도 있습니다. 이것이 청사진을 작성한 후 *app / api / users.py* , *app / api / errors.py* 및 *app / api / tokens.py* 모듈 (아직 작성하지 않은)을 가져 오는 이유입니다.

*API의 핵심* 은 *app / api / users.py* 모듈에 저장 될 것 입니다. 다음 표에는 구현할 경로가 요약되어 있습니다.

| HTTP 메소드 | 자원 URL                       | 노트                                      |
| :---------- | :----------------------------- | :---------------------------------------- |
| `GET`       | */ api / users / *             | 사용자를 반환하십시오.                    |
| `GET`       | */ api / users*                | 모든 사용자의 콜렉션을 리턴하십시오.      |
| `GET`       | */ api / users /  / followers* | 이 사용자의 추종자를 반환하십시오.        |
| `GET`       | */ api / users /  / followed*  | 이 사용자가 따르는 사용자를 반환하십시오. |
| `POST`      | */ api / users*                | 새로운 사용자 계정을 등록하십시오.        |
| `PUT`       | */ api / users / *             | 사용자를 수정하십시오.                    |

지금은이 모든 경로에 대한 자리 표시자가 포함 된 스켈레톤 모듈을 만들겠습니다.

*app / api / users.py* : 사용자 API 리소스 자리 표시 자

```
from app.api import bp

@bp.route('/users/<int:id>', methods=['GET'])
def get_user(id):
    pass

@bp.route('/users', methods=['GET'])
def get_users():
    pass

@bp.route('/users/<int:id>/followers', methods=['GET'])
def get_followers(id):
    pass

@bp.route('/users/<int:id>/followed', methods=['GET'])
def get_followed(id):
    pass

@bp.route('/users', methods=['POST'])
def create_user():
    pass

@bp.route('/users/<int:id>', methods=['PUT'])
def update_user(id):
    pass
```

*응용 프로그램 / API / errors.py* 모듈은 몇 가지 도우미 함수를 정의하는 것입니다 그 오류 응답 처리합니다. 그러나 지금은 나중에 작성할 자리 표시자를 사용할 것입니다.

*app / api / errors.py* : 자리 표시 자 처리 오류.

```
def bad_request():
    pass
```

*응용 프로그램 / API / tokens.py* 인증 서브 시스템을 정의 할 것입니다 모듈입니다. 이것은 웹 브라우저가 아닌 클라이언트가 로그인 할 수있는 대체 방법을 제공 할 것입니다. 지금은이 모듈에 대한 자리 표시자를 작성하겠습니다.

*app / api / tokens.py* : 토큰 처리 자리 표시 자

```
def get_token():
    pass

def revoke_token():
    pass
```

새로운 API 블루 프린트는 애플리케이션 팩토리 기능에 등록해야합니다.

*app / __ init__.py* : 애플리케이션에 API 블루 프린트를 등록하십시오.

```
# ...

def create_app(config_class=Config):
    app = Flask(__name__)

    # ...

    from app.api import bp as api_bp
    app.register_blueprint(api_bp, url_prefix='/api')

    # ...
```

## 사용자를 JSON 객체로 표시

API를 구현할 때 고려해야 할 첫 번째 측면은 리소스의 표현을 결정하는 것입니다. 사용자와 함께 작동하는 API를 구현할 것이므로 사용자 리소스에 대한 표현을 결정해야합니다. 약간의 브레인 스토밍 후 다음 JSON 표현을 생각해 냈습니다.

```
{
    "id": 123,
    "username": "susan",
    "password": "my-password",
    "email": "susan@example.com",
    "last_seen": "2017-10-20T15:04:27Z",
    "about_me": "Hello, my name is Susan!",
    "post_count": 7,
    "follower_count": 35,
    "followed_count": 21,
    "_links": {
        "self": "/api/users/123",
        "followers": "/api/users/123/followers",
        "followed": "/api/users/123/followed",
        "avatar": "https://www.gravatar.com/avatar/..."
    }
}
```

많은 필드가 사용자 데이터베이스 모델에서 직접 제공됩니다. 이 `password`필드는 새 사용자가 등록 될 때만 사용된다는 점에서 특별합니다. [5 장](https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-v-user-logins) 에서 기억 하듯이 사용자 암호는 데이터베이스에 저장되지 않으며 해시 만 저장되므로 암호가 반환되지 않습니다. `email`나는 사용자의 이메일 주소를 노출하지 않기 때문에 필드는 또한 특별하게 취급된다. `email`사용자가 자신의 항목을 요청할 때만 필드가 반환되지만 다른 사용자로부터 항목을 검색 할 때는 이 필드가 반환되지 않습니다. `post_count`, `follower_count`및`followed_count`필드는 데이터베이스에 필드로 존재하지 않지만 편의상 클라이언트에 제공되는 "가상"필드입니다. 이것은 자원 표현이 실제 자원이 서버에서 정의 된 방식과 일치하지 않아도된다는 것을 보여주는 훌륭한 예입니다.

`_links`하이퍼 미디어 요구 사항을 구현 하는 섹션을 참고하십시오 . 정의 된 링크에는 현재 리소스에 대한 링크,이 사용자를 따르는 사용자 목록, 사용자가 따르는 사용자 목록, 마지막으로 사용자의 아바타 이미지에 대한 링크가 포함됩니다. 앞으로이 API에 게시물을 추가하기로 결정한 경우 사용자의 게시물 목록에 대한 링크도 여기에 포함되어야합니다.

JSON 형식의 한 가지 좋은 점은 항상 파이썬 사전 또는 목록으로 표현으로 변환한다는 것입니다. `json`Python 표준 라이브러리 의 패키지는 Python 데이터 구조를 JSON으로 또는 JSON으로 변환하는 작업을 처리합니다. 따라서 이러한 표현을 생성하기 위해라는 `User`모델에 메소드를 추가 `to_dict()`하여 파이썬 사전을 반환합니다.

*app / models.py* : 표현할 사용자 모델.

```
from flask import url_for
# ...

class User(UserMixin, db.Model):
    # ...

    def to_dict(self, include_email=False):
        data = {
            'id': self.id,
            'username': self.username,
            'last_seen': self.last_seen.isoformat() + 'Z',
            'about_me': self.about_me,
            'post_count': self.posts.count(),
            'follower_count': self.followers.count(),
            'followed_count': self.followed.count(),
            '_links': {
                'self': url_for('api.get_user', id=self.id),
                'followers': url_for('api.get_followers', id=self.id),
                'followed': url_for('api.get_followed', id=self.id),
                'avatar': self.avatar(128)
            }
        }
        if include_email:
            data['email'] = self.email
        return data
```

이 방법은 대부분 설명이 필요하며 사용자가 설정 한 사용자 사전이 포함 된 사전이 생성되어 반환됩니다. 위에서 언급했듯이 `email`사용자가 자신의 데이터를 요청할 때만 전자 메일을 포함하고 싶기 때문에이 필드 에는 특별한 처리가 필요합니다. 따라서 `include_email`플래그를 사용하여 해당 필드가 표현에 포함되는지 여부를 결정합니다.

```
last_seen`필드가 어떻게 생성 되는지 확인하십시오 . 날짜 및 시간 필드의 경우 Python에서 메소드를 통해 생성 할 수 있는 [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) 형식 을 사용하겠습니다 . 그러나 UTC이지만 기본 시간대가 기록되지 않은 순진한 객체를 사용하고 있기 때문에 끝에 UTC 를 추가해야합니다 .UTC의 표준 시간대 코드는 ISO 8601입니다.`datetime``isoformat()``datetime``Z
```

마지막으로 하이퍼 미디어 링크를 어떻게 구현했는지 살펴보십시오. 다른 응용 프로그램 경로를 가리키는 세 개의 링크의 `url_for()`경우 URL을 생성하는 데 사용합니다 (현재 *app / api / users.py에* 정의한 자리 표시 자보기 함수를 *가리킴* ). 아바타 링크는 응용 프로그램 외부의 Gravatar URL이므로 특별합니다. 이 링크 `avatar()`에는 웹 페이지에서 아바타를 렌더링하는 데 사용한 것과 동일한 방법을 사용합니다.

이 `to_dict()`메소드는 사용자 객체를 Python 표현으로 변환 한 다음 JSON으로 변환합니다. 또한 클라이언트가 요청에서 사용자 표현을 전달하고 서버가 구문 분석하고 `User`객체 로 변환 해야하는 반대 방향을 살펴 봐야 합니다. 다음은 `from_dict()`파이썬 사전에서 모델로 변환 하는 방법입니다.

*app / models.py* : 사용자 모델로 표현.

```
class User(UserMixin, db.Model):
    # ...

    def from_dict(self, data, new_user=False):
        for field in ['username', 'email', 'about_me']:
            if field in data:
                setattr(self, field, data[field])
        if new_user and 'password' in data:
            self.set_password(data['password'])
```

이 경우 루프를 사용하여 클라이언트가 설정할 수있는 필드 인 `username`, `email`및 을 가져 오기로 결정했습니다 `about_me`. 각 필드에 대해 `data`인수에 제공된 값이 있는지 확인하고 존재하는 경우 Python을 사용 `setattr()`하여 객체의 해당 속성에 새 값을 설정합니다.

`password`는 객체의 필드가 아니기 때문에 필드는 특별한 경우로 취급됩니다. `new_user`이것은 그 수단은 새로운 사용자 등록이면 인수 결정 `password`에 포함된다. 사용자 모델에서 비밀번호를 설정하기 `set_password()`위해 비밀번호 해시를 생성하는 메소드를 호출합니다 .

## 사용자 모음 대표

이 API에는 단일 리소스 표현 작업 외에도 사용자 그룹에 대한 표현이 필요합니다. 예를 들어, 클라이언트가 사용자 또는 팔로어 목록을 요청할 때 사용되는 형식이됩니다. 다음은 사용자 모음을 나타냅니다.

```
{
    "items": [
        { ... user resource ... },
        { ... user resource ... },
        ...
    ],
    "_meta": {
        "page": 1,
        "per_page": 10,
        "total_pages": 20,
        "total_items": 195
    },
    "_links": {
        "self": "http://localhost:5000/api/users?page=1",
        "next": "http://localhost:5000/api/users?page=2",
        "prev": null
    }
}
```

이 표현 `items`에는 이전 섹션에서 설명한대로 각각 정의 된 사용자 자원 목록이 있습니다. 이 `_meta`섹션에는 클라이언트가 페이지 매김 컨트롤을 사용자에게 제시하는 데 유용한 컬렉션의 메타 데이터가 포함되어 있습니다. 이 `_links`섹션에서는 컬렉션 자체에 대한 링크와 이전 및 다음 페이지 링크를 포함하여 관련 링크를 정의하여 클라이언트가 목록을 페이지 매김하는 데 도움을줍니다.

페이지 매김 논리로 인해 사용자 모음 표현을 생성하는 것은 까다로울 수 있지만 논리는 나중에이 API에 추가하려는 다른 리소스에 공통적이므로이 표현을 그런 다음 다른 모델에 적용 할 수있는 일반적인 방법입니다. [16 장으로](https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-xvi-full-text-search) 돌아가서 전체 텍스트 검색 인덱스와 비슷한 상황에 처해 있었는데, 이는 모든 모델에 적용 할 수 있도록 일반적으로 구현하고자하는 또 다른 기능입니다. 내가 사용한 솔루션 `SearchableMixin`은 전체 텍스트 인덱스가 필요한 모델이 상속 할 수 있는 클래스 를 구현하는 것이 었습니다 . 나는 이것에 대해 동일한 아이디어를 사용할 것이므로 여기에 내가 명명 한 새로운 믹스 인 클래스가 있습니다 `PaginatedAPIMixin`.

*app / models.py* : 페이지 매김 표현 믹스 인 클래스.

```
class PaginatedAPIMixin(object):
    @staticmethod
    def to_collection_dict(query, page, per_page, endpoint, **kwargs):
        resources = query.paginate(page, per_page, False)
        data = {
            'items': [item.to_dict() for item in resources.items],
            '_meta': {
                'page': page,
                'per_page': per_page,
                'total_pages': resources.pages,
                'total_items': resources.total
            },
            '_links': {
                'self': url_for(endpoint, page=page, per_page=per_page,
                                **kwargs),
                'next': url_for(endpoint, page=page + 1, per_page=per_page,
                                **kwargs) if resources.has_next else None,
                'prev': url_for(endpoint, page=page - 1, per_page=per_page,
                                **kwargs) if resources.has_prev else None
            }
        }
        return data
```

이 `to_collection_dict()`메소드는 `items`, `_meta`및 `_links`섹션을 포함하여 사용자 콜렉션 표현이있는 사전을 생성 합니다. 작동 방식을 이해하려면 방법을 신중하게 검토해야 할 수도 있습니다. 처음 세 인수는 Flask-SQLAlchemy 쿼리 개체, 페이지 번호 및 페이지 크기입니다. 이들은 반환 될 항목을 결정하는 인수입니다. 구현은 `paginate()`쿼리 객체 의 메소드를 사용 하여 웹 애플리케이션의 색인, 탐색 및 프로파일 페이지에서 게시물을 사용한 것처럼 페이지 가치있는 항목을 얻습니다.

복잡한 부분은 자체 참조와 다음 및 이전 페이지에 대한 링크를 포함하는 링크를 생성하는 것입니다. 이 기능을 일반화하고 싶기 때문에 예를 들어 `url_for('api.get_users', id=id, page=page)`자체 링크를 생성하는 데 사용할 수 없었습니다 . 인수 `url_for()`는 특정 리소스 모음에 종속되므로 `endpoint`인수에 전달 해야하는보기 함수를 인수에 전달하는 호출자에게 의존 합니다 `url_for()`. 그리고 많은 경로에 인수가 있기 때문에에서 추가 키워드 인수를 캡처 `kwargs`하여 전달해야 `url_for()`합니다. `page`및 `per_page`쿼리 문자열 인수는 명시 적으로 부여되기 때문에 모든 API 노선에 대한 이러한 제어 매김.

이 믹스 인 클래스는 `User`모델에 부모 클래스로 추가해야합니다 .

*app / models.py* : PaginatedAPIMixin을 사용자 모델에 추가하십시오.

```
class User(PaginatedAPIMixin, UserMixin, db.Model):
    # ...
```

컬렉션의 경우 클라이언트가 사용자 목록을 보내도록 요구하는 경로가 없기 때문에 반대 방향이 필요하지 않습니다.

## 오류 처리

[7 장](https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-vii-error-handling) 에서 정의한 오류 페이지 는 웹 브라우저를 사용하여 응용 프로그램과 상호 작용하는 사용자에게만 적합합니다. API가 오류를 반환해야하는 경우 클라이언트 응용 프로그램이 쉽게 해석 할 수있는 "기계 친화적"유형의 오류 여야합니다. 따라서 JSON에서 API 리소스에 대한 표현을 정의한 것과 동일한 방식으로 이제 API 오류 메시지에 대한 표현을 결정합니다. 사용할 기본 구조는 다음과 같습니다.

```
{
    "error": "short error description",
    "message": "error message (optional)"
}
```

오류의 페이로드 외에도 HTTP 프로토콜의 상태 코드를 사용하여 오류의 일반 클래스를 나타냅니다. 이러한 오류 응답을 생성 할 수 있도록 *app / api / errors.py에*`error_response()` 함수 를 작성하겠습니다 .

*app / api / errors.py* : 오류 응답.

```
from flask import jsonify
from werkzeug.http import HTTP_STATUS_CODES

def error_response(status_code, message=None):
    payload = {'error': HTTP_STATUS_CODES.get(status_code, 'Unknown error')}
    if message:
        payload['message'] = message
    response = jsonify(payload)
    response.status_code = status_code
    return response
```

이 함수는 `HTTP_STATUS_CODES`Werkzeug (Flask의 핵심 종속성)의 편리한 사전을 사용하여 각 HTTP 상태 코드에 대한 간단한 설명 이름을 제공합니다. `error`오류 표현 의 필드에 이러한 이름을 사용 하므로 숫자 상태 코드와 선택적 긴 설명 만 걱정하면됩니다. 이 `jsonify()`함수는 `Response`기본 상태 코드가 200 인 Flask 객체를 반환 하므로 응답을 만든 후 상태 코드를 오류에 대한 올바른 코드로 설정했습니다.

API가 반환 할 가장 일반적인 오류는 "불량 요청"에 대한 오류 인 코드 400입니다. 이것은 클라이언트가 잘못된 데이터를 가진 요청을 보낼 때 사용되는 오류입니다. 이 오류를보다 쉽게 생성 할 수 있도록 긴 설명 메시지 만 인수로 필요한 전용 함수를 추가하겠습니다. 이것은 `bad_request()`이전에 추가 한 자리 표시 자입니다.

*app / api / errors.py* : 잘못된 요청 응답.

```
# ...

def bad_request(message):
    return error_response(400, message)
```

## 사용자 리소스 끝점

사용자의 JSON 표현 작업에 필요한 지원이 완료되었으므로 API 엔드 포인트 코딩을 시작할 준비가되었습니다.

### 사용자 검색

다음과 같이 주어진 단일 사용자 검색 요청부터 시작하겠습니다 `id`.

*app / api / users.py* : 사용자를 반환합니다.

```
from flask import jsonify
from app.models import User

@bp.route('/users/<int:id>', methods=['GET'])
def get_user(id):
    return jsonify(User.query.get_or_404(id).to_dict())
```

보기 함수는 `id`요청 된 사용자의 URL에서 동적 인수로를 수신합니다 . `get_or_404()`쿼리 개체의 방법은 매우 유용 변종 `get()`또한 주어진와 객체 반환 이전에 본 방법 `id`은, 대신에 반환하는있는 경우 `None`(가) 때 `id`존재하지 않는, 그것은 요청 반환 404 오류를 중단을 클라이언트에게. `get_or_404()`over 의 장점은 `get()`쿼리 결과를 확인할 필요가 없어 뷰 기능의 로직이 단순화된다는 것입니다.

`to_dict()`내가 추가 한 방법 `User`은 선택한 사용자의 리소스 표현으로 사전을 생성하는 데 사용되며 Flask의 `jsonify()`기능은 해당 사전을 JSON 형식으로 변환하여 클라이언트로 반환합니다.

이 첫 번째 API 경로의 작동 방식을 보려면 서버를 시작한 다음 브라우저의 주소 표시 줄에 다음 URL을 입력하십시오.

```
http://localhost:5000/api/users/1
```

JSON 형식으로 렌더링 된 첫 번째 사용자가 표시됩니다. 또한 큰 `id`값 을 사용 `get_or_404()`하여 SQLAlchemy 쿼리 개체 의 메서드가 404 오류를 트리거하는 방법 을 확인하십시오 (나중에 이러한 오류가 JSON 형식으로 반환되도록 오류 처리를 확장하는 방법을 보여 드리겠습니다).

이 새로운 경로를 테스트 하기 위해 API 요청을 쉽게 보낼 수 있도록 Python으로 작성된 명령 행 HTTP 클라이언트 인 [HTTPie](https://httpie.org/) 를 설치 [하겠습니다](https://httpie.org/) .

```
(venv) $ pip install httpie
```

이제 다음 명령을 사용하여 `id`of `1`(있는 경우) 사용자 정보를 요청할 수 있습니다 .

```
(venv) $ http GET http://localhost:5000/api/users/1
HTTP/1.0 200 OK
Content-Length: 457
Content-Type: application/json
Date: Mon, 27 Nov 2017 20:19:01 GMT
Server: Werkzeug/0.12.2 Python/3.6.3

{
    "_links": {
        "avatar": "https://www.gravatar.com/avatar/993c...2724?d=identicon&s=128",
        "followed": "/api/users/1/followed",
        "followers": "/api/users/1/followers",
        "self": "/api/users/1"
    },
    "about_me": "Hello! I'm the author of the Flask Mega-Tutorial.",
    "followed_count": 0,
    "follower_count": 1,
    "id": 1,
    "last_seen": "2017-11-26T07:40:52.942865Z",
    "post_count": 10,
    "username": "miguel"
}
```

### 사용자 모음 검색

모든 사용자의 컬렉션을 반환하려면 이제 다음 `to_collection_dict()`방법을 사용할 수 있습니다 `PaginatedAPIMixin`.

*app / api / users.py* : 모든 사용자의 컬렉션을 반환합니다.

```
from flask import request

@bp.route('/users', methods=['GET'])
def get_users():
    page = request.args.get('page', 1, type=int)
    per_page = min(request.args.get('per_page', 10, type=int), 100)
    data = User.to_collection_dict(User.query, page, per_page, 'api.get_users')
    return jsonify(data)
```

이 구현을 위해 먼저 요청의 쿼리 문자열에서 추출 `page`하고 `per_page`기본값을 1과 10으로 정의합니다 (정의되지 않은 경우). 는 `per_page`그 서버에 대한 성능 문제가 발생할 수 있으므로 정말 큰 페이지를 요청하는 클라이언트 제어주기 (100)에서 캡은, 좋은 생각이 아니라고 추가 로직이있다. `page`및 `per_page`인수는 다음에 전달되는 `to_collection_query()`이 경우 단순히 쿼리와 함께, 방법 `User.query`, 가장 일반적인 쿼리 즉 반환 모든 사용자. 마지막 인수는이며 `api.get_users`, 표현에 사용되는 세 개의 링크에 필요한 엔드 포인트 이름입니다.

HTTPie로이 엔드 포인트를 테스트하려면 다음 명령을 사용하십시오.

```
(venv) $ http GET http://localhost:5000/api/users
```

다음 두 끝점은 팔로어와 사용자를 반환하는 끝점입니다. 이것들은 위의 것과 상당히 유사합니다.

*app / api / users.py* : 팔로워 및 팔로우 된 사용자를 반환합니다.

```
@bp.route('/users/<int:id>/followers', methods=['GET'])
def get_followers(id):
    user = User.query.get_or_404(id)
    page = request.args.get('page', 1, type=int)
    per_page = min(request.args.get('per_page', 10, type=int), 100)
    data = User.to_collection_dict(user.followers, page, per_page,
                                   'api.get_followers', id=id)
    return jsonify(data)

@bp.route('/users/<int:id>/followed', methods=['GET'])
def get_followed(id):
    user = User.query.get_or_404(id)
    page = request.args.get('page', 1, type=int)
    per_page = min(request.args.get('per_page', 10, type=int), 100)
    data = User.to_collection_dict(user.followed, page, per_page,
                                   'api.get_followed', id=id)
    return jsonify(data)
```

이 두 경로는 사용자마다 다르기 때문에 `id`동적 인수가 있습니다. 는 `id`데이터베이스에서 사용자를 가져 오는 데 사용하고 제공 `user.followers`과 `user.followed`관계를 기반으로 쿼리를 `to_collection_dict()`추가 약간의 시간을 보내고 일반적인 방법으로이 방법을 설계하는 것은 정말 떨어져 지불 왜 그렇게 잘하면 지금 당신이 볼 수 있습니다. 마지막 두 개의 인수 `to_collection_dict()`는 엔드 포인트 이름과이며 `id`,이 메소드는에서 추가 키워드 인수 로 사용하여 표현의 링크 섹션을 생성 `kwargs`할 `url_for()`때 전달합니다 .

이전 예제와 유사하게 다음과 같이 HTTPie를 사용하여이 두 경로를 연습 할 수 있습니다.

```
(venv) $ http GET http://localhost:5000/api/users/1/followers
(venv) $ http GET http://localhost:5000/api/users/1/followed
```

하이퍼 미디어 덕분에 이러한 URL `_links`은 사용자 표현 섹션에 포함되어 있으므로 기억할 필요가 없습니다 .

### 신규 사용자 등록

*/ users* 경로에 대한 `POST`요청 은 새 사용자 계정을 등록하는 데 사용됩니다. 아래에서이 경로의 구현을 볼 수 있습니다.

*app / api / users.py* : 새 사용자를 등록하십시오.

```
from flask import url_for
from app import db
from app.api.errors import bad_request

@bp.route('/users', methods=['POST'])
def create_user():
    data = request.get_json() or {}
    if 'username' not in data or 'email' not in data or 'password' not in data:
        return bad_request('must include username, email and password fields')
    if User.query.filter_by(username=data['username']).first():
        return bad_request('please use a different username')
    if User.query.filter_by(email=data['email']).first():
        return bad_request('please use a different email address')
    user = User()
    user.from_dict(data, new_user=True)
    db.session.add(user)
    db.session.commit()
    response = jsonify(user.to_dict())
    response.status_code = 201
    response.headers['Location'] = url_for('api.get_user', id=user.id)
    return response
```

이 요청은 요청 본문에 제공된 클라이언트에서 JSON 형식의 사용자 표현을 수락합니다. Flask는 `request.get_json()`요청에서 JSON을 추출하여 Python 구조로 반환 하는 방법을 제공합니다 . 이 메소드는 `None`요청에 JSON 데이터가 없으면 return을 사용하여 항상 expression을 사용하여 사전을 얻을 수 있습니다 `request.get_json() or {}`.

데이터를 사용하기 전에 모든 정보를 얻었는지 확인해야하므로 3 개의 필수 필드가 포함되어 있는지 확인해야합니다. 이들은 `username`, `email`와 `password`. 누락 된 것이 있으면 *app / api / errors.py* 모듈 의 `bad_request()`도우미 함수를 사용 하여 클라이언트에 오류를 반환합니다. 그 확인 외에도 다른 사용자가 및 필드를 사용하고 있지 않은지 확인해야 하므로 제공된 사용자 이름과 이메일로 데이터베이스에서 사용자를로드하려고 시도합니다. 사용자에게도 클라이언트에게 오류를 반환합니다.`username``email`

데이터 유효성 검사를 통과하면 사용자 개체를 쉽게 만들어 데이터베이스에 추가 할 수 있습니다. 사용자를 만들려면 모델 의 `from_dict()`메서드를 사용합니다 `User`. `new_user`인수로 설정 `True`이 또한 허용되도록, `password`일반적으로 사용자의 표현의 일부가 아닌 필드.

이 요청에 대해 반환하는 응답은 새로운 사용자를 나타내므로 `to_dict()`해당 페이로드를 생성합니다. `POST`자원을 작성 하는 요청 의 상태 코드는 201이어야하며, 새 엔티티가 작성 될 때 사용됩니다. 또한 HTTP 프로토콜에서는 201 응답 `Location`에 새 자원의 URL로 설정된 헤더가 포함 되어야합니다.

아래에서는 HTTPie를 통해 명령 줄에서 새 사용자를 등록하는 방법을 볼 수 있습니다.

```
(venv) $ http POST http://localhost:5000/api/users username=alice password=dog \
    email=alice@example.com "about_me=Hello, my name is Alice!"
```

### 사용자 편집

API에서 사용할 마지막 끝점은 기존 사용자를 수정하는 끝점입니다.

*app / api / users.py* : 사용자를 수정합니다.

```
@bp.route('/users/<int:id>', methods=['PUT'])
def update_user(id):
    user = User.query.get_or_404(id)
    data = request.get_json() or {}
    if 'username' in data and data['username'] != user.username and \
            User.query.filter_by(username=data['username']).first():
        return bad_request('please use a different username')
    if 'email' in data and data['email'] != user.email and \
            User.query.filter_by(email=data['email']).first():
        return bad_request('please use a different email address')
    user.from_dict(data, new_user=False)
    db.session.commit()
    return jsonify(user.to_dict())
```

이 요청 `id`에 대해 URL의 동적 부분으로 사용자 를 수신 하므로 지정된 사용자를로드하고 404 오류가 없으면이를 리턴 할 수 있습니다. 아직 인증이 없으므로 지금 API는 사용자가 다른 사용자의 계정을 변경할 수 있도록 허용합니다. 이것은 나중에 인증이 추가 될 때 해결 될 것입니다.

새 사용자의 경우와 마찬가지로 클라이언트가 제공 한 `username`및 `email`필드가 다른 사용자와 충돌하지 않는지 확인해야 하지만이 경우 유효성 검사가 좀 더 까다 롭습니다. 우선,이 필드는이 요청에서 선택 사항이므로 필드가 존재하는지 확인해야합니다. 두 번째 합병증은 클라이언트가 동일한 값을 제공한다는 것이므로 사용자 이름 또는 이메일이 사용되는지 확인하기 전에 현재 사용자 이름 또는 이메일 이름과 다른지 확인해야합니다. 이러한 유효성 검사 중 하나라도 실패하면 이전과 같이 400 오류를 클라이언트에 다시 반환합니다.

데이터의 유효성이 확인되면 모델 의 `from_dict()`방법을 사용 `User`하여 클라이언트가 제공 한 모든 데이터를 가져온 다음 변경 사항을 데이터베이스에 커밋 할 수 있습니다. 이 요청의 응답은 업데이트 된 사용자 표현을 기본 200 상태 코드와 함께 사용자에게 반환합니다.

다음은 `about_me`HTTPie로 필드 를 편집하는 요청 예입니다 .

```
(venv) $ http PUT http://localhost:5000/api/users/2 "about_me=Hi, I am Miguel"
```

## API 인증

이전 섹션에서 추가 한 API 엔드 포인트는 현재 모든 클라이언트에게 열려 있습니다. 분명히 그것들은 등록 된 사용자 만 이용할 수 있어야하며, 그렇게하려면 *인증* 및 *권한 부여* , 또는 "AuthN"및 "AuthZ"를 간단히 추가해야합니다 . 클라이언트가 보낸 요청은 일종의 식별을 제공하여 서버가 클라이언트가 나타내는 사용자를 알고 요청 된 조치가 해당 사용자에게 허용되는지 여부를 확인할 수 있습니다.

이러한 API 엔드 포인트를 보호하는 가장 확실한 방법 `@login_required`은 Flask-Login 의 데코레이터 를 사용하는 것이지만이 방법에는 몇 가지 문제가 있습니다. 데코레이터는 인증되지 않은 사용자를 감지하면 사용자를 HTML 로그인 페이지로 리디렉션합니다. API에는 HTML 또는 로그인 페이지 개념이 없으며, 클라이언트가 유효하지 않거나 누락 된 자격 증명으로 요청을 보내면 서버는 401 상태 코드를 반환하는 요청을 거부해야합니다. 서버는 API 클라이언트가 웹 브라우저이거나 리디렉션을 처리하거나 HTML 로그인 양식을 렌더링하고 처리 할 수 있다고 가정 할 수 없습니다. API 클라이언트는 401 상태 코드를 받으면 사용자에게 자격 증명을 요구해야한다는 것을 알고 있지만 실제로는 서버의 업무가 아닙니다.

### 사용자 모델의 토큰

API 인증 요구를 위해 *토큰* 인증 체계 를 사용하겠습니다 . 클라이언트가 API와의 상호 작용을 시작하려면 사용자 이름과 비밀번호로 인증하는 임시 토큰을 요청해야합니다. 그러면 클라이언트는 토큰이 유효한 한 토큰을 인증으로 전달하는 API 요청을 보낼 수 있습니다. 토큰이 만료되면 새 토큰을 요청해야합니다. 사용자 토큰을 지원하기 위해 `User`모델 을 확장하겠습니다 .

*app / models.py* : 사용자 토큰 지원.

```
import base64
from datetime import datetime, timedelta
import os

class User(UserMixin, PaginatedAPIMixin, db.Model):
    # ...
    token = db.Column(db.String(32), index=True, unique=True)
    token_expiration = db.Column(db.DateTime)

    # ...

    def get_token(self, expires_in=3600):
        now = datetime.utcnow()
        if self.token and self.token_expiration > now + timedelta(seconds=60):
            return self.token
        self.token = base64.b64encode(os.urandom(24)).decode('utf-8')
        self.token_expiration = now + timedelta(seconds=expires_in)
        db.session.add(self)
        return self.token

    def revoke_token(self):
        self.token_expiration = datetime.utcnow() - timedelta(seconds=1)

    @staticmethod
    def check_token(token):
        user = User.query.filter_by(token=token).first()
        if user is None or user.token_expiration < datetime.utcnow():
            return None
        return user
```

이 변경으로 `token`사용자 모델에 속성을 추가 하고 데이터베이스를 검색해야하기 때문에 고유하고 색인을 생성합니다. 또한 `token_expiration`토큰이 만료되는 날짜와 시간이있는을 추가했습니다 . 토큰이 오랫동안 유효하지 않아 보안 위험이 발생할 수 있습니다.

이 토큰으로 작업하기위한 세 가지 방법을 만들었습니다. 이 `get_token()`메소드는 사용자의 토큰을 리턴합니다. 토큰은 모든 문자가 읽을 수있는 범위에 있도록 base64로 인코딩 된 임의의 문자열로 생성됩니다. 새 토큰을 만들기 전에이 방법은 현재 할당 된 토큰이 만료되기 최소 1 분 남았는지 확인한 다음 기존 토큰이 반환되는지 확인합니다.

토큰으로 작업 할 때는 만료 날짜에만 의존하는 대신 항상 토큰을 즉시 철회하는 전략을 세우는 것이 좋습니다. 이것은 종종 간과되는 보안 모범 사례입니다. 이 `revoke_token()`방법은 단순히 만료 날짜를 현재 시간 1 초 전으로 설정하여 사용자에게 현재 지정된 토큰을 무효화합니다.

이 `check_token()`메소드는 토큰을 입력으로 받아서이 토큰이 속한 사용자를 응답으로 리턴하는 정적 메소드입니다. 토큰이 유효하지 않거나 만료 된 경우 메소드는를 반환합니다 `None`.

데이터베이스를 변경 했으므로 새 데이터베이스 마이그레이션을 생성 한 다음 데이터베이스를 사용하여 데이터베이스를 업그레이드해야합니다.

```
(venv) $ flask db migrate -m "user tokens"
(venv) $ flask db upgrade
```

### 토큰 요청

API를 작성할 때 클라이언트가 항상 웹 애플리케이션에 연결된 웹 브라우저가되는 것은 아니라는 점을 고려해야합니다. 진정한 API 기능은 스마트 폰 앱 또는 브라우저 기반 단일 페이지 애플리케이션과 같은 독립형 클라이언트가 백엔드 서비스에 액세스 할 수있는 경우에 제공됩니다. 이러한 특수한 클라이언트가 API 서비스에 액세스해야하는 경우, 전통적인 웹 애플리케이션의 로그인 양식에 해당하는 토큰을 요청하여 시작합니다.

토큰 인증을 사용할 때 클라이언트와 서버 간의 상호 작용을 단순화하기 위해 [Flask-HTTPAuth](https://flask-httpauth.readthedocs.io/) 라는 [Flask](https://flask-httpauth.readthedocs.io/) 확장을 사용하겠습니다 . Flask-HTTPAuth는 pip와 함께 설치됩니다.

```
(venv) $ pip install flask-httpauth
```

Flask-HTTPAuth는 API에 적합한 몇 가지 인증 메커니즘을 지원합니다. 먼저 클라이언트가 표준 [인증](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Authorization) HTTP 헤더 에서 사용자 자격 증명을 보내는 [HTTP 기본 인증](https://en.wikipedia.org/wiki/Basic_access_authentication) 을 사용하겠습니다 . Flask-HTTPAuth와 통합하려면 응용 프로그램에서 두 가지 기능을 제공해야합니다. 하나는 사용자가 제공 한 사용자 이름과 비밀번호를 확인하는 논리를 정의하고 다른 하나는 인증 실패시 오류 응답을 반환합니다. 이 함수는 데코레이터를 통해 Flask-HTTPAuth에 등록 된 다음 인증 과정에서 필요에 따라 확장 프로그램에서 자동으로 호출됩니다. 구현을 볼 수 있습니다.

*app / api / auth.py* : 기본 인증 지원.

```
from flask import g
from flask_httpauth import HTTPBasicAuth
from app.models import User
from app.api.errors import error_response

basic_auth = HTTPBasicAuth()

@basic_auth.verify_password
def verify_password(username, password):
    user = User.query.filter_by(username=username).first()
    if user is None:
        return False
    g.current_user = user
    return user.check_password(password)

@basic_auth.error_handler
def basic_auth_error():
    return error_response(401)
```

`HTTPBasicAuth`Flask-HTTPAuth 의 클래스는 기본 인증 흐름을 구현하는 클래스입니다. 두 가지 필수 기능은 각각 데코레이터 `verify_password`와 `error_handler`데코레이터를 통해 구성 됩니다.

확인 기능은 클라이언트가 제공 한 사용자 이름과 비밀번호를 수신하고 `True`신임 정보가 유효하거나 유효 `False`하지 않은 경우 리턴 합니다 . 암호를 확인하려면 클래스 의 `check_password()`방법을 사용합니다.이 방법은 `User`웹 응용 프로그램 인증 중에 Flask-Login에서도 사용됩니다. 인증 된 사용자를에 저장하면 `g.current_user`API보기 기능에서 액세스 할 수 있습니다.

오류 처리기 함수는 단순히 *app / api / errors.py* 의 `error_response()`함수에 의해 생성 된 401 오류를 반환합니다 . 401 오류는 HTTP 표준에서 "무단"오류로 정의됩니다. HTTP 클라이언트는이 오류를 수신하면 전송 한 요청을 유효한 신임 정보로 다시 보내야한다는 것을 알고 있습니다.

이제 기본 인증 지원이 구현되었으므로 클라이언트가 토큰이 필요할 때 호출 할 토큰 검색 경로를 추가 할 수 있습니다.

*app / api / tokens.py* : 사용자 토큰을 생성합니다.

```
from flask import jsonify, g
from app import db
from app.api import bp
from app.api.auth import basic_auth

@bp.route('/tokens', methods=['POST'])
@basic_auth.login_required
def get_token():
    token = g.current_user.get_token()
    db.session.commit()
    return jsonify({'token': token})
```

이 뷰 함수는 인스턴스 의 `@basic_auth.login_required`데코레이터 로 장식되어 `HTTPBasicAuth`Flask-HTTPAuth에 인증 (위에서 정의한 확인 기능을 통해)을 확인하고 제공된 자격 증명이 유효한 경우에만 기능을 실행하도록 지시합니다. 이 뷰 함수의 구현은 `get_token()`토큰을 생성하기 위해 사용자 모델 의 방법에 의존합니다 . 토큰이 생성 된 후 데이터베이스 커밋이 발행되어 토큰과 만료가 데이터베이스에 다시 쓰여지도록합니다.

POST 요청을 토큰 API 경로로 보내려고하면 다음과 같은 상황이 발생합니다.

```
(venv) $ http POST http://localhost:5000/api/tokens
HTTP/1.0 401 UNAUTHORIZED
Content-Length: 30
Content-Type: application/json
Date: Mon, 27 Nov 2017 20:01:00 GMT
Server: Werkzeug/0.12.2 Python/3.6.3
WWW-Authenticate: Basic realm="Authentication Required"

{
    "error": "Unauthorized"
}
```

HTTP 응답에는 401 상태 코드와 `basic_auth_error()`함수 에서 정의한 오류 페이로드가 포함 됩니다. 이번에는 기본 인증 자격 증명을 포함하여 동일한 요청이 있습니다.

```
(venv) $ http --auth <username>:<password> POST http://localhost:5000/api/tokens
HTTP/1.0 200 OK
Content-Length: 50
Content-Type: application/json
Date: Mon, 27 Nov 2017 20:01:22 GMT
Server: Werkzeug/0.12.2 Python/3.6.3

{
    "token": "pC1Nu9wwyNt8VCj1trWilFdFI276AcbS"
}
```

이제 상태 코드는 200이며 이는 성공적인 요청을위한 코드이며 페이로드에는 사용자를 위해 새로 생성 된 토큰이 포함됩니다. 이 요청을 보낼 `:`때는 자신의 자격 증명 으로 바꿔야 합니다. 사용자 이름과 비밀번호는 구분 기호로 콜론을 제공해야합니다.

### 토큰으로 API 경로 보호

클라이언트는 이제 API 엔드 포인트와 함께 사용할 토큰을 요청할 수 있으므로 남은 것은 해당 엔드 포인트에 토큰 확인을 추가하는 것입니다. 이것은 Flask-HTTPAuth가 나를 위해 처리 할 수있는 것입니다. `HTTPTokenAuth`클래스를 기반으로 두 번째 인증 인스턴스를 만들고 토큰 확인 콜백을 제공해야합니다.

*app / api / auth.py* : 토큰 인증 지원.

```
# ...
from flask_httpauth import HTTPTokenAuth

# ...
token_auth = HTTPTokenAuth()

# ...

@token_auth.verify_token
def verify_token(token):
    g.current_user = User.check_token(token) if token else None
    return g.current_user is not None

@token_auth.error_handler
def token_auth_error():
    return error_response(401)
```

토큰 인증을 사용할 때 Flask-HTTPAuth는 `verify_token`데코 레이팅 된 기능을 사용 하지만 그 외에는 토큰 인증이 기본 인증과 같은 방식으로 작동합니다. 내 토큰 확인 기능은 `User.check_token()`제공된 토큰을 소유 한 사용자를 찾는 데 사용 됩니다. 이 함수는 현재 사용자를로 설정하여 누락 된 토큰의 경우도 처리합니다 `None`. `True`또는 `False`영약-HTTPAuth 실행 여부하는보기 기능을 허용하는 경우 리턴 값 결정한다.

토큰으로 API 경로를 보호하려면 `@token_auth.login_required`데코레이터를 추가해야합니다.

*app / api / users.py* : 토큰 인증으로 사용자 경로를 보호합니다.

```
from flask import g, abort
from app.api.auth import token_auth

@bp.route('/users/<int:id>', methods=['GET'])
@token_auth.login_required
def get_user(id):
    # ...

@bp.route('/users', methods=['GET'])
@token_auth.login_required
def get_users():
    # ...

@bp.route('/users/<int:id>/followers', methods=['GET'])
@token_auth.login_required
def get_followers(id):
    # ...

@bp.route('/users/<int:id>/followed', methods=['GET'])
@token_auth.login_required
def get_followed(id):
    # ...

@bp.route('/users', methods=['POST'])
def create_user():
    # ...

@bp.route('/users/<int:id>', methods=['PUT'])
@token_auth.login_required
def update_user(id):
    if g.current_user.id != id:
        abort(403)
    # ...
```

`create_user()`토큰을 요청할 사용자를 먼저 작성해야하기 때문에 데코레이터는를 제외한 모든 API보기 함수에 추가됩니다 . 또한 `PUT`사용자를 수정 하는 요청에 사용자가 다른 사용자의 계정을 수정하려고 시도하지 못하게하는 추가 검사가있는 방법에 유의하십시오 . 요청한 사용자 ID가 인증 된 사용자의 ID와 일치하지 않으면 클라이언트에 요청 된 작업을 수행 할 권한이 없음을 나타내는 403 오류 응답을 반환합니다.

이전에 표시된대로 이러한 엔드 포인트에 요청을 보내면 401 오류 응답이 다시 나타납니다. 액세스하려면 `Authorization`요청에서받은 토큰과 함께 */ api / tokens에* 헤더 를 추가해야합니다 . Flask-HTTPAuth는 토큰이 "베어러"토큰으로 전송 될 것으로 예상합니다.이 토큰은 HTTPie에서 직접 지원되지 않습니다. 사용자 이름과 비밀번호를 사용한 기본 인증의 경우 HTTPie는 `--auth`옵션을 제공 하지만 토큰의 경우 헤더를 명시 적으로 제공해야합니다. 베어러 토큰을 보내는 구문은 다음과 같습니다.

```
(venv) $ http GET http://localhost:5000/api/users/1 \
    "Authorization:Bearer pC1Nu9wwyNt8VCj1trWilFdFI276AcbS"
```

### 토큰 해지

마지막으로 구현할 토큰 관련 기능은 토큰 해지입니다. 아래에서 볼 수 있습니다.

*app / api / tokens.py* : 토큰을 취소합니다.

```
from app.api.auth import token_auth

@bp.route('/tokens', methods=['DELETE'])
@token_auth.login_required
def revoke_token():
    g.current_user.revoke_token()
    db.session.commit()
    return '', 204
```

클라이언트는 */ tokens* URL에 `DELETE`요청을 보내 *토큰* 을 무효화 할 수 있습니다. 이 경로에 대한 인증은 토큰 기반이며, 실제로 `Authorization`헤더로 전송 된 토큰 은 해지되는 토큰 입니다. 해지 자체는 `User`클래스 의 도우미 메서드를 사용 하여 토큰의 만료 날짜를 재설정합니다. 이 변경 사항이 데이터베이스에 기록되도록 데이터베이스 세션이 커밋됩니다. 이 요청의 응답에는 본문이 없으므로 빈 문자열을 반환 할 수 있습니다. return 문의 두 번째 값은 응답의 상태 코드를 204로 설정합니다.이 코드는 응답 본문이없는 성공적인 요청에 사용할 코드입니다.

다음은 HTTPie에서 보낸 토큰 해지 요청의 예입니다.

```
(venv) $ http DELETE http://localhost:5000/api/tokens \
    Authorization:"Bearer pC1Nu9wwyNt8VCj1trWilFdFI276AcbS"
```

## API 친화적 인 오류 메시지

유효하지 않은 사용자 URL로 브라우저에서 API 요청을 보내도록 요청했을 때이 장의 초기에 발생한 일을 기억하십니까? 서버가 404 오류를 리턴했지만이 오류는 표준 404 HTML 오류 페이지로 형식화되었습니다. API에서 반환해야 할 많은 오류는 API 청사진의 JSON 버전으로 재정의 될 수 있지만 Flask에서 처리 한 일부 오류는 여전히 응용 프로그램에 전역 적으로 등록 된 오류 처리기를 통과하며 HTML을 계속 반환합니다. .

HTTP 프로토콜은 클라이언트와 서버가 *컨텐츠 협상* 이라는 응답에 가장 적합한 형식에 동의 할 수있는 메커니즘을 지원합니다 . 클라이언트 `Accept`는 형식 기본 설정을 나타내는 요청과 함께 헤더 를 보내야합니다 . 그런 다음 서버는 목록을보고 클라이언트가 제공 한 목록에서 지원하는 최상의 형식을 사용하여 응답합니다.

내가하고 싶은 것은 전역 응용 프로그램 오류 처리기를 수정하여 클라이언트 기본 설정에 따라 콘텐츠 협상을 사용하여 HTML 또는 JSON으로 응답하도록하는 것입니다. 이것은 `request.accept_mimetypes`Flask 의 객체를 사용하여 수행 할 수 있습니다 .

*app / errors / handlers.py* : 오류 응답을위한 컨텐츠 협상.

```
from flask import render_template, request
from app import db
from app.errors import bp
from app.api.errors import error_response as api_error_response

def wants_json_response():
    return request.accept_mimetypes['application/json'] >= \
        request.accept_mimetypes['text/html']

@bp.app_errorhandler(404)
def not_found_error(error):
    if wants_json_response():
        return api_error_response(404)
    return render_template('errors/404.html'), 404

@bp.app_errorhandler(500)
def internal_error(error):
    db.session.rollback()
    if wants_json_response():
        return api_error_response(500)
    return render_template('errors/500.html'), 500
```

`wants_json_response()`도우미 함수는 원하는 형식의 자신의 목록에있는 클라이언트에 의해 선택된 JSON 또는 HTML에 대한 선호도를 비교합니다. JSON이 HTML보다 높은 경우 JSON 응답을 반환합니다. 그렇지 않으면 템플릿을 기반으로 원래 HTML 응답을 반환합니다. JSON 응답의 `error_response`경우 API 블루 프린트에서 도우미 함수 를 가져 오려고합니다 . 그러나 여기서는 `api_error_response()`그것이 무엇을하고 어디에서 왔는지 명확하게 하기 위해 이름을 바꿀 것 입니다.

