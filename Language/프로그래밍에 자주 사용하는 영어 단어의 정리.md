# 프로그래밍에 자주 사용하는 영어 단어의 정리

출처: https://qiita.com/Ted-HM/items/7dde25dcffae4cdc7923



## 사용하지 말아야 할 말

**get / set**
액세서 (getter / setter)나 프로퍼티에 자주 사용되고 있다.
그 이외에 사용하면 혼란을 초래하므로 좋지 않다.
get 은 경량의 처리라고 생각하므로, 안에 무거운 처리는 써서는 안 된다.
단순한 취득/설정 이외에서 사용하고 싶어지면 다른 말을 생각한다.

```
load, save, commit, store, enable, disable,
fetch, register, configure, add, etc...
```

**check**
의미가 너무 넓어서 무엇을 하고 있는지 모르겠다.
가능한 한 다른 단어를 사용하십시오.
구체적으로 무엇을 하고 있는지를 분해해 생각하면 좋다.
대신 자주 사용되는 메소드/프로퍼티명은 아래와 같다.

```
isNull, isEmpty, isNullOrEmpty, isValid, canSave, canClose,
hasSaved, hasChanged, exists, contains, etc...
```

체크 마크를 붙이는 의미로 check 를 사용하는 경우는 예외.
check 자체를 피하고 싶은 경우는 putCheckmark 로 한다.

**change**
무엇을 어떻게 변경하고 있는지 모른다.
check 와 같이 구체적인 이름으로 할 수 없는가 생각해 보면 좋다.
예외로서 isChanged 의 플래그를 변경하기 위한 Change 메소드에 사용하는 경우가 있다.

**xxxManager / xxxController**
이런 이름을 붙이면 클래스가 비대하기 쉽다.
단일 책임의 원칙에 따라 클래스를 설계하는 것.
UNIX 철학에도 "Small is beautiful."라는 생각이 있다.

**xxxType, xxxData, xxxItem, xxxInfo**
이중화되기 쉽다.
Type, Data, Item, Info를 취해도 의미가 통하지 않는지 검토해 본다.

## 사용하지 않는 것이 더 나은 단어

**compare**
비교한다.
편리할 때도 있지만 비교한 결과가 어떻게 될지 알기 어렵기 때문에 다른 동사를 검토한다.

```
exists, contains, equals, isSmall, max, min, etc...
```

**toggle**
전환, 교체.
실행할 때마다 상태가 전환되므로 디버깅이 어려워집니다.
편리할 때도 있지만, 전환한 상태가 어떻게 될지 알기 어렵기 때문에 다른 동사를 검토한다.

```
turnOn, turnOff, switchOn, switchOff, etc...
```

## 쌍을 이루는 말

**comment out / uncomment**
코멘트로 한다, 코멘트를 해제한다.
comment out 은 into a comment 의 의미.
comment 뿐이라면 코멘트한다, 평가하는 의미가 된다.

**add / remove**
추가, 삭제.
리스트 등에 값을 넣는 경우 등에도 사용된다.
특히, 말미에 추가하는 경우는 append, 선두에 추가하는 경우는 prepend 를 사용한다.
Add A to B에서 A를 B에 추가합니다.
Remove A from B에서 B에서 A를 제거합니다.

**start / stop**
시작, 중지. 명사라면 시작, 정지.
정지 상태에서 움직이는 느낌이 start.
도중부터라도 사용할 수 있다.
바코드나 통신의 부호로 StartCode / StopCode 라고 하는 사용법을 한다.

**begin/end**
시작, 끝.
첫걸음을 내디뎠 느낌이 begin.
처음에만 사용할 수 있다.
C 언어에서는 일반적으로 begin은 포함하고 end는 배타적입니다.

**first/last**
처음, 끝.
단순한 배열의 경우나 수를 세는 경우는 first 를 사용한다.
셀 수 없는 경우는 beginning 를 사용한다.

**최소/최대**
최소, 최대.

**top/last**
선두, 후미.
순위나 레벨을 의식하는 경우는 top 을 사용한다.

**head/tail**
머리・꼬리로부터 돌아서 선두・말미.
파일의 시작과 끝을 나타내는 데 사용됩니다.

**header/footer**
헤더, 바닥글.
본문을 나타내는 경우는 text 나 ​​body 가 사용된다.

**top/bottom**
정상, 하단.

**up/down**
위로, 아래로.

**horizontal / vertical**
수평, 수직.
스크롤 바의 방향을 나타내는데 사용한다.

**landscape/portrait**
가로, 세로.
인쇄나 스마트폰의 화면 방향을 나타내는데 사용한다.

**width/height/depth**
가로, 높이, 깊이.
업계에 따라 LHW나 WDH라는 표현이 있다.
L은 length(길이)입니다.

**대문자/소문자**
큰글자, 작은글자.

**wide / narrow**
넓고, 좁은에서 돌려 전각, 반각.
full-width 와 half-width 에서도 전각과 반각.
two-byte character 와 one-byte character 로 2 바이트 문자와 1 바이트 문자.

**under/over**
미만, 초과.

**or under / and over**
이하, 이상.
greater than이나 not less than 등 다수의 말투가 있다.
약어도 많고 LE / GE가 많이 사용된다.
LE는 less than or equal, less or equal.

**earlier / later**
이전, 뒤.
소프트웨어 버전을 나타내는 경우에 사용한다.
version 3.0 or later 로 버전 3.0 이후.

**go/back**
앞으로, 뒤로.
다른 계층 간의 이동 이미지.

**previous / next / current**
이전, 다음, 현재.
동일한 계층 구조에서 가로 이동의 이미지.
동사로 하는 경우는, goNext, moveNext 등.
current 는 현재의 위치를 ​​나타내는 경우 등에 사용된다.

**앞으로 / 뒤로**
앞, 뒤.

**foreground/background**
전경, 배경.
프로그래밍에서는 사용하지 않지만 middle-ground 로 중경이라는 말도 있다.

**push/pull**
넣어, 당긴다.
Git 명령에 사용됩니다.
git push 와 반대의 동작은 git pull 는 아니고 git fetch 가 된다.

**push/pop**
상자에 넣어, 안에서 꺼낸다.
접시를 겹치는 이미지.
스택에 사용한다.

**enqueue/dequeue**
큐에 추가하는, 큐로부터 꺼낸다.
queue는 큐의 의미입니다.
말미는 上上(ueue)로 기억해 두면 철자에 헤매지 않는다.


신청 **전/후 .**

**parent / child / children / sibling / self**
부모, 아이, 아이들, 형제, 자신.
XML이나 Tree의 Node를 나타내는 경우 등에.

**ancestors / descendants**
조상, 후손.
대부분 복수형으로 사용된다.
Git의 역사 등에.

**do / undo / redo**
실행, 취소 및 재실행.
전자 의료 기록의 do는 ditto (이전과 동일)의 의미.

**open/close**
파일이나 소켓을 열고 닫습니다.

**backup / restore**
데이터베이스를 백업하고 복원합니다.

**create/delete/restore**
파일을 작성, 삭제, 복원합니다.

**connect/disconnect**
회선을 접속, 절단한다.
약하는 경우는 conn으로 하는 것이 많다.

**source/destination**
소스, 목적지.
생략하는 경우는 src, dst 로 하는 것이 많다.

**input/output**
입력한다, 출력한다.
장치(화면, 키보드 등)의 입출력.
파일등의 경우는 변환이 없을 때에 사용한다.

**inclusive / exclusive**
포함, 포함되지 않습니다.
날짜나 범위를 나타내는 경우에 명시적으로 사용한다.
startInclusive, endExclusive.

**가져오기/내보내기**
, 수입, 가져오기.
밖으로 발행, 수출하는, 수출.
내용을 변경하고 나서 처리하는 경우에 사용한다.

**explicit/implicit**
명시적, 암시적.
ex-의 어간은 out-이므로 개방적.
망설이면 import / export 관계를 기억하는 것이 좋다.

**손실/무손실 비가역**
, 가역.

**encode/decode**
인코딩, 디코딩.
인코딩, 복합.

**encrypt / decrypt**
암호화, 해독 (복호)한다.
일본어의 문제이지만, 「암호화한다」의 반대는 「복호"화"한다"는 아니기 때문에 주의.

**download / upload**
다운로드, 업로드.

**request/response**
요청, 희망, 요청.
답변, 반응, 응답.

**request / respond 요청**
, 응답.

**fetch/post**
가져오기, 게시.
네트워크를 통해 데이터를 가져오는 경우 fetch를 사용할 수 있습니다.
post 대신 send 에서도 가능.

**serialize / deserialize**
직렬화, 복원.
직렬화란 메모리상에 있는 데이터를 파일 형식으로 변환하는 처리.

**read/write**
파일이나 포트를 읽어내, 기입한다.
read는 읽는 활동 자체를 가리킨다.

**save/load**
저장, 불러오기.
읽어들여 넣는(설정한다)까지가 load.

**set/unset/reset**
설정, 해제, 초기 위치로 재설정합니다.

**check/uncheck**
체크를 넣는다, 체크를 해제한다.

**lock/unlock**
잠그거나 해제합니다.

**attach / detach**
연결, 분리.
데이터베이스의 파일이나 외부 프로그램의 디버그시에 사용되고 있다.

**suspend / resume**
휴지, 복귀.

**enable / disable**
사용 가능, 사용 불가능.

**active / inactive**
유효, 무효.

**activate/deactivate**
활성화하거나 비활성화합니다.

**show / hide**
표시, 숨기기.

**visible / hidden**
표시, 숨김.
hidden 쪽이 invisible 보다 육체적인 느낌.

**valid / invalid**
유효한, 유효하지 않습니다.
validation에서 검증의 의미.

**collapse / expand**
접히고 확장합니다.
트리를 조작하는 경우에 사용한다.

**zero padding / zero suppression**
제로 채우기, 제로 억제.
123 → 00123 가 5 자리의 제로 패딩.
00123 → 123 가 제로 서프레스.

**normal/abnormal**
정상, 이상.
명확한 기준이 있고, 맞는가?

**normal/error**
정상, 이상.
정상(보통, 보통)과 그것에 실패한 것.

**regular/irregular**
규칙적인, 불규칙적인. 일상적인, 비일상적인.
일정한 반복 본이 있고 거기에 적용되는가?
텔레비전 출연자를 레귤러라고 부르지만, 매회 출연하기 때문에.

**general / special**
일반, 특별.
general은 전반적인 세상 일반적인 느낌.

**ordinal / special**
평범하고 특별한.
ordinal은 특필할 일이 없는 부정적인 느낌.

**common / special**
공통, 고유.
공통 설정에서 공통 설정.

**common / personal**
공유의, 개인의.

**common/uncommon**
흔한, 흔하지 않습니다.

**social / personal**
사회적, 개인.

**public / private**
공공, 사적인.

**조직 / 개인**
조직, 개인.

**available/unavailable**
사용 가능, 사용 불가 또는 사용 가능, 사용 불가.

**success/failure**
성공, 실패.
success 와 error 를 사용하는 경우도.
OK와 NG는 일본식 영어이기 때문에 공장 정도로밖에 통하지 않는다.

**accept/refuse**
승낙, 거부한다.

**allow / deny**
허용, 거부. 아라우, 디나이와 발음한다.
파일 시스템의 허가나 네트워크 관련에서는 실패하면 자주 denied 라고 말해진다.

**host/guest**
호스트, 게스트.
손님을 초대하는 측이 호스트. 서버의 의미에서도 사용된다.
손님이 손님.

**server/client/peer**
서버, 클라이언트, 피어.
서비스를 제공하는 측이 서버.
의뢰하는 것이 클라이언트.
접속하고 있는 상대의 컴퓨터는 피어.

**공급자 / 소비자**
공급자, 소비자.
React useContext 등에서 사용된다.

**provider/user**
제공자, 사용자.
DICOM의 SCP와 SCU는 서버와 클라이언트의 의미에서 사용된다.

**caller / callee**
발신자, 수신자로부터 돌려 함수 호출자 및 호출자.
말미가 ee로 끝나면 「한 사람」을 나타낸다.
employee (직원), examinee (대상) 등.

**duplicate/dedupe**
중복, 중복 제거.
dedupe는 동사에서 중복을 제거하는 의미에서도 사용된다.

**mutable / immutable**
가변, 불변의.
immutable은 한 번 작성한 변수의 내용을 변경할 수 없습니다.
mutable은 그 반대로 변경할 수 있다는 것.

**built-in / plug-in**
내장, 플러그인.
플러그인은 붙일 수있는 경우에 사용됩니다.

**on-premise / cloud**
premises 에서 시설. on- 를 붙이고, 시설내에서. 즉 자사 시스템.
클라우드는 인터넷을 통한 시스템 일반입니다. 클라우드 서비스 등.

## 비슷한 의미의 단어 / 뉘앙스의 차이

**log in / log out**
**log on / log off**
**sign in / sign out / sign up / sign on**
log 는 항해일지(log, logbook)가 어원. 회전하여 PC의 로그에 기록할 것.
log in은 주로 Linux에서 사용됩니다. 계정에 들어갑니다.
log on은 주로 Windows에서 사용됩니다.
sign은 서명이므로 PC가 없는 시대부터 사용되고 있다.
sign in은 주로 웹에서 볼 수 있습니다. 서명하고 들어간다.
sign up 는 신청할 경우. 계정을 만듭니다.
sign on 은 서류에 서명하는 경우.
login, logon, signin은 사용법에 차이가 없습니다.

**certification / authentication**
certification 은 권위를 가진 제3자가 증명하는 이미지. 인증 기관에 의한 증명.
authentication은 두 사람 사이의 증거입니다. 비밀번호 인증 등. 본인 확인.
일본어로는 모두 증명이나 인증이 되므로 혼란한다.

**authentication / authorization**
authentication 은 인증. 로그인 등에서 사용된다. AuthN으로 약칭된다.
authorization 은 인가(승인). 로그인 후 작업이 허용되는지 확인하기 위한 것입니다. AuthZ로 약칭된다.
별로 보이지 않지만 AuthC나 AuthR로 약칭되는 경우도 있다.
auth 뿐이라면 AuthN 에서 사용되는 경우가 많지만, 문맥을 읽어들일 필요가 있다.
그건 그렇고, OAuth는 authorization입니다.
인증 인가로 세트로 취급되는 경우가 많다.

**identify/identification/identifier/identity**
그 사용자가 본인인지 식별하는 것을 identify. 동사.
식별하는 행위 자체는 identification. identify의 명사 형태. 식별, ID, 신분증.
그 사용자를 식별하는 데 사용 정보를 identifier. 식별자. 성명, 변수명 등.
그 사용자를 특성화하는 모든 정보를 identity. 신원, 정체성.

**classify / classification / class**
classify는 분류한다. 동사.
classification은 분류. classify의 명사형.
class 는 분류된 구분.

**category / genre / group**
category는 분류, 종류, 장르입니다.
genre (장르)라는 것은 특히 예술이나 엔터테인먼트에서 사용되는 카테고리.
group은 공통성을 가진 집단입니다. 어떤 카테고리에 속한 그룹?

**kind / class / type**
kind는 대략적인 종류로 사용됩니다. 품종.
클래스는 차별화 된 종류로 사용됩니다. 계급.
type 은 일반적인 의미로 종류를 나타낸다. 더 구체적인 느낌. 종류.

**class / rank**
class 는 계급, 등급, 계층을 나타낸다. 구분은 확실히 하고 있지만, 폭이 있는 느낌.
rank는 외부로부터의 평가에 사용되는 느낌. class 보다 순위를 의식시킨다.

**grade / level**
grade는 등급과 단계를 나타냅니다. 상하나 우열을 나타내지만, 폭이 있는 느낌.
level은 수준을 나타냅니다. grade 더 구체적인 느낌.

**region / realm / domain**
region은 지역과 지역을 나타내는 영역입니다.
realm 은 영토나 분야나 부문을 나타내는 영역.
domain은 활동 범위와 분야를 나타내는 영역입니다.
코드를 접는 영역을 지정하려면 region을 사용합니다.
클라우드에 서버가 있는 지역을 나타내는 경우 region을 사용합니다.
로그인 서버로 단락짓는 영역을 나타내는 경우는 realm 를 사용한다.
인터넷 주소, 소유지를 나타내는 경우는 domain 을 사용한다.
비즈니스의 전문 분야나 프로그램상에서의 역할을 나타내는 경우는 domain 를 사용한다. 도메인 구동.

**config / setting / preference**
구성, 하드보다의 설정, 개발자가 설정하는 것은 config.
소프트측의 설정, 유저가 변경할 수 있는 것은 setting.
유저가 설정하는 것으로 특히 표시나 거동의 취향의 설정은 preference.
기본은 config와 setting의 구분으로 충분하다.

**initialize/set up**
초기화한다. 설정합니다.
둘 다 가장 먼저 할 의미가 강하다.
setup은 명사이지만 set up이면 동사.
종료시에 실시하는 것은 finalize.

**stop/end/finish/complete/terminate**
다시 시작할 수 있는 경우 stop.
재개하지 않는 경우는 end.
끝까지 완료하고 끝나는, 끝내는 것이 finish.
목표를 달성하고 끝나는 것이 complete. 완벽한 느낌.
막다른 곳까지 가서 끝나는 것이 terminate. 마무리되는 느낌.

**stop / suspend / pause**
움직이는 것을 멈추는 것이 stop. 재개될 수 있다.
일시 정지의 경우는 suspend. 한숨 돌린 느낌.
일단 움직임을 멈추는 경우는 pause. 언제든지 움직일 수 있다.

**stop / break / abort / quit / exit**
움직이는 것을 멈추는 것이 stop. 의미가 넓다.
나누어 들어가 중단하는 것을 break.
이상에 의해 중단되는 것이 abort.
현재의 상태로부터 멀어지는 것을 quit.
출구에서 빠져 나가는 것을 exit. 그 자리에서 떠난다.

**show / display**
표시하는 것은 show.
사람이 보기 쉬운 장소에 표시(전시)하는 것이 display.

**calculate/compute**
수식을 사용한 계산을 하는 것이 calculate.
난해한 계산을 하는 것이 compute. 행렬과 해시 계산 등.

**expression / formula**
수식이나 프로그래밍의 평가식을 나타내는 것은 expression.
공식을 나타내는 것은 formula.
이콜을 사용하는 등식, 방정식은 equation.
부등식은 inequality.

**update/upgrade**
최신의 것으로 하는 것이 update.
보다 뛰어난 것으로 대체하는 것이 upgrade. update 보다 교환의 의미가 강하다.
Windows Update는 패치만 적용합니다.
Windows 8에서 10으로 변경하는 것은 upgrade.
버전 업은 일본 제 영어.

**update / refresh**
최신 것을 얻는 것이 update.
새롭게 하는 것이 refresh. 전체를 새롭게 하는 뉘앙스가 있다.
Windows에서는 화면을 갱신하는 경우에 Invalidate(무효화한다)가 사용되지만,
draw area를 무효화하는 것으로써 redraw를 촉구하기 위해(때문에).

**updated / changed / modified / revised**
정보를 최신으로 업데이트한 것이 updated.
전면적으로 변경한 경우는 changed.
수정이나 개선한 경우는 modified.
서류의 수정이나 개정, 개판한 경우는 revised.

**adjust / adapt**
무언가에 맞게 조정하는 것이 adjust. 사이즈를 딱 맞춘다.
주변 환경에 맞게 변경하는 것이 adapt. 커넥터의 형태에 맞추는 것이 어댑터.

**fix / repair / restore / recover**
문제를 해결하고, 원래 상태로 되돌리거나, 고정하는 것을 fix. 의미가 넓고 여러가지 사용할 수 있다.
복잡한 기계를 전문 지식이 있는 사람이 수리하는 것을 repair. 비교적 작은 것에 사용한다.
원래 상태로 복원하는 것을 restore. 가치가 높은 것이나 큰 것에 사용한다. 백업에서 되돌릴 때도 사용한다.
어떻게든 원래의 상태를 되찾아, 복구하는 것을 recover. 복구하지 않아도 회복하면 된다. OS 덮어쓰기 설치 등.

**output / export**
그대로 출력하는 것이 output.
변환하고 내보내는 것이 export.

**find/search for/look for/seek**
찾기를 기대하는 것이 find.
찾아보는 것이 search.
look for 는 가장 일반적인 검색이라고 하는 의미이지만, 찾아내는 것이 비교적 간단할 경우에 사용한다.
보이지 않는 물건을 찾을 때는 seek.

find 는 발견하는 것이 전제이므로, 찾아볼 경우는 try 를 붙이거나, search for 를 사용한다.
실패할 가능성이 있는 메소드에 try 를 붙여, bool 를 돌려주는 용법이 있다.
try to find는 중복되고 어려운 뉘앙스가 있습니다.
`bool Find(object target)`
`bool TryFind(object target)`

search 는 목적어에 장소를 지정하므로 메소드로 하는 경우는 주의.
`bool Search(object place, object target)`
`bool SearchFor(object target)`

**search / retrieve**
검색하는 것이 search.
검색해 가져오는 것이 retrieve.
search는 후보를 나란히 평가하는 기법일 때에 이용한다.

**toXXX / convertToXXX / XXX.parse / XXX.tryParse**
XXX로 변환합니다.
메소드 이름은 동사가 원칙이지만 to는 예외적으로 사용된다.
try가 붙는 경우는 변환을 시도한다.

**encode/decode/convert**
아날로그에서 디지털로 변환하는 것이 encode.
디지털에서 아날로그로 되돌리는 것이 decode.
디지털에서 디지털로 변환하는 것이 convert.

**convert / translate / transform 등가**
인 것으로 변환하는 것이 convert. 섭씨 화씨, 달러 엔 등 같은 것으로 바뀌는 이미지.
전혀 다른 물건으로 변환하는 것이 translate. 번역 등 다른 무언가로 바뀌는 이미지.
조성이 다른 것으로 재조합하는 것이 transform. 모양이 바뀌거나 수식을 바꾸는 이미지.

**clear / delete**
내용만 지우는 것이 clear.
외부를 포함하여 모두 삭제하는 것이 delete.

**erase/trash/delete**
지우개로 지우는 것이 erase. 육체적이고 아날로그적인 느낌. 복원할 수 없습니다.
쓰레기를 버리는 것이 trash(속). 아날로그 느낌. 쓰레기통이 있다.
삭제하는 것이 delete. 디지털 느낌. 복원할 수 있다.
테이프나 메모리의 소거에는 통상적으로 erase 가 사용된다.
erase 한 후에는 덮어 쓸 수있는 이미지.

**create/generate/make/build**
창조하는 아무것도 없는 곳에서 만들어내는 것이 create.
무언가를 변환하여 생성하는 것이 generate.
재료를 조립하고 만드는 것이 build.
재료로부터 만들어내는 것이 make.
명시적으로 인스턴스를 만들 때는 create 를 사용하는 것이 관례.

**parameter / argument**
메소드에 정의하고 있는 것이 parameter.
메소드에 건네진 값은 argument.
가인수(parameter)와 실인수(argument)라고도 한다.
말하기에서 어느 쪽이라도 통한다.

**property / attribute**
어느 쪽도 속성으로 용법에 차이는 없다.
단, 분야나 제품에 따라 구분되어 있다.
객체 지향 클래스의 성질을 나타내는 것은 property.
HTML 태그의 속성은 attribute.

**number / numeric**
숫자, 번호를 나타내는 것이 number.
숫자, 특히 10진수를 나타내는 것이 numeric.
numeric 쪽이 보다 수학적인 느낌.

**sum/total**
금액이나 합계, 요약하는, 더한 것이 sum.
합계, 전체의, 특히 총계를 나타내는 것이 total.

**max / limit**
단순한 최대치를 나타내는 것이 max.
넘으면 안되는 값을 나타내는 것이 limit.
리더블 코드에 의하면 한계치를 포함하는 경우는 min / max 가 좋다고 되어 있다.
first / last 와 begin / end 의 구별에도 언급되고 있다.

**limits/bounds/range**
경계, 제한 범위, 제한 영역이 limits. 제한의 의미가 강하다.
한계 내, 경계선이 bounds. 더 수학적 느낌. 경계를 나타냅니다.
값이 변동하는 폭, 상한 하한이 있는 범위가 range. 범위를 보여줍니다.
limits와 bounds는 복수형으로 사용된다.
bounds check 로 경계 체크.

**top / peak / spike**
정상, 꼭대기, 끝이 top.
산맥 안의 하나의 정상이 peak.
꺾은 선 그래프 등의 뾰족은 spike.
망설이면 top을 사용하면 틀림없다.

**exclude / ignore**
배제한다, 닫는다, 고려하지 않는 것이 exclude.
무시하는, 눈치 채지 않는 척을 하는 것이 ignore.

**state/status**
상태나 상황을 의미하는 것이 state.
상태라는 말을 의미하는 것이 status.
게임 캐릭터의 status에서 독이라는 state에 있다고 생각하면 좋다.

**locale / local**
어플리케이션을 사용하는 국가나 지역, 언어의 설정등을 나타내는 것이 locale.
LAN(Local Area Network)에서 알 수 있듯이, 현지나 그 컴퓨터 자신을 나타내는 것이 local. **로케일**
(a를 강조)과 **로컬** (o를 강조).

**letter / text / character**
a 라든지 b 라든지의 문자 자체는 letter.
문자열이나 본문은 text.
기호나 문자는 character.
집합적으로 알파벳 전체, 문자 전체를 가리키는 경우도 있다.

**title/caption**
책이나 기사의 제목, 제목, 표제가 title.
짧은 설명문, 페이지의 제목이 caption.

**subject / topic / theme**
주제, 의제, 큰 항목을 나타내는 것이 subject.
작은 화제를 나타내는 것이 topic. subject의 밑에 매달리는 감각.
특정 화제를 나타내는 것이 theme. subject 보다 감각적인 느낌.

**issue / problem**
문제, 논점, 쟁점, 토론해야 할 것을 issue.
어려움을 일으키는 문제로 해결이 필요한 것을 problem.

**common/shared**
소유자가 없는 다수가 유효한 공유가 common.
소유자가 나누어주는 의미에서의 공유가 shared.
공유지는 common, 공유 폴더는 shared 를 사용한다.

**individual / personal**
많은 사람들에 대한 개인이 individual. 개별.
인원수에 관계없이, 다른 누구도 아닌, 그 개인을 나타내는 것이 personal. 개인.
종업원 한 사람 한 사람을 나타내는 개인 등은 individual을 사용하면 된다.

**just / only**
무언가를 기준으로, 단지, 단지 지금을 나타내는 것이 just.
절대적인 의미로, 유일한, 단 하나의 물건을 만나는 것이 only.

**within / inside of / less than**
within은 시간, 거리, 범위를 의미합니다. 감각적인 느낌.
within 3 sec에서 3초 이내. in 3 sec 그리고 3 초 후.
inside of는 구체적인 장소를 나타냅니다.
less than 은 숫자 전반에서 사용할 수 있다. 미만. 이하라면 or less.

**validate / verify**
요청을 만족하는지, 올바른지 확인하는 것은 validate. 입력 체크 등에.
공정의 일부로 내장되어 검사 및 테스트 verify. 보다 제한적인 느낌.
CD/DVD 굽기 과정의 끝에는 verify가 있다.
일본어로 하면 둘 다 검증한다.

**permit/allow/accept/grant**
법률이나 공식, 면허로 허가하는 것이 permit. 위반하면 처벌이 있는 딱딱한 이미지.
사람이 무언가를 하는 것을 허락하는 것이 allow. 구어적인 느낌. 입장이 위에서 훌륭하다.
요구를 받아들이고 승인하는 것이 accept. 입장은 상관없다.
용서를 받는 것이 grant. 지급이나 부여되는 이미지.

**permission/privilege/authority**
permittion은 원칙적으로 금지되어 있지만 허가. 파일 액세스 권한의 속성.
privilege는 특별한 허가, 특권. 사용자 권한 속성.
authority는 그 행위를 할 수 있는 권한. 넓은 의미에서의 권한.

**memo / note**
업무로 기록하는 것은 memo.
메모 쓰기, 기록으로 남겨두는 것이 note.
영어와 일본어에서는 메모와 노트의 뉘앙스가 다르다.

**remark / note / comment 약간의**
비고나 주석의 경우는 remark.
일반적인 비고의 경우는 note. 주의를 준다.
코멘트한다, 의견을 말하는 것이 comment.

**notice / caution / warning**
소중한 것이 쓰여 있기 때문에 읽어 주었으면 하는 것이 notice.
주의나 경고는 caution.
절대로 해서는 안되는 것이 warning.
컴파일러에서 warning 은 흔히 있지만, 실제로는 강한 경고의 의미가 있다.

**table / figure**
table 은 데이터를 보기 쉽게 표로 한 것.
figure 는 데이터를 그림으로 한 것.
논문에서 자주 등장하는 표현.

**plot / graph**
plot 는 그래프에 써낸 것. 개념적 느낌.
graph 는 그래프나 도표, 도식 등. 수학적 느낌.

**chart / diagram**
chart 는 일을 알기 쉽게 도시한 것. 막대 그래프, 날씨 다이어그램.
diagram 은 흐름이나 관계성, 의도를 나타낸 것. 네트워크 다이어그램, 흐름도, 벤 다이어그램.
chart는 graph와 diagram도 포함한 일본어로 말하는 「그림」이라는 표현.
diagram도 광의에서는 「그림」이라고 할 수 있지만, 보다 개념적, 추상적인 느낌.

**save / register / apply / entry / enroll**
save 는 저장하는 의미로 등록한다. 반대어의 load와 쌍으로 사용하면 좋다.
register는 일반적인 의미에서 등록한다. 무엇이든 사용할 수 있습니다.
apply는 심사가 필요한 신청에 등록한다. 신청한다. 규칙을 따라 적용할 이미지.
entry는 입력합니다. 쓰지 않은 이미지.
enroll은 입회한다, 입학한다, 입대한다.

**supplement /complement**
보완하는, 부족한 것을 보충하는 것이 supplement.
2개의 것을 맞추어 보완하는 것이 complement.
complement 는 상호의 의미가 강하고, 상대가 필요.
「2의 보수」는 「Two's complement」가 된다.

**correct / right**
명확한 기준이 있고 올바른 경우는 correct.
도덕적으로 옳고 판단이나 의견이 옳다면 right.

**autocomplete/autocorrect/suggest**
입력 도중의 것을 보완해 주는 것이 autocomplete.
입력이 끝난 것을 올바르게 하는 것이 autocorrect.
입력을 바탕으로 무언가를 제안하는 것이 suggest.
일본어의 보완은 부족한 부분을 보충해 완전하게 하는 것.
보간은 수치 사이의 값을 계산하여 보완한다.

**need / require**
주관적으로 보고 필요한 것이 need.
객관적으로 봐 필요한 것이 require.
need는 구어.
require 쪽이 단단한 말로, 규칙으로 요구되는 경우에 사용한다.

**parallel / concurrency**
하나의 문제를 병렬화하고 신속하게 처리하는 것이 parallel. 물리적으로 동시에 실행되는 이미지.
복수의 수속을 병행해 실행하는 것이 concurrency. 교대로 진행해도 좋은 이미지.
비동기 프로그래밍을 나타내는 것은 concurrency가 옳다.

**acronym / bacronym / abbreviation**
이니셜을 연결하여 읽게 된 단어는 acronym. (ZIP, NaN)
머리글자나 각 단어의 문자를 무리하게 맞춘 말은 bacronym 또는 backronym. (GCC)
생략된 단어는 abbreviation. (Feb., Mon., Dr.)

**overlapping / overlapped**
둘 다 중복된 의미이지만, overlapping 쪽이 현재도 중복하고 있는 것을 강조할 수 있다.
overlapped라고 과거에 중복하고 있었지만, 이미 해결한 경우에서도 적용된다.

**amount / quantity**
추상적, 개념적인 양을 나타내는 것이 amount. 돈과 물 등.
물질적인 양을 나타내는 것이 quantity. 셀 수 있는 것.
실제의 수를 나타내는 것은 number.

**sex/gender**
생물학적 성별을 나타내는 것이 sex. >> [ISO/IEC 5218](https://en.wikipedia.org/wiki/ISO/IEC_5218)
사회적인 성별을 나타내는 것이 gender.

## 실수하기 쉬운 단어

**programming**
m은 2개 필요.
programing이라는 말도 있지만 소수파.

**license(us) /licence(uk)**
license 쪽이 다수파.
lisence와 lisense는 실수입니다.
라이센스를주는 무슨을 licenser.
라이센스를 받는 것을 licensee.

**canceled(us) / cancelled(uk)**
최근에는 canceled 가 자주 사용되게 되었다.
역사적으로는 cancelled 쪽이 낡다.
명사형은 cancellation 밖에 없다.

**collect / correct**
collect는 수집하고 수집합니다.
correct는 정확하다, 정정한다.

**cache / cash**
cache는 메모리와 같은 캐시입니다.
cash은 현금입니다.

**clash / crash / crush**
clash는 부딪치고 충돌합니다. 데미지는 적다.
crash은 명중한다. 큰 데미지가 있다.
crush는 부서진다, 부서진다. 부서지다.

알파벳순으로 늘어놓을 때, 망가지는 방법이 점점 커진다.
PC가 부서지는 (kowaReRu)는 crash이라고 기억한다.
과즙을 짜내는 (shiboRU)는 crush라고 기억한다.

하드웨어가 고장나고, 처리에 실패하는 경우는 crash 보다 fail 쪽이 보다 명확.

**option / choice / selection**
option 은 선택사항, 뭔가가 있어 거기에 수반되는 선택.
choice는 자유로운 선택, 주관적인 감각.
selection는 엄선한 선택, 최적 선택, 공식적인 느낌.

**margin / padding**
margin (은)는 여백, 란외, 마진등 상하 좌우의 인쇄되지 않는 영역을 나타내는, 즉 외측의 여백.
padding는 채우는, 덧붙인다, 포장을 의미한다, 즉 안 여백.
영어의 의미를 기억해 두면 안쪽인지 바깥인지 헤매지 않는다.

**register**
register로 등록합니다.
resist은 저항한다. shield s로 기억하는 것이 좋다.
regist 라고 약칭하는 것은 혼란의 원이므로 생략하지 않는다.
reg로 약칭하면 Windows의 registry를 가리키는 경우가 많다.

**raise**
raiseEvent 로 이벤트를 여기(기동)한다.
trigger는 데이터베이스에서 사용되므로 이벤트에 적합하지 않습니다.
run이나 do는 사용하지 않는다.

**disk / disc**
disk는 diskette의 약자로 케이스가 들어간 자기 디스크를 나타냅니다.
disc는 특히 디스크를 의미하고 벗겨지는 광학 디스크를 나타냅니다.

**directory / folder**
directory는 Linux 시스템에서 사용되는 디스크의 저장 위치를 ​​나타냅니다.
folder 는 Windows 계에서 사용되는, 계층 구조를 가리킨다. (directory 포함)
Windows 제어판 등은 디렉토리가 아니지만 폴더가 된다.

**index / indexes / indices**
발음은 인덱스 이즈 (indexes) 와 인디시즈 (indices).
indexes 는 책이나 데이터베이스에서 색인을 의미합니다.
indices 는 수학이나 통계로 지수나 지표를 의미하는 경우.
프로그래밍 배열의 첨자를 복수형으로 하는 경우는 indices 를 사용한다.

**act / action / behavior**
act 는 동사이지만 명사라면 행위.
단시간에 끝나는 하나만의 행위를 가리키는 경우가 많다.
또한 결과에 초점이 맞춰져 있고, 끝난 행위를 가리키는 경우가 많다.
action 은 순서가 필요한 일련의 행동.
집단에서 실시하는 경우에도 사용한다.
behavior는 action도 포함한 넓은 의미에서의 행동을 나타낸다.
behavior는 태도로 사용되는 것이 더 자주 발생합니다.

**crypto / crypt**
crypto는 암호입니다.
crypt로 멈추면 지하납골당.

**svr / srv**
server 를 줄이는 경우는 svr 를 사용하는 것이 일반적.
srv라면 service를 연상한다.
DNS의 SRV 레코드는 SERVICE 레코드의 약자.

**Reference Value**
참고값, 기준값.
판단의 기준에 사용하는 참고치.
의사는 정상치/이상치라는 말을 싫어하기 때문에 기준치를 사용한다.
객체나 메모리의 reference (참조)와는 관계없다.

**Regular Value**
기하학계에서는 정칙치.
regular (정칙)이란 규칙을 따르는 것.

**Standard Value**
일반이라는 의미로 표준값.
규격내라는 의미로 규격치와도.

**통상치 / 정상치 통상**
치는 평상치라고 바꾸는 편이 알기 쉽다.
평상치(Usual Value) 는, 평상시대로의 값. Usual은 빈도를 나타냅니다.
정상값(Normal Value)은 아무런 문제가 없는 범위의 값입니다.
정상값(Normal Value)보다 정상 범위(Normal Range)로 사용되는 경우가 많다.

**기본값/규정값**
기본값(default value)은 공장 출하 시 등의 초기 설정값입니다.
규정값(control value, minimal required value)은 제품의 규격을 정한 값입니다.

**정규화/정규화**
정규화(regularization)는 통계나 기계 학습에 있어서 파라미터에 벌칙을 가해 과학습을 막는 수법.
정규화(normalization)는 일정한 규칙에 따라 데이터를 이용하기 쉽게 한다.
데이터베이스 정규화와 벡터 정규화가 있습니다.

**행(ROW) / 열(COLUMN)**
행은 굵기(만들기)의 위가 옆에 평행이므로, 옆으로 늘어나는 이미지. EXCEL에서 행을 선택하면 가로 일렬이 선택된다.
열은 굵기(가로)가 세로에 평행이므로, 세로로 늘어나는 이미지. EXCEL로 열을 선택하면 세로 일렬이 선택된다.
수학의 좌표는 (x, y)로 표현되는 경우가 많지만, 프로그래밍의 표는 (row, column)으로 나타내는 경우가 많다.
CSV 파일 등을 루프로 처리할 때를 기준으로 생각하면 i행째의 j번째로 하는 것이 처리하기 쉽다.

**normalization/canonicalization**
둘 다 정규화를 나타냅니다.
normalization보다 조금 더 복잡한 정규화를 canonicalization이라고합니다.

**regression / degrade**
손 반환 (regression).
디그레는 열화(degrade)이지만, 리그레션의 의미로 일본제 영어가 되고 있다.

## 실수하기 쉬운 읽기

원래 카타카나로 표기하고 있기 때문에 올바르지 않다.
일본인의 영어 발음이 안되는 것은 로마자와 카타카나 때문이 아닌가.
알파벳을 읽는 방법 외에 알파벳의 발음도 가르쳐야 한다.
특히 r은 일본어에는 없는 발음이지만, 발음할 수 있으면 들을 수 있게 된다.

**data**
데이터, 다타.
데이터가 다수파.

**done**
댄.

**align**
정렬.

**horizontal / horizon**
호리존탈, 호라이즌.

**radius / relative / relation**
레이디어스, 관계, 관계.

**temporary**
템포렐리.
카타카나에서 임시라고 쓰므로 착각하기 쉽다.

**false**
force.
Farus와 읽고 phallus에서 남근의 의미.

**팁**
팁.
칩이라면 chip이 된다.

**null**
널.
널에서 일본제 영어화하고 있다.

**ping**
핀. 구는 들리지 않지만 ng로 발음하고 있다.
정중하게 말하면 g를 강조하여 구가 될 수도 있다.
핑으로 일본제 영어화하고 있다.

**JPEG / GIF / PNG / WebP**
**MPEG / WebM**
제이펙, 지프, 핑, 웨피. (스틸 이미지)
엠펙, 웹 엠. (동영상)

**repository / Git / TortoiseGit / Mercurial**
저장소, 깃, 토타 스기트, 머큐리얼. (버전 관리)
리포지토리라고 위화감이 있다.

**nginx**
engine x (엔진 엑스). (httpd)

**Xeon**
지온. (CPU)

**우분투**
|oǒ'boǒntoō|
우분투, 우분투, 우분투. (Linux)
줄루어의 발음을 들으면 우븐츠.

**그놈**
그놈. (Linux)
영어 읽으면 놈이지만, 그놈과 발음하는 것이 맞다.

**Kubernetes (K8s)**
쿠바네티스, 쿠베르네테스.

**awesome**
오삼.
아우삼이 아니므로 주의.
awe (경외) + some.

**schema**
스키마 또는 셰이머.
스키마는 종종 데이터베이스의 논리적 구조를 가리킨다.
셰이머는 독일어 읽기로 의료계에서 그림을 가리키는 경우가 많다.

## 빈번한 단어

**로그**
기록, 로그를 복용.
명사와 동사가 같다.

**emit**
로그를 파일로 출력합니다.

**flush**
쌓여 있는 데이터나 로그를 출력해 클리어 한다.
밀어 낸다, 모두 토해낸다.

**fetch**
네트워크에서 데이터를 검색합니다.
CPU가 메모리로부터 데이터를 취득하는 경우에도 사용한다.

**retrieve**
데이터를 찾아서 검색합니다.
검색의 의미에서도 사용된다.

**stack 스택**
, 스택.
명사와 동사가 같다.

**token**
토큰, 표시, 증거.
어휘 분석의 경우 분해할 수 없는 최소 단위입니다.
네트워크 등의 경우는 송신권을 교환하는 데이터.

**credential**
사용자 ID와 암호.

**optimize**
최적화합니다.

**normalize**
정규화한다.

**NDA / Non-Disclosure Agreement**
비밀 유지 계약
closure는 close에서 변경되어 마감일을 의미합니다.
disclosure 는 부정형이므로, 폐쇄의 반대로, 공개한다.
non-disclosure는 더 부정적이기 때문에 비밀로 만듭니다.

**cheat sheet**
호랑이 롤. 사용법을 1 페이지에 정리한 것.

**usage**
사용법, 사용법.

**unknown**
알 수없는, 정체 불명의.
`unknown error, something happened.`

**misc / miscellaneous**
잡다한, 다방면.

**TOC / table of contents**
목차.

**description**
설명.

**brief**
개요, 요약한다.

**recommend**
추천합니다.

**features**
특징, 기능.
대부분 복수형으로 사용된다.

**via**
~에 의해, ~을 통해.

**required**
필수.

**reserved**
예약되었습니다.

**verbose**
중복. 자세한.
`-v`로 로그 출력 옵션으로 정보를 늘리는 경우에 사용된다.
`-V`그렇다면 버전을 가리키는 경우가 많다.

**diversity**
다양성.

**Proof Of Concept**
프로토타입을 만들어 검증한다.

**ecosystem**
생태계.
생태계에서 전환하여 여러 기업 소프트웨어가 협력 연계하여 시장을 키우는 방법.

**omni-channel**
옴니 채널. 복수의 판매 형태를 가지는 것.
App Store뿐만 아니라 자체 다운로드 판매, 상점 USB 판매 등.

**full stack**
위에서 아래까지 전부.
full stack developer / engineer는 인프라에서 시스템 개발, 데이터베이스, 프런트 엔드까지 모두 할 수 있는 인재.
full stack framework는 필요한 모든 기능을 갖춘 프레임 워크입니다.

**DevOps**
개발(Development)과 운용(Operations)을 붙인 조어.
개발 팀과 운영 팀이 협력하여 지속적인 개발, 지속적인 배포를 신속하게 수행하는 방법.
팀의 대립구조를 해소하는 것을 목적으로 하고 있다.

## 관련 단어

### 데이터 호출 및 등록 정보

양식에 데이터를 호출하는 것을 `Load`.
양식에 데이터를 저장할 수 있습니다 `Save`.
파일이나 Stream에서 읽는 것을 `Read`.
파일이나 Stream에 쓰는 것을 `Write`.
서버에서 데이터를 검색합니다 `Fetch`.
서버에 데이터를 보내는 것을 `Send`.
데이터를 검색하는 것은 `Retrieve`.
데이터를 등록하는 것은 `Register`.
데이터베이스에서 SELECT를 실행합니다 `ExecuteQuery`.
데이터베이스에서 INSERT, UPDATE, DELETE 를 실행하는 것을 `ExecuteNoneQuery`.

다음은 예입니다.

검색 버튼으로 `Search`한다.
결과를 서버로부터 `Fetch`한다.
클라이언트는 서버로 `Request`한다.
서버는 데이타베이스에 `Retrieve`한다.
데이터베이스는 SELECT 문을 `ExecuteQuery`수행합니다.
서버는 클라이언트로 `Respond`한다.
검색 결과를 목록으로 `Add`표시합니다 `Refresh`.

목록에서 `Select`한다.
선택한 키에서 화면으로 데이터를 `Load`만듭니다.
결과를 서버로부터 `Fetch`한다.
클라이언트는 서버로 `Request`한다.
서버는 데이타베이스에 `Retrieve`한다.
데이터베이스는 SELECT 문을 `ExecuteQuery`수행합니다.
서버는 클라이언트로 `Respond`한다.
결과를 화면으로 `Set`한다.

필요한 경우 데이터를 다시 씁니다.
입력 체크 `Validate`로 하고 , `CanSave`로 저장할 수 있는지 확인하고 한다 `Save`.
또는 `TrySave`저장을 시도합니다.

데이터를 `Save`한다.
데이터를 화면에서 `Get`한다.
데이터를 서버로 `Send`설정합니다.
클라이언트는 서버로 `Request`한다.
서버는 데이타베이스에 `Register`한다.
데이터베이스는 INSERT, UPDATE, DELETE 문을 `ExecuteNoneQuery`한다.
서버는 클라이언트로 `Respond`한다.

필요하면 화면을 `Clear`한다.

### 식, 값, 변수 정보

**syntax / statement / expression / operator / signature**
syntax는 구문입니다. 구문은 statement와 expression으로 구성됩니다.
statement 는 문장. if 문, for 문, 함수 호출 문 등.
expression은 평가되는 표현식입니다.
operator는 연산자입니다.
signature 는 함수의 형태 정보이며, 메소드명, 파라미터, 반환값의 형태를 아울러 표현한 것.
프로그래밍 언어에 따라 정의가 다릅니다.

**prefix / suffix / affix**
접두사, 접미사, 접사.
disconnect의 dis-와 restart의 re-가 접두사.
player 의 -er 나 nullable 의 -able 가 접미사.
suffix 대신 postfix 에서도 의미는 통하지만 별로 사용되지 않는다.
affix 는 첨부하는, 첨부하는 의미가 있어, prefix 와 suffix 를 정리해 표현할 때에 사용한다.

**prefix notation/infix notation/postfix notation**
전치기법, 중치기법, 후치기법.
폴란드 표기법(+AB), 일반 수식(A+B), 역 폴란드 표기법(AB+).
컴퓨터에서 수식을 처리하는 경우는 스택을 이용한 역 폴란드 기법이 자주 사용된다.

**create / destroy**
인스턴스를 작성하는 인스턴스를 파기합니다.

**allocate/free**
메모리를 할당하고 메모리를 여십시오.

**inheritance/override/overload**
상속. 덮어쓰기. 다중 정의.

**delimiter/separator**
구분 기호.
delimiter 는 의미가 넓고, 쉼표 이외에도 쿼트나 괄호도 포함한다.
separator 는 쉼표 등 분할하는 것만을 말한다.

**type**
타입, 데이터 타입.
문맥에 따라서는 종류를 의미하므로 주의가 필요.
헝가리안 기법이 두 종류가 된 것은 문맥에 의한 의미의 틀림이 원인.

**dynamic / static**
dynamic (동적)은 필요에 따라 수시로 처리를 실시한다.
static(정적)은 사전에 필요한 처리를 해 두는 것.
dynamic library는 작동 중에 DLL을로드합니다.
static library 는 미리 LIB 를 링크해 컴파일 한다.
라우팅의 dynamic route는 자동으로 추가되며
static route는 미리 수동으로 설정해 둡니다.
static 변수는 언어에 의해 정의가 다르지만, 메모리상에 미리 영역을 확보해 둔다.

**increment/decrement**
증량, 체중 감소.
프로그램에서는 i++ 와 i-- 입니다.

**Initial Value / Initialized Value**
초기값, 초기화 값.
프로그램의 처음이나, constructor 으로 초기화되는 값.
또는 변수와 동시에 선언되는 값.
초기값은 가능한 한 넣는 편이 예기치 않은 트러블을 줄일 수 있다.

초기값을 영역하면 Initial Value, Default Value, Start Value 가 된다.
그러나 프로그래밍에서 초기값이라고 하면 변수 선언시의 초기화를 가리키는 경우가 많다.

**Default Value**
아무것도 설정하지 않았을 때의 값, 회전해 디폴트치.
공장 출하시 설정 등의 값.
초기치의 의미로 사용되는 일도 있지만, 엄밀하게는 다르다. >> [여기의 설명을 알기 쉬운](https://wa3.i-3-i.info/word1184.html)
인수를 생략했을 경우의 값, 그 경우는 Optional Value 와도.

default만이라면 게으름이나 무작위를 의미한다.
일본어로 데포라고 약칭하는 경우는, 보통 등이라는 의미로 사용된다.

**Start Value/Starting Value**
시작값, 초기값.
처리를 시작할 때의 초기값 등.

**Current Value**
현재 값.

**Original Value**
원래 값.
변경 전의 값.

**Parameter/Argument**
인수.
구별한다면 parameter 는 가인수, argument 는 실인수.

**Return Value/Returned Value**
반환값.
ret, retval로 약칭되는 경우가 많다.

**Result Value**
결과 값.
res, rslt로 약칭되는 경우가 많다.
res 라고 쓰면 response 라고 헤매기 때문에 생략하지 않는 편이 좋다.

**Var(Variable)**
변수.

**Const (Constant)**
상수.

**Literal**
리터럴. 직접 기술된 값.
변수와 반대의 의미.
`int x = 10;`
`String str = "abc";`
10을 숫자 리터럴, `"abc"`문자열 리터럴이라고합니다.

**Primitive Data Type**
프리미티브 유형. 기본형. 내장형.
프로그래밍 언어로 처음부터 준비되어 있는 변수의 형태.

```
bool, char, int, short, long, double, float, unsigned char,
Boolean, Int32, String, Decimal...
```

**declare/define**
변수와 함수를 정의한다.

**null/nil**
존재하지 않는 것. 널.
영어 읽으면 나루이지만, 많이 듣지 않는다.

**void**
하늘.
널과 비슷한 의미.

### 수치 표현

**digit**
자리.
아라비아 숫자를 나타내는 경우도 있다.

**binary number**
2진수.
선두에 `0b-`붙여 표현한다. `0b10`에서 2를 나타냅니다.

**octal number**
8 진수.
현재는 우선 사용되지 않는다.
메인프레임의 시대(1word = 24bit)에 자주 사용되고 있었다.
선두에 `0-`붙여 표현한다. `010`에서 8을 나타냅니다.

**decimal number**
10진수.

**hexadecimal number**
16 진수.
선두에 `0x-`붙여 표현한다. `0x10`에서 16을 나타냅니다.
0xFF, FFH, 0xFFH 등 표현 방법은 몇 가지 있다.
RGB 값으로 자주 볼 수 있습니다.

**even/odd**
짝수, 홀수.
명사 또는 형용사로 사용.

**integer part/fractional part**
정수부와 소수부.
integral part / decimal part 모두.

### 진위값

**true/false**
True, False.
트루, 포르스와 발음한다.
언어에 의한 차이도 크지만, 통상은 0 이외가 true, 0 이 false.

비교하는 경우는 `if (a == false)`등 `if (a == 0)`가짜 값과 비교하면 좋다.
참값의 바리에이션이 많고 가짜 값과 비교하면 실수가 적기 때문인가.

프로그램의 종료 상태(Exit Status, Return Code)는 0이 통상 종료, 그 이외가 에러 코드를 나타낸다.
다만, 리눅스의 파일 기술자, 파일 핸들에 한해, 취득에 실패하면(자) -1 이 된다.
따라서 비교할 경우 함수화해 두면 혼란이 적다.
`bool FileDescriptor::isOpened() { return (fd != -1); }`

**isXXX/canXXX/hasXXX**
상태를 결정하는 경우.
is-<형용사>, can-<동사>, has-<과거 분사>로 한다.
isSaved, isNull, isNumber, canSave, hasConnected 등.
isXXX는 동사로 시작하지만 예외적으로 진위 값을 나타내는 변수 이름으로도 자주 사용됩니다.

hasChanged 가 능동적(active)으로 바뀌었을 경우,isChanged 는 수동적(passive)으로 바뀐 경우라는 차이가 있다.

**exists**
파일 등이 물리적으로 존재하는가.
삼단현의 s를 붙인다.

**contains**
목록 등에 포함되어 있는가?
삼단현의 s를 붙인다.

**equals**
동등한?
삼단현의 s를 붙인다.

### 유형 정보

**float**
부동 소수점 수입니다.
floating point number에서.

**double**
배정밀도 부동 소수점 숫자.
double precision floating point number 로부터.

**문자열**
문자열입니다.
한계라는 의미.
character strings에서.

### 메모리

#### 램

**RAM(랜덤 액세스 읽기/쓰기 메모리)**

**stack-based memory**
스택 영역. 정적 메모리 영역도.
스코프를 빠지면 자동으로 개방된다.

**heap memory**
힙 영역. 동적 메모리 영역도.
heap 는 쌓아 올리는 것을 의미한다.
new나 malloc 했을 경우는 이쪽에 확보된다.
delete 와 free 를 잊어버려 메모리 누수를 일으키기 쉽다.
또한 단편화도 일어나기 쉽다.

#### ROM

**ROM (random access Read Only Memory)**
내장으로 기입을 행하는 메모리 영역.
BIOS 및 펌웨어가 기록되었습니다.
필요한 ROM의 용량은 program + const + data입니다.
필요한 RAM 용량은 data + bss로 계산할 수 있습니다.

※왜 일본에서는 Android 스마트폰의 내장 스토리지 용량이 ROM이라고 쓰여져 있는 경우가 있다.
확실히 Flash 메모리는 EEPROM이지만, ROM만 쓰면 의미가 다르다.

**VECT section (Vector)**
인터럽트 벡터 테이블이 기입해지는 영역.
모든 컴퓨터는 리셋 벡터로 시작됩니다.

**Program section**
프로그램이 저장되는 위치.
text 영역도.

**Const section**
상수가 저장되는 위치.
rodata (read only data) 영역도.

**Data section**
초기값 있는 전역 변수가 저장되는 위치.

**BSS section (Block Started by Symbol)**
초기치 없는 전역 변수가 저장되는 장소.

#### 메모리 용어 대비

**ROM (read only memory) - RWM (read write memory)**
**RAM (random access read/write memory) - SAM (sequential access read/write memory)**
일반적으로 RAM이라고 했을 경우는 RWM으로 분류되는 RAM을 가리켜 있다.
ROM은 ROM (Read Only Memory)의 random access Read Only Memory를 의미합니다.

### 단위

**b / bit** : 이진수
**B / Byte** : 1byte = 8bit
**KB / KiB** : 킬로 바이트(10^3) ​​/ kibi 바이트(2^10)
**MB / MiB** : 메가 바이트(10^6) / mebi 바이트(2 ^20 )
**GB / GiB** : 기가바이트(10^9) / 바이트 유사(2^30)

**MSB** : Most Significant Bit (최상위 비트)
**LSB** : Least Significant Bit (최하위 비트)
MSBit / MSByte 등과 bit 또는 Byte 를 명시하는 경우도 있다.

**bps** : bits per second (비트 초당)
**B/s** : bytes per second, 1B/s = 8bps

**sec** : second (초)
**ms** : millisecond (밀리초), 1sec = 1000msec
**us** : microsecond (마이크로초), 1msec = 1000us
**ns** : nanosecond (나노초), 1us = 1000ns

**Hz** : Hertz (주파수), 1MHz = 1us 주기 임베디드
주기 계산은 엄밀하게 2의 멱승(밟아)로 계산하지 않으면 엇갈린다.
1MHz = 1,048,576Hz = 2^20Hz

**dB** : decibel (데시벨)
**px** : pixel (픽셀 수), picture element
**bpp** : bits per pixel (색심도)

### 기호

`!`느낌표
`"`큰따옴표, 큰따옴표 해시
`#`, 숫자, 파운드
`$`달러
`%`퍼센트
`&`앰퍼샌드
`'`작은따옴표, 아포스트로피
`()`괄호, 괄호, 둥근 괄호
`-`하이픈, 빼기, 대시, 막대
`=`등
`^`캐럿, 모자, 위쪽 화살표
`~`물결표
`\`엔
`|`파이프, 세로 막대

`@`마크
\```백 따옴표
`[]`괄호, 대괄호
`{}`중괄호, 중괄호

`;`세미콜론
`+`과
`:`콜론
`*`별표, 별

`,`쉼표
`.`점, 마침표,
`<>`꺾쇠 괄호
`/`슬래시
`?`물음표
`\`백슬래시
`_`밑줄, 밑줄, 밑줄

### 그리스 문자

**A a** 알파 알파
**B b** 베타 베타
**Γ c** 감마 간마
**Δ d** 델타 바레타
**E e** 엡실론 입시론
**Z z z** zeta 제타
**H η** eta ータ
**Θ θ** ​​theta シータ
**I i** iota iotaΚ
**k** kappa 캄파
**Λ l** lambda ramdamM
**μ** mumu
**N n** nu 뉴Ξ
**ξ** xi クシー
**Ο o** 오미크론 오미크론
**Π π** 파이 παιΠ
**ρ** rho ΡέΟΣ
**σ** 시그마 시그마
**Τ τ** tau τY
**y** 업실론 우프시론
**Φ φ** 파이 파이
**X χ** 카이카이Ψ
**ψ**psi 푸사이
**오메가** 오메가

### 날짜 표현

**date_created** : 자주 사용되는
**created_date** : 이쪽도 자주 사용되는
**creation_date** : 많이 사용되지 않는
**created** : DateTime 형이면 좋지만, 이름만으로는 bool 라고 판별이 붙지 않는다

on 과 at 로 타임 스탬프를 나타내는 것은 rails 로 사용되고 있는 용법.
**created_on** : 작성일
**created_at** : 작성일시
**updated_at** : 갱신일시

**created_datetime** : DateTime 형, TimeStamp 형, `YYYY-MM-DD HH:mm:SS`
**created_date** : date 형,`YYYY-MM-DD`

유닉스 시간, 에포크 시간이라고 말해, 1970-01-01 로부터의 초수로 표현하는 방법도 있다.
int형으로 32bit라면 2038년 문제가 되므로 주의.

```
public static long ToUnixTime(this DateTime date)
{
    var epoch = new DateTime(1970, 1, 1, 0, 0, 0, DateTimeKind.Utc);
    return Convert.ToInt64((date.ToUniversalTime() - epoch).TotalSeconds);
}
```

좁은 스코프로, 일자를 캐릭터 라인으로 보관 유지하는 경우, 변수명으로 어떠한 형식인가 명시할 수 있다.

```
var yyyyMMdd = DateTime.Now.ToString("yyyyMMdd");
var HHmmssfff = DateTime.Now.ToString("HHmmssfff");
```

### 데이터베이스 관련

데이터베이스 관련 키워드는 모두 대문자로 기록해야합니다.
`SELECT t.name FROM table t;`

대문자 소문자를 구별하는/하지 않는 데이터베이스가 있으므로, 테이블명, 열명등은 모두 소문자로 쓴다.
반대로 모두 대문자로 쓰는 문화도 있지만, 키워드와 구별이 붙지 않기 때문에 읽기 어렵다.
데이타베이스에 따라서는 `Users`낙타 케이스로 쓸 수 있다.

테이블명은 복수형으로 하는 경우가 많다.
테이블이 행의 집합이므로 복수형으로 하는 것이 자연스러운 포착 방법이 된다.
클래스에 맵핑하는 경우는, 복수형이라면 배열이나 리스트와 같은 취급이 필요하게 되므로, 단수형으로 할 필요가 있다.

테이블명을 단수형으로 하는 문화도 있다.
테이블은 컨테이너이므로 단수형으로 해야 한다고 생각된다.
이 경우는 클래스명과 이콜이 되므로 기계적으로 작업이 쉬워진다.

테이블명에 `mst_, trn_, tbl_, m_, t_`등을 붙일 때는 일관성을 갖게 한다.
원래 중복이 되기 때문에 필요 없다.
예를 들면, 마스터로서 만들었지만 갱신이 자주 있으면, 그것은 더 이상 마스터가 아니기 때문에 되어 있으면 혼란의 아래 `mst_`.

`_`(언더스코어) 단락은 2개 정도까지가 딱 좋다.

외래 키의 필드는 모두로 `_id`끝나는 이름으로 한다.
열명에 `_id, _code, _type, _cd, _kbn, _sbt, _flg`등 붙일 때는 일관성을 갖게 한다.
`_kbn, _sbt`는 영어가 아닌 로마자 읽기이므로 사용하지 않는다.
반드시 붙인다, 생략하지 않는다, 혼재시키지 않는 등.
구체적으로 다음을 혼동해서는 안됩니다.

```
_cd : _code
_typ : _type
_kbn : _kubun
_sbt : _shubetu
_flg : _flag
```

`delete_flag`그렇다면 FALSE가 삭제되었는지 또는 TRUE가 삭제되었는지 알기 어렵습니다.
`delete_flag`아니거나 또는 `deleted`해야 `is_deleted`합니다.
`_flag`는 애매하고 중복이므로 사용하지 않는다.

`_id`는 기본 키나 고유하게 식별할 수 있는 번호에 붙인다. `int`또는 `bigint`바람직합니다.
다른 테이블과 관계하기 위한 id 열은 가능한 한 같은 이름으로 하는 것이 바람직하다.

`_code`는 의미 있는 기호나 번호, 코드 체계화되어 있는 것에 사용한다. `int`혼잡하면 혼란스럽기 때문에 `text`통일하고 싶다.

`_seq`는 순차적으로 사용한다.
`_number, _no`는 숫자에 사용한다.
`_num`는 특히 개수에 사용한다.

우편번호( `postal_code, post_code, zip_code`)는 일본어로는 번호이지만 실태는 코드가 된다.
고객 번호의 경우는 customer_number 라고 숫자이지만 customer_code 는 숫자 이외도 있을 수 있다.
다만, 업무에서의 호칭명으로~코드나~번호가 되고 있는 경우는 맞추는 것이 좋은 경우도 있다.

정렬을 하기 위한 열로 보다는 `sort_number`의미 `asc_order`가 명확하게 전해진다.

한계값을 포함하는 경우나 범위를 나타내는 경우에는 `min_`와를 `max_`이용한다.
범위를 나타내는 경우 `first_`는 와를 `last_`이용한다.
포함 배타적 범위를 나타내는 경우는 `begin_`(begin 포함)과 `end_`(end 포함하지 않는다)를 사용한다.
`begin_`이미`start_` 대체가 가능.

#### SQL

SQL은 Escuel 또는 Sequel로 읽습니다.
원본 데이터베이스 언어는 SEQUEL (Structured English Query Language)입니다.

an SQL (에스큐 엘)
a SQL (어시켈)

#### SQL 문 예

```
    SELECT t.name FROM table_name t WHERE t.id = '1';
    SELECT t.name FROM table_name t ORDER BY t.id DESC;
    SELECT COUNT(t.day) FROM table_name t WHERE t.year = '2015' GROUP BY t.month HAVING t.month LIKE 'J%';

    UPDATE table_name SET code = 'aaa' WHERE id = '1';
    INSERT INTO table_name (id, code) VALUES ('1', 'aaa');
    INSERT INTO table_name VALUES ('1', 'aaa');
    INSERT INTO table_name (id, code) SELECT t.id, t.code FROM table_name2 t;
    INSERT INTO table_name SELECT * FROM table_name2;
    DELETE FROM table_name WHERE id = '1';
```

#### 키워드

**TABLE** : 테이블, 테이블
**ROW** : 행, 행
**COLUMN** : 열, 열
**SELECT** : 선택, 선택
**UPDATE** : 업데이트, 업데이트
**INSERT** **:**
**인서트** , 삽입
**DELETE** : 델리트, 삭제 만들기 **DROP** **:** 드롭, 테이블 삭제하기 **INDEX** : 인덱스, 인덱스 **PRIMARY KEY** **:** 기본 키 **,** NOT NULL 제약







#### 자주 사용하는 단어

**연락처** 연락처
**full_name** 이름
**first_name** 이름
**middle_name** 중간 이름
**last_name** 이름
**honorific** 경칭
**nickname** 닉네임
**job_title** 직함 phone **전화**
**번호** **_** _ **_** _ 주소, e-mail 모두 **웹 웹 사이트** **,** 홈페이지, url을 사용해도 **좋다** **address1** 주소 1 **address2** 주소 2









**사용자** 사용자
**user_code** 사용자 코드 (로그인 이름)
**user_name** 사용자 이름 (표시 이름)
**password** 암호
**expiration_date** 만료일

**patient** 환자
**patient_code** 환자 코드
**patient_name** 환자 이름
**patient_name_katakana** 환자 이름 (가나)
**birth_date** 생년월일, 생일 (birthday)이 아니므로 주의
**sex_code** 성별, ISO 5218 및 DICOM 규격 참조
**job_role** 직업
**노트** 비고, remarks

**customer** 고객,
**비즈니스 파트너 employer** 고용주
**employee** 직원
**quantity** 수량
**order** 주문

order라는 테이블 이름을 사용하고 싶을 때는 조심한다.
ORDER BY 의 예약어이므로 `[order]`해야 한다.

### 계단

**title** 제목
**subtitle** 하위 제목

**caption** 짧은 설명, 주로 이미지 설명

**부품** 부품 장 **장**
**섹션** 하위
**섹션**
**항목**
**단락** 단락 문장 텍스트 **단어** 언어 _



### 배열과 목록 구조, 문자열 등

**지우기/추가/제거/추가/앞에 추가/삽입**
**트림/분할/비교/바꾸기**

[0]으로 시작하는 배열
zero-based (0부터 시작) or index origin = 0

[1]로 시작하는 배열
one-based (1로 시작)

### 네트워크 관련

**듣기 / 수락 / 보내기 / 받기**
**로컬 / 원격**

**핑핑**
. 영어라면 핀이지만 별로 듣지 않는다.

**TTL**
time to live.
패킷의 생존 기간(홉 수) 또는 DNS의 유효 기간(초).

### 이벤트

**Click / Clicking / Clicked / OnClick**
예를 들어 클릭 된 이벤트의 발생은 Clicked라고합니다.
시제를 나타내는 경우는, `-ing`또는 `-ed`로 한다.
클래스 내부의 이벤트는 OnClick 에 기술한다.

**call / invoke**
그냥 간단히 부르는 것을 call. 직접적인 느낌.
다른 스레드, 다른 컨텍스트의 처리를 불러내는 것을 invoke. 부탁하는 느낌.

**delegate/dispatch**
처리를 위양하는 것이 delegate. 대리에 맡기는 느낌. 응용 프로그램의 이벤트에서 사용됩니다.
태스크를 할당하는 것이 dispatch. 즉시 실행하는 느낌. 멀티 태스킹 OS가 프로세스를 실행할 때 사용됩니다.

### 도형

**point / x / y / offset**
좌표, X축, y축, 상대적인 위치.
화면의 왼쪽 상단이 (0, 0)입니다.
offset은 빼는 의미가 있습니다.

**size/width/height**
크기, 폭, 높이.
위즈(위도스)와 하이트와 발음한다.
발음은 여러가지 설이지만 사소한 차이이므로 허용할 수 있도록.
"옛날"을 의미하는 "한때"를 구어로 "카테"라고 발음하는 것.

**위 / 가운데 /**
**왼쪽 아래 / 가운데 / 오른쪽**

**전면 / 중앙 / 후면**
**전면 / 중앙 / 측면 / 후면**

**fill**
채우기.

**depth**
색 깊이.
32bit 컬러, 16bit 컬러 등.

## 생략한 단어

범위가 매우 좁은 범위에서만 약어, 약어는 사용하지 말라.
혼란스러운 생략은 하지 말라.

**i** : integer (정수) / i, j, k
**n** : natural number (자연수) / n, m

**b** : 부울, 바이트, 비트
**bln** : 부울
**byt** : 바이트
**c** : char
**ch** : char
**s** : 문자열
**str** : 문자열
**i** : 정수
**int** : 정수
**sht** : short
**l** : long
**lng** : long
**f** : float
**flt** : float
**sng** : 단일
**d** : 더블
**dbl** : 더블
**dec** : 십진수

**u** : 부호 없는
**uchar** : 부호 없는 문자

**o** : 개체
**obj** : 개체
**cls** : 클래스
**enm** : enum
**dte** : 날짜
**rng** : 범위

**prc** : 프로시저, 프로세스
**proc** : 프로시저, 프로세스
**sub** : 하위 프로시저
**f** : 함수
**fn** : 함수
**fnc** : 함수
**func** : 함수

**p** : pointer (포인터)
**ptr** : pointer
**g** : global
**t** : type
**e** : event
**e** : error
**err** : error
**ex** : exception
**iter** : iterator

**prop** : 속성
**attr** : 속성
**conf** : 구성
**pref** : 기본 설정

**args** : 인수
**params** : 매개변수

**stat** : 상태
**stat** : 통계 (netstat는 こっち)
**stats** : 상태
**stats** : 통계

**ln** : length (배열 길이)
**len** : length
**cnt** : count
**num** : number
**buf** : buffer (임시 문자 배열)
**mem** : memory

**app** : 애플리케이션
**문서** : 문서
**ext** : 확장자
**txt** : 텍스트
**tmp** : 임시

**conn** : 연결
**주소** : 주소

**dst** : 대상
**dest** : 대상
**src** : 소스

**cli** : 클라이언트
**svr** : 서버
**cl** : 클라이언트
**sv** : 서버

**srv** : 서비스
**svc** : 서비스

**h** : 핸들
**fh** : 파일 핸들
**fd** : 파일 디스크립터

**min** : minimum
**max** : maximum
**add** : add (더하기), addition (가산)
**sub** : subtract (빼기), subtraction (감산)
**div** : divide (나누기), division (나누기)
**multi** : multiply (곱하기), multiplication (곱하기)
**sum** : sum (합계, 합계)
**avg** : average (평균)

**qty** : quantity (개수)
**tot** : total (총계)
**ttl** : total

**EQ** : equal ( `=`, 같음)
**NE** : not equal ( `!=`, `<>`, 같지 않음)
**GT** : greater than ( `>`, 큰, 초과)
**GE** : greater equal ( `>=`, 이상)
**LT** : less than ( `<`, 보다 작음, 미만)
**LE** : less equal ( `<=`, 이하)
**TL** : total

**EQU** : 같음
**NEQ** : 같지 않음
**GTR :**
**GEQ** 보다 큼 : 큼 같음
**LSS :**
**LEQ** 보다 작음 : 덜 같음

**init** : 초기화
**exec** : 실행
**eval** :
**동기화** 평가 : 동기
**prev** : 이전
**curt** : 현재

**w** : 너비
**h** : 높이
**sz** : 크기
**pt** : 점
**pos** : 위치
**img** : 이미지
**fig** : 그림
**pct** : 그림
**bg** : 배경
**fg** : 전경
**mid** : 중간
**nav** : 탐색
**req** : 요청

**std** : 표준
**cfg** : 구성
**conf** : 구성

**sec** : seconds (secs가 아님)
**min** : minutes
**hrs** : hours
**ss** : seconds
**mm** : minutes
**hh** : hours
**dd** : days
**MM** : months
**yyyy** : years

**일** : 일요일
**월** : 월요일 화
**:** 화요일 수
**:** **수요일 목**
**:** 목요일 **금** : 금요일 토 : 토요일 **DOW** : 요일(曜日)



**1**
**월** : 1 **월 2월**
**:** 2 월 3 **월** : 3월 **4** **월** : 4월 **5월** : **5월 6월** : 6월 7월 : 7월 8월 : 8월 9월 : 9월 10 **월** **:** 10월 11월 : 11월 **12월** : 12월









**E** : Electromotive force (전압)
**I** : Intensity of electric current (전류)
**R** : Resistance (저항 ohm, Ω), E=RI

**f** : frequency
**A** : Ampere (암페어)
**V** : Volt (볼트)
**W** : Watt (와트)
**T** : temperature (온도)
**TEMP** : temperature (온도)

## MS 시스템 헝가리안에서 자주 사용되는 약어

**addr** : IPAddress
**ani** : 애니메이션
**bmp** : 비트맵
**btn** : 버튼
**bdn** : BindingNavigator
**bds** : BindingSource
**cal** : Calendar
**ckl** : CheckedListBox
**ctl** : Control
**ctr** : Control
**chk** : CheckBox
**chklst** : CheckBoxList
**clp** : Clipboard
**cbo** : ComboBox(発音重視)
**cmb** : ComboBox
**cmd** : 명령
**cdr** : MonthCalendar
**dlg** : 대화 상자
**doc** : 문서
**dtp** : DateTimePicker
**flp** : FlowLayoutPanel
**frm** : 형식
**gra** : 그래프
**grp** : GroupBox
**hsb** : HorizontalScrollbar
**icn** : 아이콘
**ico** : 아이콘
**il** : ImageList
**img** : 이미지
**imgbtn** : ImageButton
**lbl** : 라벨
**lin** : 라인
**llb** : LinkLabel
**lv** : ListView
**lvw** : ListView
**lst** : ListBox
**nud** : NumericUpDown
**mdi** : MDIChildForm
**mnu** : 메뉴
**mtx** : MaskedTextBox
**mtxt**: MaskedTextBox
**nti** : NotifyIcon
**opt** : OptionButton
**pic** : PictureBox
**pnl** : 패널
**prg** : ProgressBar
**prg** : PropertyGrid
**rdo** : RadioButton
**rpt** : 보고서
**rpv** : ReportViewer
**rtx** : RichTextBox
**rtxt** : RichTextBox
**shp** : 모양
**spl** : Splitter
**spl** : SplitContainer
**spt** : Splitter
**spn** : 스핀
**tgl** : ToggleButton
**tlp** : TableLayoutPanel
**팁** : 도구 설명
**trb** : TrackBar
**txt** : TextBox
**tmr** : 타이머
**tvw** : TreeView
**ud** : UpDown
**vsb** : VerticalScrollbar
**wbs** : WebBrowser

**tab** : TabControl
**tp** : TabPage
**페이지** : TabPage

**tabc** : TabControl
**탭** : TabPage
**tpg** : TabPage

**cms** : ContextMenuStrip
**mns** : MenuStrip
**ssr** : StatusStrip
**tsr** : ToolStrip
**tsc** : ToolStripContainer

**db** : 데이터베이스
**conn** : 연결
**ole** : OLEContainer
**sql** : SQLStatement
**qry** : 쿼리

**dg** : DataGrid
**dgv** : DataGridView
**ds** : DataSource
**ds** : DataSet
**dt** : DataTable
**dr** : DataRow

**grd** : DataGridView, DataGrid
**dgview** : DataGridView
**dts** : DataSet
**data** : DataSet
**tbl** : 테이블
**행** : 행
**행** : 행
**col** : 열
**cols** : 열 fld : 필드
**flds** :
**필드**

**id** : ID, 식별자
**cd** : 코드
**idx** : 인덱스
**mcr** : 매크로
**snp** : 스냅샷
**trn** : 트랜잭션

## 명사를 만드는 접미사

**-ance** : 인스턴스, 저항, 임피던스
**-ence** : 존재, 침묵
**-ency** : 의존성

**-ty** : 어려움
**-ity** : 능력, 현실
**-ion** : 파괴

**-ment** : 발달
**-ness** : 두께, 어두움
**-th** : 성장

**-or** : 선택기
**-er** : 플레이어
**-eer** : 엔지니어

**-나이** : 사용법

## 메타 구문 변수

샘플 프로그램 등에서 특히 의미가 없는 변수명에 사용된다.
누구도 아닌 것을 의미하는 기호.

**foo, bar, baz, ...**
foobar 와 함께 부르기도 한다.

**hoge, piyo, hogera, hogehoge, ...**
hoge 와 piyo 의 곱셈도 있다.

**unko, chinko**
부분에는 열광적인 지지자가 있다.

**spam, ham, eggs**
Python에서 자주 사용됩니다.

**Alice, Bob, Charlie, Dave, Eve, Ivan, ...**
프로토콜 및 암호 설명에 자주 사용 되는 사람 이름.
Alice는 본인이나 당사자.
Bob은 상대.
Charlie은 제 3 당사자.
Dave은 네 번째 당사자.
Eve는 도청자 (eavesdropper) 등.
Isaac는 공급자 (ISP)입니다.
Justin은 사법.

**야마다 타로, John Smith, Hans Schmidt, ...**
일반적인 이름입니다.

**무명의 권무위, 아무노 모, John Doe, Jane Doe, ...**
신원 불명의 이름입니다.

## 출시

**alpha release, alpha version**
α판. 개발 초기 및 시작 단계에 있는 소프트웨어.
동작이 불안정하거나 예기치 않은 트러블이 붙는 것.

**beta release, beta version**
β판. 평가판. 개발 도중에 있는 소프트웨어.

**CTP (Community Technology Preview)**
베타 버전과 동일. 다만, 대상을 한정하고 있다.
Microsoft가 자주 사용하는 표현.

**RC (Release Candidate)**
릴리스 후보 버전. 평가판. 베타 버전보다 더 제품에 접근한 상태.
판이 진행되면 RC1, RC2, ... 라고 늘어나간다.

**RTM (Release To Manufacturing)**
골든 마스터. 제품 출하 버전. 제조 라인에 올리는 최종 단계.

**GA (General Availability)**
정규판.

**stable/devel**
안정판, 개발판.
제품에 대한 명확한 기준이없는 OSS에서 자주 사용됩니다.
안정판은 테스트 등을 통해서 안심하고 사용할 수 있다.

**nightly build**
매일의 성과를 반영한 ​​최신 상태.
개발자가 최신 기능을 사용해보십시오.

**canary**
카나리아 릴리스.
일부 사용자에게 선행하는 릴리스(배포) 방법.
갱도에서의 가스 사고를 막는 카나리아가 유래.

**SaaS (Software as a Service)**
웹 응용 프로그램을 제공합니다. 그물을 통해서 온라인으로 소프트웨어를 실행할 수 있다.

**PaaS(Platform as a Service)**
웹 애플리케이션의 실행 기반을 제공한다.
GAE(Google App Engine), Microsoft Azule, AWS(Amazon Web Services) 등

## 속어 / 속어

[InternetSlang.com](http://internetslang.com/)

**XD** : (웃음)
**XXD** : (폭발)
**LOL (Laughing Out Loud)** : (폭발)
**ROFL (Rolling on the Floor Laughing)** : (핵폭탄)
**LMAO (Laughing My Ass Off)** : (짚), 왈라타, 빌어 먹을
**haha** : w
**hehe** : haha ​​보다 자랑스럽거나, 빛나거나
**ayy, ayy lmao** : w
**ayyyyyy** : www
**LOLOLOL** : www
**lolz** : 에라(조금 조소가 들어간다)

**hakspek, leet**
같은 발음의 숫자나 기호로 치환한 표현을 hakspek라고 한다.
보다 은어적인 표현을 하는 경우는 1337 을 사용한다.
1337 → l33t → leet

**k8s**
Numeronym(약어)이라는 약어.
k + 8자 + s로 kubernetes.
다른 유명한 것은 몇 가지이다.
sk8r: skater
l10n: localization
g11n: globalization
v12n: virtualization
p13n: personalization
c14n: canonicalization
i18n: internationalization
143: i love you

**2U, 4U**
to you, for you의 약자. 당신에게.

**thx**
Thanks의 약어. 감사합니다.

**pls, plz**
please의 약어. 부탁드립니다.

**NP**
No Problem의 약자. 문제 없어.
이해하기 어려우므로 우선 생략하지 않는다.

**GJ**
Good Job. 잘했다.
네트게 용어이므로, 네이티브는 생략하지 않는다.

**WIP (Work In Progress)**
미완성, 미해결.

**RTFM (Read The Fucking Manual)**
매뉴얼 읽기. 도움 정도 보라. >> [Qt의 Forum에서 자주 보는](https://forum.qt.io/search/RTFM?in=posts)
파생이 많이 있다. >> [Wikipedia의 RTFM 참조](https://en.wikipedia.org/wiki/RTFM)

**JFGI (Just Fucking Google It)**
구구레카스 (ggrks)의 의미.
구글로 검색하지 않고 듣는 사람에게 사용한다.
J를 가지고 FGI도.
이것도 파생이 많다.

**RIP (Requiescat in Pace / Rest in Peace)**
편안하게 잠들고 명복을 기원하는 의미.
무덤 같은데 Rip로 새겨진다.
RIP라고 써도 통한다.
사용되지 않는 코드를 지울 때의 코멘트 등에.

**cf. (confer)**
………를 참조. ………와 비교.
관련 항목으로 들으려면 see also를 사용한다.

**eg (exempli gratia)**
예를 들면 (for example).
일본에서는 ex라고 쓰일 수도 있지만 eg를 사용하는 것이 옳다.
또한 ex로 시작하는 단어가 많기 때문에 약어로는 적합하지 않습니다.

**ie (id est)**
즉, 즉, 이른바.

**aka (also known as)**
………로 알려진, 또의 이름을, 일명.
AKA라고도 쓰여진다.

**N/A (not available, not applicable)**
사용할 수 없음, 해당 없음.
NA라고도 쓰여진다.

**w/, w/o**
with 와 without .

**TL; DR (too long; didn't read) 너무 길기**
때문에 읽지 않았다. 너무 길다. 나가후미 우자이.
스스로 쓴 문장의 머리에 붙여 장문주의의 의미에서도 사용한다.
Qiita에서도 가끔 눈에 띄지만, 캡션에 붙여 요약을 나타내는 것도.

`;`(semicolon)
「그러니까」 「즉」 「그리고」에 해당하는 so나 ie나 and를 의미한다.
TL;DR에서는 너무 긴 "에서" 읽지 않았다.
마침표와 쉼표의 중간 정도.

`:`(colon)
좌측을 구체적으로 설명하는 경우에 사용한다.
이콜에 가깝다.

## 기법에 대해

### 카멜케이스, 인터캡

낙타 케이스.
캐릭터의 기복이 낙타의 코브처럼 보이기 때문에.
주로 오브젝트 지향 언어로 사용된다.

**PascalCase/UpperCamelCase**
시작을 대문자로 시작합니다.

**camelCase/lowerCamelCase**
시작 부분을 소문자로 시작합니다.

### snake_case

뱀 케이스.
C, Perl, SQL 등에서 사용된다.

**snake_case/SNAKE_CASE**
구분을 밑줄로 표현한다.
C 언어 등에서는 정수를 나타내는 경우는 모두 대문자로 쓰는 것이 관례.

### 체인 케이스

체인 케이스.
PowerShell 등에서 사용된다.

**chain-case/Chain-Case**
단락을 하이픈으로 표현한다.

### 헝가리안

고안자의 출신지에 따라 명명.
이름에 정보를 추가하고 쓰는 기법.

원래는 응용 프로그램 헝가리안으로 고안되었다.
본래는 의미를 나타내는 접두사를 붙여, 잘못된 코드를 발견하기 쉽게 하는 것.

```
    int rpX; // 相対座標 Relative Position
    int apY; // 絶対座標 Absolute Position
    var point = new Point(rpX, apY); // rpとapが使われているので間違いだと気づく
```

형식 정보를 부여하는 것이 시스템 헝가리안.
논문중의 type 를 종류가 아니고 형 정보로 오해해, 컴파일러의 형태 정보가 충분하지 않은 C 언어에 있어서 퍼졌다.

```
    bool bFlag; // 論理型
    char chChar; // 文字型
    char[] sString, szString; // 文字列型, ゼロ終端文字列型
    int iInteger; // 整数型
    int* pPointer; // ポインタ型
    int (*fnFunction)(void); // 関数ポインタ
    int hFileHandle; // ハンドル型
```

제대로 된 형식화 언어가 등장해, 사용되지 않게 되어 왔지만, 가끔 어딘가에서 사용되고 있다.
Android에서 Google 가이드라인에 올리기도 합니다.

```
    private int mMember { get; set; }
    public static int sStatic { get; set; }
```

## 액세서는 불필요한 흐름

액세서 (getter / setter) 란, Java 언어에 있어서, 숨겨진 필드에 액세스 하기 위한 getXXX / setXXX 라고 하는 메소드를 말합니다.
JavaBeans에서는 getter / setter를 강제하는 언어 사양이있었습니다.
액세서가 너무 중복이기 때문에 버렸다.

~~Java SE 7 로부터 property 를 사용할 수 있다.~~
Java SE 7 로 property 의 구문이 초안이 되어 있었지만 거부되었다.
`public property String name;`

C# 에서는 Java 의 액세서보다 세련된 프로퍼티라는 구조가 있다.
C#의 언어 버전이 진행됨에 따라 더욱 정교해졌다.
`public string Name { get; private set; } = 0;`

Ruby는 언어 사양으로 접근자 (attr_accessor)를 쉽게 정의 할 수 있습니다.
`attr_accessor :name, :price`

새롭게 등장한 언어인 Kotlin 이나 Swift 에서는 필드는 선언할 수 없고, 모두 프로퍼티가 된다.
`public var name : String`

### 캡슐화

오브젝트내의 행동이나 데이터를 은닉하는 캡슐화라고 하는 생각형이 있다.
다수의 액세서나 프로퍼티를 마련함으로써, 누구라도 자유롭게 데이터를 변경할 수 있다고 캡슐화의 원칙에 반해 버린다.
필요가 없는 정보는 공개하지 않도록 한다.

언어에 따라서는, 필드를 public 로 할 수 있으므로 프로퍼티 대신에 이용되는 일이 있지만, 좋지 않은 설계이다.
간결하게 쓸 수 있다고 해서, 필드를 public 로 해서는 안 된다. (최근의 Visual Studio에서는 경고가 나오게 된 것 같다)

### 데메텔의 법칙(LoD: Law of Demeter), 최소 지식의 원칙(PLK: Principle of least knowledge)

「모르는 녀석에게는 말을 걸지 않는다(Don't Talk to Strangers!)」라고도.
액세서나 프로퍼티로 다른 클래스를 참조할 수 있어 버리면, 불필요한 의존관계가 생겨 버린다.
직접 참조할 필요가 없는 클래스는 은닉해 두는 것이 좋다.

### 묻지 말고 명령하라 (TdA: Tell, don't ask.)

객체 지향에서 중요한 설계 지침 중 하나.
함수형 언어에서는, 데이터를 취득하고 나서, 어떠한 처리를 해 데이터를 되돌리는 순서를 취한다.
객체 지향에서는, 데이터를 가지는 클래스에 명령하는 것만으로 끝난다.
이 원칙을 지키면 데이터를 얻을 필요가 최소화됩니다.



## 번역 사이트

자주 사용하는 번역 사이트는 아래와 같습니다.

[에이지로(알크)](http://www.alc.co.jp/)
다수의 결과가 걸리므로 찾기 쉽다. (역자주: 일본어)

[Google 번역](https://translate.google.co.jp/?hl=ja)
URL을 전달하면 사이트를 통째로 번역도 가능.

[Google](https://www.google.co.jp/)
세세한 뉘앙스를 조사할 때는 ""XXX"번역"으로 검색한다.
비슷한 의미의 말로 헤매면 ""XXX" "YYY" 차이"등으로 한다.

[Dictionary.com](http://dictionary.reference.com/)
영어 어원도 알아볼 수 있다.

[Wiktionary(en)](https://en.wiktionary.org/)
의미, 유래, 용법, 관련어 등이 조사된다.

[GitHub](https://github.com/)
오픈 소스 코드를 검색할 수 있습니다.
그 단어가 어떠한 사용법을 하고 있는지 실례를 보고 싶을 때.