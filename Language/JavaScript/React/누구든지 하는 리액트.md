# 누구든지 하는 리액트



출처: https://velopert.com/3613

### 누구든지 하는 리액트: 초심자를 위한 리액트 핵심 강좌

이 튜토리얼은 리액트를 1도 모르는 사람들을 위해 작성되었습니다. 만약에 여러분이 리액트를 배우고 싶은데, 아직 뭐가 뭔지 잘 모르겠다! 그렇다면 이 튜토리얼을 진행하고 나면 리액트가 무엇인지, 왜 사용하는지, 그리고 어떻게 사용하는지를 알아 갈 수 있을것입니다.



> 이 튜토리얼은 [인프런](https://www.inflearn.com/course/react-velopert/)에 영상 버전으로도 올라와있습니다. 영상으로 학습하시는것이 편하신분은 인프런에서 수강해주세요~



## 목차

### 1편 [리액트는 무엇인가](https://velopert.com/3612)

프론트엔드 라이브러리는 뭐고, 리액트는 뭔지, 어쩌다가 만들어졌고 왜 사용해야 하는지에 대해서 다뤄봅니다.

### 2편 [리액트 프로젝트 시작하기](https://velopert.com/3621)

리액트 프로젝트를 진행하는데 필요한 작업환경을 여러분들의 컴퓨터에 설치합니다.

### 3편 [JSX](https://velopert.com/3626)

리액트에서 컴포넌트를 작성할 때 사용하는 JSX 라는 문법에 대해서 알아봅니다.

### 4편 [props 와 state](https://velopert.com/3629)

리액트에서 데이터를 다룰 때, 부모가 전달해주고, 고정적인 props, 그리고 컴포넌트 자신이 갖고있고 유동적인 state 에 대해서 알아봅니다.

### 5편 [LifeCycle API](https://velopert.com/3631)

리액트 컴포넌트가 페이지에 나타나고, 업데이트되고, 사라지는 과정에서 호출되는 라이프사이클 API 에 대하여 알아봅니다.

### 6편 [input 상태 관리하기](https://velopert.com/3634)

리액트에서 폼상태를 다루는 방법에 대해서 다뤄봅니다.

### 7편 [배열 다루기 (1) 생성과 렌더링](https://velopert.com/3636)

배열에 새로운 데이터를 집어넣고, 그 배열을 렌더링하는 방법에 대해서 알아봅니다.

### 8편 [배열 다루기 (2) 제거와 수정](https://velopert.com/3638)

배열에 추가한데이터를 제거하고 수정하는 방법에 대해서 알아봅니다.

### 9편 [불변성을 지키는 이유와 업데이트 최적화](https://velopert.com/3640)

상태를 업데이트 할 때 왜 불변성을 지켜야 하는지, 그리고 또 컴포넌트 업데이트를 어떻게 최적화하는지에 대해서 알아봅니다.

### 10편 [앞으로의 공부방향](https://velopert.com/3642)

튜토리얼을 마치며, 앞으로 무엇을 더 공부해야 하는지에 대해서 알아봅니다.



## <span style="color:green">1편: 리액트는 무엇인가</span>

### 프론트엔드 라이브러리 / 프레임워크

리액트는 정말 인기있는 프론트엔드 라이브러리입니다. 그런데 일단, 리액트에 대해서 알아보기전에, 이 프론트엔드 라이브러리란게 정확히 뭔지, 그리고 왜 필요한건지에 대해서 알아봅시다.

일단, 여러분이 웹사이트를 만들기 위해선, 사실 프론트엔드 라이브러리의 도움 없이도 만들어낼 수 있습니다. 그리고 단순히 정적 페이지를 만드는거라면 자바스크립트 없이도, 그냥 HTML 과 CSS 를 사용해서 만들면 되죠.

거기에 자바스크립트를 더해주면, 유저의 행동흐름에 따라서 동적으로 화면을 보여줄 수 있게 되겠죠.

그런데 요즘의 웹은요, 단순히 웹 **페이지** 가 아니라, 웹 **애플리케이션**이에요. 브라우저 상으로도 정말 자연스러운 흐름으로 매우 많은것들을 할 수가 있죠. 자, 그런데 어떠한 유저인터페이스를 동적으로 나타내기위해서는 정말 수많은 상태를 관리해줘야합니다.

예를 들어서 다음과 같은 HTML 코드가 있다고 가정해봅시다.

```html
  <div>
    <h1>Counter</h1>
    <h2 id="number">0</h2>
    <button id="increase">+</button>
  </div>
```

우리가, 버튼을 눌러서 저 숫자 0 값을 바꿔주려면 각 DOM 엘리먼트에 대한 레퍼런스를 찾고, 해당 DOM 에 접근하여 원하는 작업을 해줘야하죠.

```javascript
var number = 0;
var elNumber = document.getElementById('number');
var btnIncrease = document.getElementById('increase');

btnIncrease.onclick = function() {
  number++;
  elNumber.innerText = number;
}
```

만약에 jQuery 를 사용하게 된다면, `document.getElementById` 대신에 `$('#number')` 이런식으로 사용해서 DOM 을 가져오게 되겠죠.

여러분의 프로젝트가 사용자와의 인터랙션이 별로 없다면, 사실상 프론트엔드 라이브러리는 필요하지 않습니다. 그냥 직접 구현하는 것도 나쁘지 않아요. 하지만! 프로젝트가 규모가 커지고, 정말 다양한 유저 인터페이스와 인터랙션을 제공하게 된다면, 그 많은 DOM 요소들을 직접 관리하고 코드 정리하는건 진짜 진짜 갈수록 힘든 일 일것입니다.

물론, 제대로된 컨벤션을 가지고, 여러 규칙을 세워서 진행을 한다면 불가능한 일은 아닙니다만, 여전히 번거로운 것은 사실입니다.

웹 개발을 하게 될 때, 귀찮은 DOM 관리와 상태값 업데이트 관리를 최소화하고, 오직 기능 개발, 그리고 사용자 인터페이스를 구현하는 것에 집중 할 수 있도록 하기위해서 정말 여러 라이브러리들 혹은 프레임워크들이 만들어졌습니다.

대표적으로 Angular, Ember, Backbone, Vue, React 등이 있죠.

#### 라이브러리 / 프레임워크의 선택

2017년 기준으로 이 프론트엔드 동네에서 3 대장으로는 React, Angular, Vue 가 있습니다. 무엇을 선택해야 할까요? 결국 이 세 라이브러리는, 똑같은 문제를 다른 방식으로 해결 할 뿐입니다. 이 중에서 하나를 고르라고 하는건, 정말 답이 없는 문제입니다. 이런 말 들어보셨죠? “장인은 도구를 탓하지 않는다.” 훌륭한 개발자, 훌륭한 팀이라면 이 셋중에서 뭘 선택하던지 훌륭한 프로젝트를 만들어 낼 수 있을 것 입니다.

이 셋 중에서 가장 좋은 도구를 고르는것은, 불가능한 것이지만, 여러분이 가장 좋아하는 도구를 고르는것은, 가능합니다. 되도록이면, 각 라이브러리/프레임워크를 기초수준이더라 하더라도, 한번쯤 사용해보세요. 각 도구들의 철학과 추구하고자 하는 방향이 서로 다르다는 것을 알게 될 것입니다. 그리고 나서, 맘에드는걸 사용하시면 됩니다.

제가 느낀 각 도구들에 대한 생각과 특징을 요약해보자면 다음과 같습니다.

##### Angular

UI 를 구현하게 되면서, 앵귤러만의 문법같은 것들이 다양하게 존재합니다. 특정 기능을 구현 할 때, 편리하게 대신 해주는 것들이 많습니다. 라우터, HTTP 클라이언트 등 웹 프로젝트에서 필요한 대부분의 도구들이 프레임워크 안에 내장되어 있습니다. 앵귤러1의 경우 만들어진지 꽤 오래 됐고, 기업에서 많이 사용이 돼서, 유지보수하고 있는 프로젝트가 많아서 사용률이 높은 편입니다. 앵귤러2의 경우 매우 성숙하긴 하지만, 인지도 측면에선 아직 성장하는 단계이며, 주로 타입스크립트랑 함께 사용됩니다.

##### React

“컴포넌트” 라는 개념에 집중이 되어있는 라이브러리입니다. 컴포넌트는 우리가 추후 더 자세히 배워보겠지만, 미리 간단히 설명하자면, 데이터를 넣으면 우리가 지정한 유저 인터페이스를 조립해서 보여줍니다. 페이스북 개발자들이 라이브러리의 성능과 개발자 경험을 개선하기 위해 많은 연구를 합니다. 리액트를 한번 해본 개발자들은 대부분 맘에 들어합니다. 생태계가 엄청 넓고, 사용하는 곳도 많습니다. HTTP 클라이언트, 라우터, 심화적 상태 관리 등의 기능들은 내장되어있지 않습니다. 따로 공식 라이브러리가 있는 것도 아니여서, 개발자가 원하는 스택을 맘대로 골라서 사용 할 수 있습니다 (혹은 직접 라이브러리를 만들어서 쓸 수도 있겠죠.)

##### Vue

입문자가 사용하기에, 정말 쉽습니다. 대부분 Webpack 같은 모듈 번들러를 사용하여 프로젝트를 구성해야하는 앵귤러와 리액트와 달리, 단순히 CDN 에 있는 파일을 로딩 하는 형태로 스크립트를 불러와서 사용하기도 편합니다. HTML 을 템플릿처럼 그대로 사용 할 수도 있어서 마크업을 만들어주는 디자이너/퍼블리셔가 있는 경우 작업 흐름이 매우 매끄럽습니다. 공식 라우터, 상태관리 라이브러리가 존재합니다.

### 소개

리액트의 매뉴얼을 보면 다음과 같은 내용이 있습니다.

> We built React to solve one problem: building large applications with data that changes over time.
> 번역: 우리는 지속해서 데이터가 변화하는 대규모 애플리케이션을 구축하기 위해 React를 만들었습니다

리액트를 사용하는게 여기서 유일한 해답이냐? 그건 아닙니다. 그저 여러가지 솔루션 중 하나인 것 이죠.

#### 페이스북은 왜 리액트를 만들게 됐을까?

페이스북이 리액트를 만들기 전에도, 이미 Angular, Backbone, Knockout.js, Ember 등의 수많은 프레임워크들이 존재했습니다. 그리고 해당 프레임워크들은 데이터단을 담당하는 모델(Model), 사용자의 화면에서 보여지게 되는 뷰(View), 그리고 사용자가 발생시키는 이벤트를 처리해주는 컨트롤러 (Controller) 로 이뤄진 MVC 패턴, 그리고 MVC 에서부터 파생된 MVVM(View Model), MVW(Whatever) 등의 패턴들로 이뤄져있죠.

여기서 공통점은 바로 모델입니다. 방금 언급했던 프레임워크들의 모델은, 대부분 어떻게 작동하냐면, 양방향 바인딩을 통하여 모델에 있는 값이 변하면, 뷰에서도 이를 변화시켜줍니다. 여기서 핵심적인 부분은 **변화시켜준다는** 부분입니다. 일단 첫 화면을 보여주고, 변화에 따라 필요한곳을 바꿔주는거죠.

**”변화(Mutation)”**라는것은 상당히 복잡한 작업입니다. 특정 이벤트가 발생했을때, 모델에 변화를 일으키고, 변화를 일으킴에 따라 어떤 DOM 을 가져와서 어떠한 방식으로 뷰를 업데이트 해줄 지 로직을 정해줘야 하는데요, 페이스북에서는 리액트를 만들기전에 이러한 발상을 했습니다:

> 그냥 Mutation 을 하지 말자. 그 대신에, 데이터가 바뀌면 그냥 뷰를 날려버리고 새로 만들어버리면 어떨까?

![img](https://i.imgur.com/WvPL4oJ.gif)

그렇게 하면 진짜 간단하겠죠? 그런데 브라우저가 무슨 게임 엔진도 아니고, DOM 기반으로 작동하는 이 페이지는 그때 그때 새로 뷰를 만들어버리라고 하면 성능적으로 엄청난 문제가 있을 것입니다.

그래서 사용하는게 바로, Virtual DOM 입니다.

Virtual DOM 은 가상의 DOM 입니다. 변화가 일어나면, 실제로 브라우저의 DOM 에 새로운걸 넣는것이 아니라, 자바스크립트로 이뤄진 가상 DOM 에 한번 렌더링을 하고, 기존의 DOM 과 비교를 한 다음에 정말 변화가 필요한 곳에만 업데이트를 해주는 것이죠.

이 Virtual DOM 을 사용함으로서, 데이터가 바뀌었을 때 더 이상 어떻게 업데이트 할 지를 고려하는게 아니라, 그냥 일단 바뀐 데이터로 일단 그려놓고 비교를 한다음에, 바뀐 부분만 찾아서 바꿔주는거죠.

다음 동영상을 보시면 이해하기가 쉽습니다.

- React and the Virtual DOM (https://www.youtube.com/watch?v=muc2ZF0QIO4)

Virtual DOM 은 DOM 변화를 최소화 시켜주는 역할을 하는데요, 이 횟수를 최소화 시키는것은 성능적으로 매우 중요한 이슈입니다. 자세한 내용은 [리액트에 대해서 그 누구도 제대로 설명하기 어려운 것 – 왜 Virtual DOM 인가?](https://velopert.com/3236) 포스트에서 확인해보세요.

### React 만 Virtual DOM 쓰나?

리액트는 Virtual DOM 을 성공적으로 사용한 선발주자입니다. 이 아이디어를 다른 많은 라이브러리에서도 택했습니다. Virtual DOM 을 사용하는 라이브러리는 꽤 많습니다.

- [Vue](https://kr.vuejs.org/v2/guide/comparison.html)
- [Marko](https://markojs.com/docs/why-is-marko-fast/)
- [Maquette](https://maquettejs.org/)
- [Mithril](https://mithril.js.org/vnodes.html)

### 리액트를 특별하게 만드는 점은?

그렇다면, 무엇이 리액트를 특별하게 만들까요? 이 부분은 여러가지 사항이 있겠지만, 제가 생각하는 주요 포인트는 다음 3가지입니다.

#### 엄청난 생태계

리액트 생태계에서의 개발자들의 열정은 마치 2006년쯤 jQuery 가 나왔을 떄와 비슷합니다. 매우 뜨겁죠. 그 시절에는 웹 개발에서는 jQuery 를 사용하는게 너무나 당연했었죠. 그리고 이를 사용하는 수많은 플러그인이 나왔었습니다.

이것과 비슷하게, 리액트 라이브러리도 정말 많이 만들어집니다. jQuery, 혹은 일반 자바스크립트로 만들어진 라이브러리들도 리액트로 포팅되서 많이 작성되고있습니다. 뿐만 아니라, 그냥 단순히 특정 기능을 구현하기 위한 라이브러리 (예: 폼, 캐로절, 애니메이션, UI) 가 아니라, 프로젝트의 구조와 강하게 묶여있는 라우터, 상태 관리 라이브러리들도 매우 다양하죠.

#### 사용하는곳이 많다

리액트를 사용하는 서비스는 [여기](https://github.com/facebook/react/wiki/Sites-Using-React)에서 확인해볼 수 있습니다.

유명한 회사에서도 많이 사용되고 있죠 – Airbnb, BBC, Cloudflare, Codecademy, Coursera, Dailymotion, eBay, Twitch, Walmart, Yahoo…. 정말 수많은 곳에서 사용되고 있습니다.

하지만, 리액트의 사용률이 가장 높다고는 할 수 없습니다. 왜냐하면, 기존에 만들어진 프로젝트들중에서 이미 jQuery, Angular, Ember 등으로 만들어진 프로젝트들이 꽤 있기 때문이죠.

때문에, 새로 만들어지는 프로젝트, 혹은 리뉴얼되는 프로젝트에서 정말 많이 사용됩니다.

한국에도 이 리액트 부흥이 일어났습니다. 2015년만해도, [로켓펀치](https://i.imgur.com/cdx8vK8.png) 에서 리액트를 검색했을 때 나타나는 채용 정보가 10개 내외였는데, 이제는 무려 180개가 넘습니다.

#### 한번 사용해보면, 좋아하게 된다!

이것은 단순히 제 입장이 아니라, 통계적으로 그렇습니다.

![img](https://i.imgur.com/z1GYYpi.png)


한번 사용해본 사람들 리액트를 사용해본 14689 명에게 설문 조사를 했을 때 1020명을 제외한 나머지는 리액트를 다시 사용 할 의향이 있다고 합니다 (약 93%)

그리고 2017년에 가장 사랑을 많이 받은 라이브러리이기도 합니다.

![img](https://i.imgur.com/TXcw2Th.png)


### 리액트를 사용하게 됨으로써 앞으로 겪게 될 일들

리액트는 정말 자유도가 높은 라이브러리입니다. 예를들어서 라우터, 혹은 상태관리 같은 기능들이 리액트 자체에 내장되어있지도 않거니와, 공식적인 라이브러리도 없습니다. 하지만 써드파티 라이브러리가 존재하죠.

라우터쪽을 보자면, React-router, 그리고 Next.js, After.js 같은 라이브러리들이 있죠.

상태 관리 라이브러리만해도, Redux, MobX, fr(e)actal 같은 라이브러리들이 있습니다.

그리고 리액트 컴포넌트 스타일링을 할 때도 한가지 정해진 방식이 있는게 아니라 수많은 방식으로 할 수 있습니다.

이에 따른 장점은, 여러분들이 가장 맘에드는것을 사용하거나 심지어 직접 만들어서 사용 할 수도 있다는 점이고, 단점은 여러가지를 시도해볼 필요가 있고 선택장애(?) 가 일어날 수 있다는 점 입니다.

저는 이는 엄청 좋은 것이라고 합니다. 그리고 리액트 생태계 자체에도 정말 좋은 방식이라고 생각합니다. 리액트 라이브러리는 뷰 쪽만 관리하게 하고, 나머지 기능은 써드 파티 라이브러리가 담당하게 함으로서, 리액트는 리액트 라이브러리로서 더욱 성숙해질 수가 있는것이고 (페이스북 개발팀이 리액트 자체적인 기능에 더욱 많은 연구를 쏟을 수 있겠죠), 나머지 라이브러리들에서는 종류가 많다보니, 많은 개발자가 정말 다양한 시도를 하게 될 것이고, 덕분에 계속해서 성장합니다.

#### 끝없는 공부

생태계가 계속해서 발전해나가기에 우리는 끊임없이 공부를 해야합니다. 근데 이건 사실상 뭘 배우던 마찬가지입니다 🙂 어느정도 숙달을 해놓고 나면, 계속해서 최신 동향을 따라가지 않더라도 큰 문제는 없겠지만, 더 좋은 것들을 누리지 못한다는 생각이 들게 되기 마련입니다. 그런 생각을 하면 공부를 하지 않을 수가 없죠.

### 앞으로 어떻게 공부할까?

구글링을 해가면서 자신을 학습해가시면 됩니다. 하지만, 정말 수많은 자료가 나올 것이고, 한국 자료는 (아직까지는) 그렇게 아주 많지는 않습니다. 제가 이번 튜토리얼 시리즈에서, 필요한 부분만 콕콕 찝어서 재밌고 쉽게 배울 수 있도록 가이드를 해드리겠습니다 😉 앞으로 이어지는 포스트를 쭉 읽어보세요.

### Reference

- [Introduction to React.js](https://www.youtube.com/watch?v=XxVg_s8xAms)





## <span style="color:green"> 2편: 리액트 프로젝트 시작하기</span>

리액트 프로젝트는 보통 우리가 옛날에 jQuery 같은것을 단순히 `<script src="..."><script>` 의 형태로 불러와서 사용했던 것 처럼 사용하지는 않습니다. 그렇게 하려면 할 수 는 있는데 굉장히 제한적입니다. 그 대신에, 리액트 프로젝트를 제대로 작업 하려면 여러분의 컴퓨터에 Node, yarn, Webpack, Babel 등의 도구를 설치하여 프로젝트를 설정해주어야 합니다.

리액트 프로젝트를 바닥부터 설정하는 것은 초심자에겐 꽤나 복잡한 작업입니다. 다행히도, 페이스북에서 제공해주는 도구[create-react-app](https://github.com/facebook/create-react-app)를 통하여 이 작업을 간단하게 준비해줄 수 있답니다.

## Webpack, Babel 은 무슨 용도인가요?

리액트 프로젝트를 만들게 되면서, **컴포넌트** 를 여러가지 파일로 분리해서 저장 할 것이고, 또 이 컴포넌트는 일반 자바스크립트가 아닌 **JSX** 라는 문법으로 작성하게 됩니다. 여러가지의 파일을 한개로 결합하기 위해서 우리는 Webpack 이라는 도구를 사용하고, JSX 를 비롯한 새로운 자바스크립트 문법들을 사용하기 위해서 우리는 Babel 이라는 도구를 사용합니다.

> 아직까진 컴포넌트와 JSX~ 라는 개념이 익숙하지 않을 것입니다. 조만간 배우게 될 테니까 걱정하지마세요!

## 준비사항

앞으로 계속해서 튜토리얼을 진행하기 전에, 다음 항목들을 설치해주어야 합니다.

1. **Node.js**: Webpack 과 Babel 같은 도구들이 자바스크립트 런타임인 Node.js 를 기반으로 만들어져있습니다. 그렇기에 해당 도구들을 사용하기 위해서 Node.js 를 설치합니다.
2. **Yarn**: Yarn 은 조금 개선된 버전의 npm 이라고 생각하시면 됩니다. npm 은 Node.js 를 설치하게 될 때 같이 딸려오는 패키지 매니저 도구입니다. 프로젝트에서 사용되는 라이브러리를 설치하고 해당 라이브러리들의 버전 관리를 하게 될 때 사용하죠. 우리가 Yarn 을 사용하는 이유는, [더 나은 속도, 더 나은 캐싱 시스템](https://www.keycdn.com/blog/npm-vs-yarn/)을 사용하기 위함입니다.
3. **코드 에디터**: 그리고, 코드 에디터를 준비하세요. 여러분이 좋아하는 에디터가 있다면, 따로 새로 설치하지 않고 기존에 사용하시던걸 사용하셔도 됩니다. 저는 주로 VSCode 를 사용합니다. 이 외에도, Atom, WebStorm, Sublime 같은 훌륭한 선택지가 있습니다.
4. 윈도우의 경우, [Git for Windows](https://gitforwindows.org/) 를 설치해서 앞으로 터미널에 무엇을 입력하라는 내용이 있으면 함께 설치되는 Git Bash 를 사용하세요.

### Node.js 설치하기

Node.js 를 현재 기준 LTS 버전인 v8 버전을 설치하세요. 윈도우의 경우에 [노드 공식 홈페이지 다운로드 페이지](https://nodejs.org/ko/download/) 에서 설치를 하면 됩니다.

그리고, macOS, Linux 의 경우 다음과 같이 [nvm](https://github.com/creationix/nvm) 을 통해서 설치하는것을 추천드립니다. nvm 은 여러 종류의 Node.js 버전을 설치 할 수 있게 해주는 버전입니다. 나중에 새 버전이 나왔을 때 업데이트 하기도 쉽고, 터미널을 통해 어떤 버전을 사용 할지 설정 할 수도 있어서 편리합니다.

```
curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.8/install.sh | bash
nvm install --lts
```

### Yarn 설치하기

Yarn 설치는 [Yarn Installation](https://yarnpkg.com/en/docs/install) 페이지에서 여러분의 운영체제에 맞는 방식에 따라 설치하시면 됩니다.

### VSCode 설치하기

여러분이 이미 익숙한 에디터가 있으시다면 무조건 VSCode 를 사용하라고 권하지는 않겠습니다. 하지만, 사용해본적이 없다면 한번쯤 사용해보시길 바랍니다. 꽤 가볍고 편하고 예쁜 에디터입니다.

다운로드는 [Visual Studio Code](https://code.visualstudio.com/) 에서 하실 수 있습니다.

## [create-react-app](https://github.com/facebook/create-react-app) 설치 및 사용

### 설치

create-react-app 은 이름이 뜻하듯이, 리액트 앱을 만들어주는 도구입니다. 다음 명령어를 입력하여 설치 할 수 있습니다.

```bash
npm install -g create-react-app
```

만약에 yarn 을 통하여 설치하고 싶다면 다음과 같이 입력하시면 됩니다.

```bash
yarn global add create-react-app
```

윈도우라면 상관 없지만, 만약에 여러분이 리눅스, 혹은 macOS 유저여서 nvm 을 통하여 Node.js 를 설치했다면 yarn global 설치가 제대로 작동하기 위해선 다음 커맨드를 사전에 입력해주셔야 합니다:

```bash
# macOS:
echo 'export PATH="$(yarn global bin):$PATH"' >> ~/.bash_profile
# Linux:
echo 'export PATH="$(yarn global bin):$PATH"' >> ~/.bashrc
```

### 사용

사용방법은 굉장히 간단합니다.

터미널에서 다음 명령어를 입력하세요.

```bash
create-react-app hello-react
```

![img](https://i.imgur.com/0r6VcUu.png)

성공적으로 설치되면 위와 같은 결과가 뜹니다. 위에서 나타난대로 다음과 같이

```bash
cd hello-react
yarn start
```

를 입력하시게 되면, 리액트 프로젝트가 시작 될 것입니다.

그러면 이렇게 브라우저창에서 다음과 같은 페이지가 나타나게 됩니다.

![img](https://i.imgur.com/v9i5deZ.png)

자, 그러면 이제 본격적으로 공부를 시작해봅시다.



## <span style="color:green">리액트 3편: JSX</span>

리액트 컴포넌트에 대하여 조금 더 자세히 알아봅시다!

## 컴포넌트 파일 파헤치기

이전에 만든 hello-react 프로젝트를 열어보세요. 다음과 같이 프로젝트가 구성되어 있을 것입니다.

![img](https://i.imgur.com/v4xX4Tr.png)

리액트를 사용하면 여러분의 웹 애플리케이션에서 사용하는 유저 인터페이스를 재사용 가능한 컴포넌트로 분리하여 작성함으로서, 프로젝트의 유지보수성을 우수하게 해줍니다.

여기서 컴포넌트에 해당하는 코드는, App.js 에서 확인해볼 수 있습니다. 한번 열어보세요.

```javascript
import React, { Component } from 'react';
import logo from './logo.svg';
import './App.css';

class App extends Component {
  render() {
    return (
      <div className="App">
        <header className="App-header">
          <img src={logo} className="App-logo" alt="logo" />
          <h1 className="App-title">Welcome to React</h1>
        </header>
        <p className="App-intro">
          To get started, edit <code>src/App.js</code> and save to reload.
        </p>
      </div>
    );
  }
}

export default App;
```

어떤분에겐 익숙한 코드일수도있고, 어떤분에게는 Wow, 이게뭐지? 일 수도 있습니다. 우선 상단에 있는 코드부터 순서대로 살펴봅시다.

```javascript
import React, { Component } from 'react';
import logo from './logo.svg';
import './App.css';
```

import 한다는것은, 무엇을 불러온다는것입니다. 첫번째 코드는 리액트와 그 내부의 Component 를 불러옵니다. 파일에서 JSX 를 사용하려면, 꼭 React 를 import 해주어야 합니다.

그 아래에서는 같은 디렉토리에 있는 파일 logo.svg 과 App.css 파일을 불러왔습니다.

이렇게, import 를 하는 것은, 우리가 webpack 을 사용하기에 가능한 작업입니다. 이렇게 불러오고나면 나중에 프로젝트를 빌드하게 됐을 때 웹팩에서 파일의 확장자에 따라 다른 작업을 하게 됩니다. CSS 파일을 불러오게되면, 나중에 프로젝트에서 사용한 프로젝트를 한 파일에 모두 결합해주는 작업을 진행하고, 자바스크립트 파일을 불러오게되면 모든 코드들이 제대로 로딩되게끔 순서를 설정하고 하나의 파일로 합쳐주죠. (나중에 다뤄볼 얘기지만 규칙에 따라 여러 파일로 분리해서 저장하는것도 가능합니다.) 그리고, svg 처럼 사전에 따로 설정을 되지 않은 확장자의 경우, 그냥 파일로서 불러온다음에 나중에 특정 경로에 사본을 만들어주게되고, 해당 사본의 경로를 텍스트로 받아오게 됩니다.

그 다음으로 내려가볼까요?

```javascript
class App extends Component {
  ...
}
```

컴포넌트를 만드는 방법은 두가지가 있습니다. 그 중 하나는 위처럼 클래스를 통해서 만드는 것입니다. 또 다른 방법은 함수를 통하여 컴포넌트를 만드는 것인데요, 이에 대해서는 나중에 알아보겠습니다.

```javascript
  render() {
    return (
      <div className="App">
        <header className="App-header">
          <img src={logo} className="App-logo" alt="logo" />
          <h1 className="App-title">Welcome to React</h1>
        </header>
        <p className="App-intro">
          To get started, edit <code>src/App.js</code> and save to reload.
        </p>
      </div>
    );
  }
```

클래스형태로 만들어진 컴포넌트에는 꼭, render 함수가 있어야 하구요, 그리고 그 내부에서는 JSX 를 return 해주어야 합니다. 위에 보이는 HTML 같은 코드가 바로, JSX 입니다.

마지막 줄에 있는 해당 코드는:

```javascript
export default App;
```

우리가 작성한 컴포넌트를 다른 곳에서 불러와서 사용 할 수 있도록 내보내기를 해줍니다.

index.js 파일을 보면, 다음 코드가 있는데요,

```javascript
import React from 'react';
import ReactDOM from 'react-dom';
import './index.css';
import App from './App';
import registerServiceWorker from './registerServiceWorker';

ReactDOM.render(<App />, document.getElementById('root'));
registerServiceWorker();
```

우리가 만든 컴포넌트를 불러올 때는 이렇게 import 를 사용해서 불러와줍니다

```javascript
import App from './App';
```

그리고 브라우저 상에 우리의 리액트 컴포넌트를 보여주기 위해서는 `ReactDOM.render` 함수를 사용합니다. 첫번째 파라미터는 렌더링 할 결과물이고, 두번째 파라미터는 컴포넌트를 어떤 DOM 에 그릴지 정해줍니다.

id 가 root 인 DOM 을 찾아서 그리도록 설정이 되어있는데요, 해당 DOM 은 public/index.html 파일에서 찾아보실 수 있습니다.

해당 파일 안에 있는

```html
<div id="root"></div>
```

를 찿아서 렌더링해주게 되는것이죠.

## JSX

JSX에 대해서 더 자세히 알아봅시다. 얼핏 보기에는 html 같죠? 하지만 **아닙니다**. 이건 자바스크립트입니다. 이게 무슨소리인가 싶죠?

![img](https://i.imgur.com/SZshYmi.png)

http://bit.ly/2FJsJmo

만약에, 컴포넌트를 만들 때 우측에 있는 것처럼 작성해야한다면, 정말 작업하기 싫겠죠? 리액트 개발을 쉽게 하기 위해서, HTML 과 비슷한 문법으로 작성을 하면 이를 React.createElement 를 사용하는 자바스크립트 형태로 변환시켜줍니다.

XML 형태의 코드를, 자바스크립트로 변환해야 하기 때문에, JSX를 제대로 사용하기 위해서 우리는 몇가지 규칙을 준수해줘야 합니다. 딱히, 어렵지는 않습니다. 한번 알아볼까요?

함께 코드를 작성해가면서 하면 좀 더 이해하기 쉬울테니, 일단 컴포넌트에서 보여주던 내용들을 다 비워주겠습니다. 상단의 css 와 svg 도 지워주겠습니다.

```javascript
// src/App.js
import React, { Component } from 'react';

class App extends Component {
  render() {
    return (
      <div>
        
      </div>
    );
  }
}

export default App;
```

### 꼭 닫혀야 하는 태그

태그는 꼭 닫혀있어야 합니다. `<div>` 태그를 열었으면, `</div>` 를 통하여 태그를 꼭 닫아주어야 합니다. 우리가 html 에서 input 이나 br 태그를 작성 할 때 태그를 안닫을때도 있는데요, 똑같이 리액트에서 하시면 이런 오류를 겪에 될 테니 참고하세요.

```javascript
import React, { Component } from 'react';

class App extends Component {
  render() {
    return (
      <div>
        <input type="text">
      </div>
    );
  }
}

export default App;
```

![img](https://i.imgur.com/81aCSSu.png)

### 감싸져 있는 엘리먼트

두개 이상의 엘리먼트는 무조건 하나의 엘리먼트로 감싸져있어야 합니다. 한번, 다음과 같이 코드를 작성해보세요.

```javascript
// src/App.js
import React, { Component } from 'react';

class App extends Component {
  render() {
    return (
      <div>
        Hello
      </div>
      <div>
        Bye
      </div>
    );
  }
}

export default App;
```

![img](https://i.imgur.com/MaH158t.png)

그러면 터미널 쪽에서 이러한 오류가 나타납니다. 하나의 태그로 감싸져있어야 한다고, 에러가 뜨죠.

그러면, 가장 간단하게 해결하는 방법은 이렇게 div 로 감싸주는 것 입니다.

```javascript
import React, { Component } from 'react';

class App extends Component {
  render() {
    return (
      <div>
        <div>
          Hello
        </div>
        <div>
          Bye
        </div>
      </div>
    );
  }
}

export default App;
```

간단하죠? 그런데, 가끔 어떠한 상황에선 단순히 감싸기 위해서 새로운 div 를 사용하는게 맘에들지 않을 수도 있습니다. 예를들어서, 스타일 관련 설정을 하면서 코드가 꼬이게 될 수도 있고, table 관련 태그를 작성 할 때 번거로워질 수도 있죠.

그러한 상황엔 다음과 같이 [Fragment](https://reactjs.org/docs/fragments.html) 라는것을 사용하면 됩니다. (이 기능은 v16.2 에 도입되었습니다.)

```javascript
import React, { Component, Fragment } from 'react';

class App extends Component {
  render() {
    return (
      <Fragment>
        <div>
          Hello
        </div>
        <div>
          Bye
        </div>
      </Fragment>
    );
  }
}

export default App;
```

### JSX 안에 자바스크립트 값 사용하기

JSX 내부에서 자바스크립트 값을 사용 할 땐 이렇게 할 수 있습니다.

```javascript
import React, { Component } from 'react';

class App extends Component {
  render() {
    const name = 'react';
    return (
      <div>
        hello {name}!
      </div>
    );
  }
}

export default App;
```

혹시나, const 라는 키워드가 생소한 분들을 위해 설명드리자면, const 는 ES6 에 도입된 키워드로서, 한번 선언하고 바뀌지 않는 값을 설정 할 때 사용됩니다. 그리고, 바뀌게 될 수 있는 값은 let 을 사용하여 선언하죠.

기존 자바스크립트의 var 과 비슷하다고 생각하시면 되는데, 작동 방식에 있어서 scope 가 다릅니다.

var 은 scope 가 함수단위인데요:

```javascript
function foo() {
  var a = 'hello';
  if (true) {
    var a = 'bye';
    console.log(a); // bye
  }
  console.log(a); // bye
}
```

반면 const 와 let 은 scope 가 블록 단위 입니다.

```javascript
function foo() {
  let a = 'hello';
  if (true) {
    let a = 'bye';
    console.log(a); // bye
  }
  console.log(a); // hello
}
```

여기서 드는 의문, var, const, let 이 다른 키워드들을 어떨때 써야 할지? 궁금 할 수도 있습니다.

ES6 에서는, var 을 쓸 일이 없구요, 값을 선언 후 바꿔야 할 땐 let, 그리고 바꾸지 않을 땐 const 를 사용하시면 됩니다.

### 조건부 렌더링

JSX 내부에서 조건부 렌더링을 할 때는 보통 삼항 연산자를 사용하거나, AND 연산자를 사용합니다.

반면에 if 문을 사용 할 수는 없어요 (사용하려면 [IIFE](https://developer.mozilla.org/ko/docs/Glossary/IIFE)(즉시 실행 함수 표현) 을 사용해아합니다.)

코드로 예제를 한번 살펴볼까요?

먼저 삼항연산자부터 봅시다.

```javascript
import React, { Component } from 'react';

class App extends Component {
  render() {
    return (
      <div>
        {
          1 + 1 === 2 
            ? (<div>맞아요!</div>)
            : (<div>틀려요!</div>)
        }
      </div>
    );
  }
}

export default App;
```

이렇게 하면, 맞아요가 보여질 것입니다. 반면 1 + 1 === 2 부분을 1 + 1 === 3 으로 바꿔보세요. 그럼 틀려요가 나타납니다.

그 다음엔 AND 연산자를 사용해보겠습니다. 삼항연산자는 true 일 때와 false 일 때 다른것들을 보여주고 싶을 떄 사용하는 반면, AND 연산자의 경우 단순히 우리의 조건이 true 일 때만 보여주고 false 경우 아무것도 보여주고 싶지 않을 때 사용합니다.

```javascript
import React, { Component } from 'react';

class App extends Component {
  render() {
    return (
      <div>
        {
          1 + 1 === 2 && (<div>맞아요!</div>)
        }
      </div>
    );
  }
}

export default App;
```

대부분의 상황엔 위의 방식으로 해결 할 수 있지만, 가끔씩은 좀 복잡한 조건을 작성해야 할 때도 있습니다. 그러한 조건들은 웬만하면 JSX 밖에서 로직을 작성하는것이 좋습니다. 하지만, 꼭 JSX 내부에서 작성해야 한다면, 이렇게 IIFE 를 사용합니다.

```javascript
import React, { Component } from 'react';

class App extends Component {
  render() {
    const value = 1;
    return (
      <div>
        {
          (function() {
            if (value === 1) return (<div>하나</div>);
            if (value === 2) return (<div>둘</div>);
            if (value === 3) return (<div>셋</div>);
          })()
        }
      </div>
    );
  }
}

export default App;
```

if 문 대신에 switch 문을 사용하셔도 상관 없습니다. 그리고 위 코드는 다음과 같이 쓸 수도 있습니다.

```javascript
(() => {
  if (value === 1) return (<div>하나</div>);
  if (value === 2) return (<div>둘</div>);
  if (value === 3) return (<div>셋</div>);
})()
```

여기서 사용된건 [화살표 함수](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Functions/애로우_펑션) 라고 부릅니다.

화살표 함수는 this, arguments, super 개념이 없는 익명 함수입니다. 앞으로 ES6 에서 자주 사용하게 될 것입니다.

### style 과 className

JSX 에서 style 과 CSS 클래스를 설정 할 때, html 에서 하는 것과 사뭇 다릅니다.

우선, 스타일은 다음과 같이 작성 할 수 있습니다.

```javascript
import React, { Component } from 'react';

class App extends Component {
  render() {
    const style = {
      backgroundColor: 'black',
      padding: '16px',
      color: 'white',
      fontSize: '12px'
    };

    return (
      <div style={style}>
        hi there
      </div>
    );
  }
}

export default App;
```

![img](https://i.imgur.com/HygXQs5.png)

html 에서는 그냥 텍스트형태로 `="backgroundColor: black; padding: 16px; ..."` 이런식으로 작성했었지요? 리액트에서는 객체 형태로 작성해주셔야 합니다.

그리고 클래스를 설정하게 될 때에는 html 에서는 `<div class="hello">` 이렇게 작성했었는데요, 리액트 컴포넌트에서는 class 대신에 className 을 사용합니다.

한번 직접 해볼까요? App.css 파일을 열어서 다음과 같이 수정하세요:

```css
.App {
  background: black;
  color: aqua;
  font-size: 36px;
  padding: 1rem;
  font-weight: 600;
}
```

그리고, App.js 는 이렇게 수정해보세요.

```javascript
import React, { Component } from 'react';
import './App.css'

class App extends Component {
  render() {
    return (
      <div className="App">
        리액트
      </div>
    );
  }
}

export default App;
```

![img](https://i.imgur.com/5ncflHm.png)

### 주석

마지막으로, 주석은 어떻게 작성하는지 알아봅시다.

```javascript
import React, { Component } from 'react';

class App extends Component {
  render() {
    return (
      <div>
        {/* 주석은 이렇게 */}
        <h1
          // 태그 사이에
        >리액트</h1>
      </div>
    );
  }
}

export default App;
```

위에 보이는 바와 같이, `{/* ... */}` 사이에 넣거나, 태그 사이에 넣을 수도 있습니다.

## 정리

이제 우리는 JSX 를 작성하게 될 때 주의해야 할 점을 알아보았습니다. 다음 섹션에서는, 한번 새 컴포넌트를 만들어보면서, 컴포넌트에 전달해주는 값인 props 와, 컴포넌트 내부적으로 들고있는 값인 state 에 대해서 알아보겠습니다.





## <span style="color:green"> 4편: props 와 state</span>

리액트 컴포넌트에서 다루는 데이터는 두개로 나뉩니다. 바로 props 와 state 인데요, 미리 요약하여 설명드리자면 props 는 부모 컴포넌트가 자식 컴포넌트에게 주는 값입니다. 자식 컴포넌트에서는 props 를 받아오기만하고, 받아온 props 를 직접 수정 할 수 는 없습니다.

반면에 state 는 컴포넌트 내부에서 선언하며 내부에서 값을 변경 할 수 있습니다.

## 새 컴포넌트 만들기

자, 한번 새로운 컴포넌트를 만들어봅시다. src 디렉토리에 MyName 이라는 컴포넌트를 만들어보세요.

```javascript
import React, { Component } from 'react';

class MyName extends Component {
  render() {
    return (
      <div>
        안녕하세요! 제 이름은 <b>{this.props.name}</b> 입니다.
      </div>
    );
  }
}

export default MyName;
```

자신이 받아온 props 값은 `this.` 키워드를 통하여 조회 할 수 있습니다.
지금 name 이라는 props 를 보여주도록 설정해주었습니다. 자, 이제 이 컴포넌트를 사용해볼까요?

App.js 를 다음과 같이 열어보세요.

```javascript
import React, { Component } from 'react';
import MyName from './MyName';

class App extends Component {
  render() {
    return (
      <MyName name="리액트" />
    );
  }
}

export default App;
```

import 를 통하여 컴포넌트를 불러오고, 렌더링해보겠습니다. 이렇게 컴포넌트를 만들고나면, 일반 태그를 작성하듯이, 작성해주면 됩니다. 그리고 props 값은 `name="리액트"` 이런식으로 태그의 속성을 설정해주는 것 처럼 해주세요.

작성 후, 브라우저를 확인해볼까요?

![img](https://i.imgur.com/xbryzdW.png)

## defaultProps

가끔씩은 실수로 props 를 빠트려먹을때가 있습니다. 혹은, 특정 상황에 props 를 일부러 비워야 할 때도 있구요. 그러한 경우에, props 의 기본값을 설정해줄 수 있는데요, 그것이 바로 defaultProps 입니다.

```javascript
import React, { Component } from 'react';

class MyName extends Component {
  static defaultProps = {
    name: '기본이름'
  }
  render() {
    return (
      <div>
        안녕하세요! 제 이름은 <b>{this.props.name}</b> 입니다.
      </div>
    );
  }
}

export default MyName;
```

이렇게 하면 만약에 `<MyName />` 이런식으로 name 값을 생략해버리면 “기본이름” 이 나타나게 될 것입니다. 참고로, defaultProps 는 다음과 같은 형태로도 설정 할 수 있습니다.

```javascript
import React, { Component } from 'react';

class MyName extends Component {
  render() {
    return (
      <div>
        안녕하세요! 제 이름은 <b>{this.props.name}</b> 입니다.
      </div>
    );
  }
}

MyName.defaultProps = {
  name: '기본이름'
};

export default MyName;
```

우리가 곧 알아볼 함수형 컴포넌트에서 defaultProps 를 설정할땐 위 방식으로 하면 됩니다.

## 함수형 컴포넌트

이렇게 단순히 props 만 받아와서 보여주기만 하는 컴포넌트의 경우엔 더 간편한 문법으로 작성할 수 있는 방법이 있습니다. 바로, 함수형태로 작성하는 것인데요, 한번 우리가 만들었던 MyName 컴포넌트를 다시 작성해보겠습니다.

```javascript
import React from 'react';

const MyName = ({ name }) => {
  return (
    <div>
      안녕하세요! 제 이름은 {name} 입니다.
    </div>
  );
};

export default MyName;
```

어떤가요? 훨씬 간단하죠? 함수형 컴포넌트와 클래스형 컴포넌트의 주요 차이점은, 우리가 조만간 배우게 될 state 와 LifeCycle 이 빠져있다는 점입니다. 그래서, 컴포넌트 초기 마운트가 아주 미세하게 빠르고, 메모리 자원을 덜 사용합니다. 미세한 차이이니, 컴포넌트를 무수히 많이 렌더링 하게 되는게 아니라면 성능적으로 큰 차이는 없습니다.

## state

자, 동적인 데이터를 다룰 땐 어떻게 할까요? 바로 state 를 사용합니다. 이번에 또 새로운 컴포넌트를 만들어볼게요. Counter 라는 파일을 생성해서 다음과 같이 입력해보세요.

```javascript
import React, { Component } from 'react';

class Counter extends Component {
  state = {
    number: 0
  }

  handleIncrease = () => {
    this.setState({
      number: this.state.number + 1
    });
  }

  handleDecrease = () => {
    this.setState({
      number: this.state.number - 1
    });
  }

  render() {
    return (
      <div>
        <h1>카운터</h1>
        <div>값: {this.state.number}</div>
        <button onClick={this.handleIncrease}>+</button>
        <button onClick={this.handleDecrease}>-</button>
      </div>
    );
  }
}

export default Counter;
```

### state 정의

위에서부터 아래로 쭉 살펴봅시다. 우선, 컴포넌트의 state 를 정의할 때는 [class fields](https://babeljs.io/docs/plugins/transform-class-properties/) 문법을 사용해서 정의합니다.

이 코드는 만약에 class fields 를 사용하지 않는다면 다음과 같이 사용합니다.

```javascript
import React, { Component } from 'react';

class Counter extends Component {
  constructor(props) {
    super(props);
    this.state = {
      number: 0
    }
  }

  ...

 
}
```

우리가 class fields 를 사용하는건 편의를 위함입니다. 확실히 constructor 에 넣는것보다는 편해보이죠?

위 코드의 constructor 에서 `super(props)` 를 호출 한 이유는, 우리가 컴포넌트를 만들게 되면서, Component 를 상속했으며, 우리가 이렇게 constructor 를 작성하게 되면 기존의 클래스 생성자를 덮어쓰게 됩니다. 그렇기에, 리액트 컴포넌트가 지니고있던 생성자를 super 를 통하여 미리 실행하고, 그 다음에 우리가 할 작업 (state 설정) 을 해주는 것 입니다.

만약에 class fields 도 사용하고 constructor 도 사용하게 된다면, 어떤 부분이 더욱 늦게 설정될까요?

![img](https://i.imgur.com/L1P2Z0J.png)

class fields 가 먼저 실행되고, 그 다음에 constructor 에서 설정된 것이 나옵니다.

### 메소드 작성

```javascript
  handleIncrease = () => {
    this.setState({
      number: this.state.number + 1
    });
  }

  handleDecrease = () => {
    this.setState({
      number: this.state.number - 1
    });
  }
```

컴포넌트에 메소드를 작성해주었습니다. 컴포넌트에서 메소드는 다음과 같은 형식으로도 작성 할 수 있는데요,

```javascript
  handleIncrease() {
    this.setState({
      number: this.state.number + 1
    });
  }

  handleDecrease() {
    this.setState({
      number: this.state.number - 1
    });
  }
```

이렇게 하면, 나중에 버튼에서 클릭이벤트가 발생 했을 때, this 가 undefined 로 나타나서 제대로 처리되지 않게 됩니다. 이는 함수가 버튼의 클릭이벤트로 전달이 되는 과정에서 “this” 와의 연결이 끊겨버리기 때문인데요, 이를 고쳐주려면 constructor 에서

```javascript
  constructor(props) {
    super(props);
    this.handleIncrease = this.handleIncrease.bind(this);
    this.handleDecrease = this.handleDecrease.bind(this);
  }
```

처럼 해주거나, 우리가 이전에 작성한 코드처럼 아예 화살표 함수 형태로 하면 this 가 풀리는 것에 대해서 걱정하실 필요 없습니다.

### setState

자 이제 각 메소드에 들어있는 `this.setState` 에 대해서 알아봅시다. state 에 있는 값을 바꾸기 위해서는, this.setState 를 무조건 거쳐야합니다. 리액트에서는, 이 함수가 호출되면 컴포넌트가 리렌더링 되도록 설계되어있습니다.

이 함수에 대해서 조금 더 자세히 알아봅시다.

setState 는, 객체로 전달되는 값만 업데이트를 해줍니다.

지금은 state 에 number 값밖에 없지만 만약에 다음과 같이 다른 값이 있다고 가정해봅시다.

```javascript
  state = {
    number: 0,
    foo: 'bar'
  }
```

그러면, this.setState({ number: 1 }); 을 하게 된다면, foo 는 그대로 남고, number 값만 업데이트 됩니다.

setState 는 객체의 깊숙한곳 까지 확인하지 못합니다. 예를들어서, state 가 다음과 같이 설정되어있다고 가정한다면요,

```javascript
  state = {
    number: 0,
    foo: {
      bar: 0,
      foobar: 1
    }
  }
```

아래와 같이 한다고 해서 foobar 값이 업데이트 되지 않습니다.

```javascript
this.setState({
  foo: {
    foobar: 2
  }
})
```

이렇게 하게된다면 그냥 기존의 foo 객체가 바뀌어버립니다.

```javascript
{
  number: 0,
  foo: {
    foobar: 2
  }
}
```

그 대신에 위와 같은 상황에서는 이렇게 해주어야합니다:

```javascript
this.setState({
  number: 0,
  foo: {
    ...this.state.foo,
    foobar: 2
  }
});
```

… 은 자바스크립트의 [전개연산자](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Operators/Spread_operator) 입니다. 기존의 객체안에 있는 내용을 해당 위치에다가 풀어준다는 의미죠. 그 다음에, 우리가 설정하고 싶은 값을 또 넣어주면 해당 값을 덮어쓰게 됩니다.

이러한 작업이 꽤나 귀찮으므로, 나중에는 [immutable.js](https://velopert.com/3486) 혹은 [immer.js](https://github.com/mweststrate/immer) 를 사용하여 이 작업을 좀 더 간단하게 해볼 것입니다.

#### setState에 객체 대신 함수를 전달하기

setState 를 사용하여 값을 업데이트하게 될 때, 기존의 값을 참고하여 값을 업데이트를 하게 될 때, 조금 더 나은 문법으로 할 수 있습니다.

기존에 작성했던 코드는 이랬죠?

```javascript
this.setState({
  number: this.state.number + 1
});
```

큰 문제는 아니지만, 굳이 또 this.state 를 조회해야 하는데요, 이렇게 하면 조금 더 멋진 문법으로 작성 할 수 있습니다.

```javascript
this.setState(
  (state) => ({
    number: state.number
  })
);
```

setState 에 updater 함수를 만들어서 전달해 주었습니다. 여기서 조금 더 나아가면 이렇게 작성 할 수 있습니다.

```javascript
this.setState(
  ({ number }) => ({
    number: number + 1
  })
);
```

보면 (state) 가 ({ number }) 가 됐죠? 이건 [비구조화 할당](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment) 이라는 문법입니다.

이 문법은 이런식으로도 사용 할 수 있는데요,

```javascript
const { number } = this.state;
```

결국 코드를 조금 덜 작성하고 싶다면 이렇게도 할 수 있답니다.

```javascript
const { number } = this.state;
this.setState({
  number: number + 1
})
```

어떤 코드가 더 맘에 드시나요? 아무거나 사용하시면 됩니다.

그러면, 기존에 작성했던 함수를 각각 다른 방식으로 구현해보겠습니다.

```javascript
  handleIncrease = () => {
    const { number } = this.state;
    this.setState({
      number: number + 1
    });
  }

  handleDecrease = () => {
    this.setState(
      ({ number }) => ({
        number: number - 1
      })
    );
  }
```

### 이벤트 설정

render 함수에서 이벤트 설정을 한 부분을 확인해봅시다.

```javascript
  render() {
    return (
      <div>
        <h1>카운터</h1>
        <div>값: {this.state.number}</div>
        <button onClick={this.handleIncrease}>+</button>
        <button onClick={this.handleDecrease}>-</button>
      </div>
    );
  }
```

버튼이 클릭되면 우리가 준비한 함수가 각각 호출되도록 설정해주었습니다. 기존에 자바스크립트로 비슷한 작업을 해보신분이라면 아래에 있는 코드가 익숙하시겠죠?

```html
<button onclick="alert('hello');">Click Me</button>
```

html 에서는 onclick 속성에 클릭되면 실행 할 자바스크립트를 문자열 형태로 넣어줍니다. 반면 우리가 작성한 코드를 다시 봐보세요.

```javascript
<button onClick={this.handleIncrease}>+</button>
```

여기서 정말로 **주의**해주셔야 하는데요, 리액트에서 이벤트 함수를 설정할때 html 과 다음과 같은 사항이 다릅니다.

- 이벤트이름을 설정 할 때 camelCase 로 설정해주어야 합니다. onclick 은 onClick, onmousedown 은 onMouseDown, onchange 는 onChange 이런식으로 말이죠.
- 이벤트에 전달해주는 값은 **함수** 여야 합니다. 만약에 `onClick={this.handleIncrease()}` 이런식으로 하게 된다면, 렌더링을 할 때 마다 해당 함수가 호출이됩니다. 그렇게 되면 정말 큰 일이 발생합니다. 렌더링 -> 함수 호출 -> setState -> 렌더링 -> 함수 호출 -> 무한반복.. 이렇게 되버리는 것이죠!

그러니까 꼭 주의하셔야 합니다. 렌더링 함수에서 이벤트를 설정 할 때 여러분이 만든 메소드를 호출하지 마세요!

자~ 그러면 설명이 끝났으니 이 컴포넌트를 App 에서 불러와서 렌더링 해보세요.

```javascript
import React, { Component } from 'react';
import Counter from './Counter';

class App extends Component {
  render() {
    return (
      <Counter />
    );
  }
}

export default App;
```

![img](https://i.imgur.com/BOHshpr.png)

아래에 있는 버튼들을 눌러보면 숫자가 바뀔겁니다!

## 정리

리액트에서 props 를 전달하는 방법과, state 를 다루는 방법을 알아보았습니다. 지금은 아주 간단한 정보의 상태 조작만 했는데요, 앞으로 조금 더 복잡한 상태들을 관리하게 될거에요.

다음 섹션에서는, 리액트에서 매우 유용한 역할을 하는 LifeCycle API 에 대해서 알아보겠습니다.



## <span style="color:green">5편: LifeCycle API</span>

자 이번에는 리액트의 LifeCycle API 에 대해서 알아보겠습니다. 이 API 는 컴포넌트가 여러분의 브라우저에서 나타날때, 사라질때, 그리고 업데이트 될 때, 호출되는 API 입니다.

정말 중요한 역할을 하는데요! 한번 세세히 파헤쳐봅시다.

## 컴포넌트 초기 생성

일단, 컴포넌트가 브라우저에 나타나기 전, 후에 호출되는 API 들이 있습니다.

### constructor

```javascript
constructor(props) {
  super(props);
}
```

이전에 언급 한적이 있죠? 이 부분은 컴포넌트 생성자 함수입니다. 컴포넌트가 새로 만들어질 때마다 이 함수가 호출됩니다.

### componentWillMount

```javascript
componentWillMount() {

}
```

이 API 는 컴포넌트가 여러분의 화면에 나가나기 직전에 호출되는 API 인데요, 이 API 에 대해선 별로 신경쓰지 않아도 됩니다. 원래는 주로 브라우저가 아닌 환경에서 (서버사이드)도 호출하는 용도로 사용했었는데, 이 API 가 더 이상 필요하지 않게 되어 리액트 v16.3 에서는 해당 API 가 deprecated 되었으니, 아, 옛날엔 이러한 API가 사용됐었구나.. 하고 알아만 두시면 됩니다. v16.3 이후부터는 `UNSAFE_componentWillMount()` 라는 이름으로 사용됩니다. 기존에 이 API 에서 하던 것들은 위에 있는 constructor 와 아래에서 다뤄볼 componentDidMount 에서 충분히 처리 할 수 있습니다.

### componentDidMount

```javascript
componentDidMount() {
  // 외부 라이브러리 연동: D3, masonry, etc
  // 컴포넌트에서 필요한 데이터 요청: Ajax, GraphQL, etc
  // DOM 에 관련된 작업: 스크롤 설정, 크기 읽어오기 등
}
```

이 API 는 여러분의 컴포넌트가 화면에 나타나게 됐을 때 호출됩니다. 여기선 주로 D3, masonry 처럼 DOM 을 사용해야하는 외부 라이브러리 연동을 하거나, 해당 컴포넌트에서 필요로하는 데이터를 요청하기 위해 axios, fetch 등을 통하여 ajax 요청을 하거나, DOM 의 속성을 읽거나 직접 변경하는 작업을 진행합니다.

## 컴포넌트 업데이트

컴포넌트가 업데이트는 props 의 변화, 그리고 state 의 변화에 따라 결정됩니다. 업데이트가 되기 전과 그리고 된 후에 어떠한 API 가 호출 되는지 살펴볼까요?

### componentWillReceiveProps

```javascript
componentWillReceiveProps(nextProps) {
  // this.props 는 아직 바뀌지 않은 상태
}
```

이 API 는 컴포넌트가 새로운 props 를 받게됐을 때 호출됩니다. 이 안에서는 주로, state 가 props 에 따라 변해야 하는 로직을 작성합니다. 새로 받게될 props 는 nextProps 로 조회 할 수 있으며, 이 때 this.props 를 조회하면 업데이트 되기 전의 API 이니 참고하세요. **이 API 또한 v16.3 부터 deprecate 됩니다.** v16.3 부터는 `UNSAFE_componentWillReceiveProps()` 라는 이름으로 사용됩니다. 그리고, 이 기능은 상황에 따라 새로운 API [getDerivedStateFromProps](https://reactjs.org/docs/react-component.html#static-getderivedstatefromprops) 로 대체 될 수도 있습니다.

### [NEW] static getDerivedStateFromProps()

이 함수는, v16.3 이후에 만들어진 라이프사이클 API 인데요, 이 API 는 props 로 받아온 값을 state 로 동기화 하는 작업을 해줘야 하는 경우에 사용됩니다.

```javascript
static getDerivedStateFromProps(nextProps, prevState) {
  // 여기서는 setState 를 하는 것이 아니라
  // 특정 props 가 바뀔 때 설정하고 설정하고 싶은 state 값을 리턴하는 형태로
  // 사용됩니다.
  /*
  if (nextProps.value !== prevState.value) {
    return { value: nextProps.value };
  }
  return null; // null 을 리턴하면 따로 업데이트 할 것은 없다라는 의미
  */
}
```

### shouldComponentUpdate

```javascript
shouldComponentUpdate(nextProps, nextState) {
  // return false 하면 업데이트를 안함
  // return this.props.checked !== nextProps.checked
  return true;
}
```

이 API 는 컴포넌트를 최적화하는 작업에서 매우 유용하게 사용됩니다. 우리가 저번에 배웠을 떄, 리액트에서는 변화가 발생하는 부분만 업데이트를 해줘서 성능이 꽤 잘 나온다고 했었지요? 하지만, 변화가 발생한 부분만 감지해내기 위해서는 Virtual DOM 에 한번 그려줘야합니다.

즉, 현재 컴포넌트의 상태가 업데이트되지 않아도, 부모 컴포넌트가 리렌더링되면, 자식 컴포넌트들도 렌더링 됩니다. 여기서 “렌더링” 된다는건, render() 함수가 호출된다는 의미입니다.

변화가 없으면 물론 DOM 조작은 하지 않게 됩니다. 그저 Virutal DOM 에만 렌더링 할 뿐이죠. 이 작업은 그렇게 부하가 많은 작업은 아니지만, 컴포넌트가 무수히 많이 렌더링된다면 얘기가 조금 달라집니다. CPU 자원을 어느정도 사용하고 있는것은 사실이니까요.

쓸대없이 낭비되고 있는 이 CPU 처리량을 줄여주기 위해서 우리는 Virtual DOM 에 리렌더링 하는것도,불필요할경우엔 방지하기 위해서 shouldComponentUpdate 를 작성합니다.

이 함수는 기본적으로 true 를 반환합니다. 우리가 따로 작성을 해주어서 조건에 따라 false 를 반환하면 해당 조건에는 render 함수를 호출하지 않습니다.

### componentWillUpdate

```javascript
componentWillUpdate(nextProps, nextState) {

}
```

이 API는 shouldComponentUpdate 에서 true 를 반환했을때만 호출됩니다. 만약에 false 를 반환했었다면 이 함수는 호출되지 않습니다. 여기선 주로 애니메이션 효과를 초기화하거나, 이벤트 리스너를 없애는 작업을 합니다. 이 함수가 호출되고난 다음에는, render() 가 호출됩니다. **이 API 또한 v16.3 이후 deprecate 됩니다.** 기존의 기능은 [getSnapshotBeforeUpdate](https://reactjs.org/docs/react-component.html#getsnapshotbeforeupdate) 로 대체 될 수 있습니다.

### [NEW] getSnapshotBeforeUpdate()

이 API 가 발생하는 시점은 다음과 같습니다.

1. render()
2. **getSnapshotBeforeUpdate()**
3. 실제 DOM 에 변화 발생
4. componentDidUpdate

이 API를 통해서, DOM 변화가 일어나기 직전의 DOM 상태를 가져오고, 여기서 리턴하는 값은 componentDidUpdate 에서 3번째 파라미터로 받아올 수 있게 됩니다.

예시코드:

```javascript
  getSnapshotBeforeUpdate(prevProps, prevState) {
    // DOM 업데이트가 일어나기 직전의 시점입니다.
    // 새 데이터가 상단에 추가되어도 스크롤바를 유지해보겠습니다.
    // scrollHeight 는 전 후를 비교해서 스크롤 위치를 설정하기 위함이고,
    // scrollTop 은, 이 기능이 크롬에 이미 구현이 되어있는데, 
    // 이미 구현이 되어있다면 처리하지 않도록 하기 위함입니다.
    if (prevState.array !== this.state.array) {
      const {
        scrollTop, scrollHeight
      } = this.list;

      // 여기서 반환 하는 값은 componentDidMount 에서 snapshot 값으로 받아올 수 있습니다.
      return {
        scrollTop, scrollHeight
      };
    }
  }

  componentDidUpdate(prevProps, prevState, snapshot) {
    if (snapshot) {
      const { scrollTop } = this.list;
      if (scrollTop !== snapshot.scrollTop) return; // 기능이 이미 구현되어있다면 처리하지 않습니다.
      const diff = this.list.scrollHeight - snapshot.scrollHeight;
      this.list.scrollTop += diff;
    }
  }
```

전체코드는 https://codesandbox.io/s/484zvr87ow 에서 확인 하실 수 있습니다.

### componentDidUpdate

```javascript
componentDidUpdate(prevProps, prevState, snapshot) {

}
```

이 API는 컴포넌트에서 render() 를 호출하고난 다음에 발생하게 됩니다. 이 시점에선 this.props 와 this.state 가 바뀌어있습니다. 그리고 파라미터를 통해 이전의 값인 prevProps 와 prevState 를 조회 할 수 있습니다. 그리고, getSnapshotBeforeUpdate 에서 반환한 snapshot 값은 세번째 값으로 받아옵니다.

## 컴포넌트 제거

컴포넌트가 더 이상 필요하지 않게 되면 단 하나의 API 가 호출됩니다:

### componentWillUnmount

```javascript
componentWillUnmount() {
  // 이벤트, setTimeout, 외부 라이브러리 인스턴스 제거
}
```

여기서는 주로 등록했었던 이벤트를 제거하고, 만약에 setTimeout 을 걸은것이 있다면 clearTimeout 을 통하여 제거를 합니다. 추가적으로, 외부 라이브러리를 사용한게 있고 해당 라이브러리에 dispose 기능이 있다면 여기서 호출해주시면 됩니다.

## 직접 사용해보기

기존에 우리가 만들었던 카운터에 LifeCycle API 를 작성해보겠습니다. Counter.js 를 다음과 같이 수정해보세요.

```javascript
import React, { Component } from 'react';

class Counter extends Component {
  state = {
    number: 0
  }

  constructor(props) {
    super(props);
    console.log('constructor');
  }
  
  componentWillMount() {
    console.log('componentWillMount (deprecated)');
  }

  componentDidMount() {
    console.log('componentDidMount');
  }

  shouldComponentUpdate(nextProps, nextState) {
    // 5 의 배수라면 리렌더링 하지 않음
    console.log('shouldComponentUpdate');
    if (nextState.number % 5 === 0) return false;
    return true;
  }

  componentWillUpdate(nextProps, nextState) {
    console.log('componentWillUpdate');
  }
  
  componentDidUpdate(prevProps, prevState) {
    console.log('componentDidUpdate');
  }
  

  handleIncrease = () => {
    const { number } = this.state;
    this.setState({
      number: number + 1
    });
  }

  handleDecrease = () => {
    this.setState(
      ({ number }) => ({
        number: number - 1
      })
    );
  }
  
  render() {
    console.log('render');
    return (
      <div>
        <h1>카운터</h1>
        <div>값: {this.state.number}</div>
        <button onClick={this.handleIncrease}>+</button>
        <button onClick={this.handleDecrease}>-</button>
      </div>
    );
  }
}

export default Counter;
```

![img](https://i.imgur.com/RQxnJHW.png)

콘솔에 찍히는 메시지들을 확인해보세요. 그리고 5의 배수일때는 컴포넌트가 리렌더링 되지 않는 것도 확인하세요.

## 컴포넌트에 에러 발생

render 함수에서 에러가 발생한다면, 리액트 앱이 크래쉬 되어버립니다. 그러한 상황에 유용하게 사용 할 수 있는 API 가 한가지 있는데 한번 알아봅시다!

### componentDidCatch

```javascript
componentDidCatch(error, info) {
  this.setState({
    error: true
  });
}
```

에러가 발생하면 이런식으로 componentDidCatch 가 실행되게 하고, state.error 를 true 로 설정하게 하고, render 함수쪽에서 이에 따라 에러를 띄워주시면 됩니다.

이 API 를 사용하시게 될 때 주의하실 점이 있는데요, 컴포넌트 자신의 render 함수에서 에러가 발생해버리는것은 잡아낼 수는 없지만, 그 대신에 컴포넌트의 자식 컴포넌트 내부에서 발생하는 에러들을 잡아낼 수 있습니다

일단 문제가 발생하는 코드를 작성해봅시다!

```javascript
import React, { Component } from 'react';

const Problematic = () => {
  throw (new Error('버그가 나타났다!'));
  return (
    <div>
      
    </div>
  );
};

class Counter extends Component {
  // ... 생략
  
  render() {
    return (
      <div>
        <h1>카운터</h1>
        <div>값: {this.state.number}</div>
        { this.state.number === 4 && <Problematic /> }
        <button onClick={this.handleIncrease}>+</button>
        <button onClick={this.handleDecrease}>-</button>
      </div>
    );
  }
}

export default Counter;
```

Problematic 이라는 컴포넌트를 만들고 이 값이 4가 되면 렌더링을 하도록 설정했습니다. Problematic 은 렌더링이 될 때 에러가 발생했음을 알리는 throw 를 사용하게끔 했는데요, 한번 카운터 값이 4까지 올라갔을때 어떻게 되는지 확인해보겠습니다.

![img](https://i.imgur.com/ArinRKE.png)

여기서 이렇게 빨갛게 Error: 버그가 나타났다! 라고 뜨는 부분은 개발모드에서 제공해주는 기능입니다. 프로덕션에선 이 화면은 나타나지 않습니다. 여기서 X 를 눌러보시면,

![img](https://i.imgur.com/UE8tMyQ.png)

그냥 비어있는 페이지가 나타납니다.

자, 그럼 componentDidCatch 를 통하여 자식 컴포넌트에서 발생한 에러를 잡아보겠습니다.

```javascript
import React, { Component } from 'react';

const Promblematic = () => {
  throw (new Error('버그가 나타났다!'));
  return (
    <div>
      
    </div>
  );
};

class Counter extends Component {
  state = {
    number: 0,
    error: false
  }

  // (...)
  
  componentDidCatch(error, info) {
    this.setState({
      error: true
    });
  }
  
  render() {
    if (this.state.error) return (<h1>에러발생!</h1>);

    return (
      <div>
        <h1>카운터</h1>
        <div>값: {this.state.number}</div>
        { this.state.number === 4 && <Promblematic /> }
        <button onClick={this.handleIncrease}>+</button>
        <button onClick={this.handleDecrease}>-</button>
      </div>
    );
  }
}

export default Counter;
```

이젠 어떻게되나 볼까요?

다시 카운터를 4로 올리면, 빨간 에러창은 여전히 뜨게 됩니다. 하지만 X 를 눌렀을 때, 앱이 크래쉬되는 것이 아니라 에러가 발생했다는 메시지가 뜨게 됩니다.

![img](https://i.imgur.com/bcq0n3S.png)

보통, 렌더링 부분에서 오류가 발생하는것은 사전에 방지해주어야 합니다. 주로 자주 에러가 발생하는 이유는 다음과 같습니다:

1. 존재하지 않는 함수를 호출하려고 할 때 (예를들어서 props 로 받았을줄 알았던 함수가 전달되지 않았을때)

```javascript
this.props.onClick();
```

1. 배열이나 객체가 올 줄 알았는데, 해당 객체나 배열이 존재하지 않을때

```javascript
this.props.object.value; // object is undefined
this.props.array.length; // array is undefined
```

이러한 것들은 render 함수에서 다음과 같은 형식으로 막아 줄 수 있습니다.

```javascript
render() {
  if (!this.props.object || !this.props.array || this.props.array.length ===0) return null;
  // object 나 array 를 사용하는 코드
}
```

혹은, 우리가 이전에 배웠었던 컴포넌트의 기본값을 설정하는 defaultProps를 통해서 설정하면됩니다.

```javascript
class Sample extends Component {
  static defaultProps = {
    onIncrement: () => console.warn('onIncrement is not defined'),
    object: {},
    array: []
  }
}
```

하지만 이걸로도! 놓쳐버린 버그들은 componentDidCatch 를 통해서 잡아주고, 필요시엔 에러의 세부내용을 서버쪽에 기록하게해서 조사해보면 되겠지요?

## 정리

리액트 컴포넌트가 사용될 때 각 상황에 따라 호출되는 LifeCycle API 에 대해서 알아보았습니다. 이 API 들은 알아두면 여러상황에 유용하게 쓸 수 있으니, 어떠한 API 들이 있는지 인지해두시고, 나중에 해결해야 할 문제가 있을 때 사용하면 되겠습니다.

다음 섹션에서는 state 와 props 를 사용하여 컴포넌트간의 데이터 교류와 조금 더 복잡한 상태관리를 다뤄보겠습니다.





## <span style="color:green">6편: input 상태 관리하기</span>

자, 우리가 지금까지 배웠던것들을 요약해봅시다.

- 컴포넌트 만들기
- props 와 state
- LifeCycle API

딱히 배운게 그리 많지는 않죠? 그런데 이것만으로도 정말 많은 것들을 만들 수 있습니다!
리액트는, 그냥 자바스크립트와 가깝습니다. 자바스크립트를 잘 알고 있다면, 리액트 관련해서는 배울게 그리 많지는 않습니다.

앞으로 우리는 전화번호부 프로젝트를 만들어볼건데요, 이 프로젝트에서는 우리가 배웠던 지식들을 응용하여 다양한 작업들을 구현하고, input 상태를 관리하는 방법과 배열을 다루는 방법을 알아보겠습니다.

> 프로젝트 코드는 https://github.com/vlpt-playground/phone-book 에서 확인 할 수 있습니다.

## 프로젝트 생성하기

우리가 기존에 만들었던 프로젝트는 그대로 두고, 새 프로젝트를 만들겠습니다.

```javascript
create-react-app phone-book
```

그리고, 해당 디렉토리를 VSCode 로 열고, 내부에서 `yarn start` 를 통해서 개발서버를 시작하세요.

## 첫번째 컴포넌트, PhoneForm 만들기

우리가 먼저 만들 컴포넌트는 PhoneForm 입니다. 이 컴포넌트에서는 사용자에게서 이름과 전화번호를 입력받을 것입니다. 아직 우리가 input 컴포넌트의 입력을 state 에 담는 방법에 대해선 알아보지 않았었지요? 한번 알아봅시다.

### input 다루기

우선, src 디렉토리 내부에 components 라는 디렉토리를 만드세요. 그리고, 그 안에 PhoneForm.js 라는 파일을 만들어서 다음 코드를 입력하세요.

```javascript
// file: src/components/PhoneForm.js
import React, { Component } from 'react';

class PhoneForm extends Component {
  state = {
    name: ''
  }
  handleChange = (e) => {
    this.setState({
      name: e.target.value
    })
  }
  render() {
    return (
      <form>
        <input
          placeholder="이름"
          value={this.state.name}
          onChange={this.handleChange}
        />
        <div>{this.state.name}</div>
      </form>
    );
  }
}

export default PhoneForm;
```

onChange 이벤트가 발생하면, e.target.value 값을 통하여 이벤트 객체에 담겨있는 현재의 텍스트 값을 읽어올 수 있습니다. 해당 값을 state 의 name 부분으로 설정하세요.
render 부분에서 input 을 렌더링 할 떄에는 value 값과 onChange 값을 넣어주었습니다. onChange 는 input 의 텍스트 값이 바뀔때마다 발생하는 이벤트입니다. 여기에 우리가 만들어둔 handleChange 를 설정했습니다. 그리고, 나중에 우리가 데이터를 등록하고나면 이 name 값을 공백으로 초기화 해줄건데요, 그렇게 초기화 됐을 때 input 에서도 반영이 되도록 value 를 설정해주었습니다.

그리고 그 하단에는 name 값이 잘 바뀌고 있는지 확인 할 수 있도록 값을 렌더링해주었습니다.

자~ 그러면 이 컴포넌트를 App 에서 보여줄게요.

```javascript
// file: src/App.js
import React, { Component } from 'react';
import PhoneForm from './components/PhoneForm';


class App extends Component {
  render() {
    return (
      <div>
        <PhoneForm />
      </div>
    );
  }
}

export default App;
```

![img](https://i.imgur.com/vS7rXOB.png)

결과물이 잘 나타났나요? 한번 여러분들도 input 값을 수정해보세요. 하단에 잘 나오고있나요?

전화번호부에는 전화번호가 들어가야겠지요. input 을 하나 더 추가해주겠습니다. input 이 여러개일때는 어떻게 처리해야할까요? 다음 코드를 살펴보세요.

```javascript
// file: src/components/PhoneForm.js
import React, { Component } from 'react';

class PhoneForm extends Component {
  state = {
    name: '',
    phone: ''
  }
  handleChange = (e) => {
    this.setState({
      [e.target.name]: e.target.value
    });
  }
  render() {
    return (
      <form>
        <input
          placeholder="이름"
          value={this.state.name}
          onChange={this.handleChange}
          name="name"
        />
        <input
          placeholder="전화번호"
          value={this.state.phone}
          onChange={this.handleChange}
          name="phone"
        />
        <div>{this.state.name} {this.state.phone}</div>
      </form>
    );
  }
}

export default PhoneForm;
```

아마 또 다른 이벤트 핸들러 함수를 만들면 되지 않을까? 라고 생각하신 분들도 있을겁니다. 그 방법은 물론 나쁜 방법은 아닙니다만 더 나은 방법이 있습니다.

바로, input 의 name 속성을 사용하는건데요, render 부분에 보시면, 각 input 에 `name` 값을 부여해주었습니다. 이를 통하여 우리는 각 input 을 구분 할 수 있게 됐죠.

이 name 값은, `event.target.name` 을 통해서 조회 할 수 있습니다.

setState 내부에서 사용된 문법은 [Computed property names](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Object_initializer#Computed_property_names) 라는 문법입니다. 혹여나 key 부분에 [ ] 괄호가 사용된 것이 생소하다면 링크를 클릭해보세요.

자, 이제 결과물을 확인해보세요. 두 input이 제대로 작동하나요?

![img](https://i.imgur.com/HoV0QC7.png)

### 부모 컴포넌트에게 정보 전달하기

이제 state 안에 있는 값들을 부모 컴포넌트에게 전달해줄 차례입니다. 이러한 상황에는, 부모 컴포넌트에서 메소드를 만들고, 이 메소드를 자식에게 전달한 다음에 자식 내부에서 호출하는 방식을 사용합니다.

![img](https://i.imgur.com/xKe2v5s.png)

우리는 App 에서 handleCreate 라는 메소드를 만들고, 이를 PhoneForm 한테 전달해주겠습니다. 그리고, PhoneForm 쪽에서 버튼을 만들어서 submit 이 발생하면 props 로 받은 함수를 호출하여 App 에서 파라미터로 받은 값을 사용 할 수 있도록 하겠습니다.

우선 App 을 다음과 같이 수정하세요.

```javascript
// file: src/App.js
import React, { Component } from 'react';
import PhoneForm from './components/PhoneForm';

class App extends Component {
  handleCreate = (data) => {
    console.log(data);
  }
  render() {
    return (
      <div>
        <PhoneForm
          onCreate={this.handleCreate}
        />
      </div>
    );
  }
}

export default App;
```

그 다음엔, PhoneForm 에서 버튼과 onSubmit 이벤트를 설정하겠습니다.

```javascript
// file: src/components/PhoneForm.js
import React, { Component } from 'react';

class PhoneForm extends Component {
  state = {
    name: '',
    phone: ''
  }
  handleChange = (e) => {
    this.setState({
      [e.target.name]: e.target.value
    })
  }
  handleSubmit = (e) => {
    // 페이지 리로딩 방지
    e.preventDefault();
    // 상태값을 onCreate 를 통하여 부모에게 전달
    this.props.onCreate(this.state);
    // 상태 초기화
    this.setState({
      name: '',
      phone: ''
    })
  }
  render() {
    return (
      <form onSubmit={this.handleSubmit}>
        <input
          placeholder="이름"
          value={this.state.name}
          onChange={this.handleChange}
          name="name"
        />
        <input
          placeholder="전화번호"
          value={this.state.phone}
          onChange={this.handleChange}
          name="phone"
        />
        <button type="submit">등록</button>
      </form>
    );
  }
}

export default PhoneForm;
```

handleSubmit 함수를 확인해보세요. 맨 위에 `e.preventDefault()` 라는 함수가 호출됐죠? 이 뜻은, 원래 이벤트가 해야 하는 작업을 방지시킨다는 의미입니다. 원래는 form 에서 submit 이 발생하면 페이지를 다시 불러오게 되는데요, 그렇게 되면 우리가 지니고있는 상태를 다 잃어버리게 되니까 이를 통해서 방지해주었습니다.

그 다음에는, props 로 받은 onCreate 함수를 호출하고, 상태값을 초기화해주었습니다.

render 부분에서는 submit 버튼을 만들고, form 부분에 onSubmit 이벤트를 등록해주었습니다.

코드를 다 작성하셨으면, 제대로 작동하는지 확인해보세요.

![img](https://i.imgur.com/g0Za58l.png)

## 정리

이제 input 은 어떻게 다뤄야 할 지 감을 잡으셨지요? 이제 App 컴포넌트에서 state 내부에 배열을 선언하고, 배열안에 PhoneForm 에서 입력한것들을 집어넣고 배열 내부의 데이터를 렌더링하는 방법을 알아보겠습니다.



## <span style="color:green">7편: 배열 다루기 (1) 생성과 렌더링</span>

이번에는 리액트 프로젝트에서 배열을 다루는 방법을 알아보겠습니다. 리액트에서는 배열을 다룰 때 평상시에 하던것 처럼 하시면 안 됩니다. 데이터 추가의 경우, 자바스크립트에서 배열을 다뤄보신분이라면 그냥 배열에 데이터를 추가할 때, push 를 사용하니까 `this.state.array.push('some value');` 이런식으로 하면 되겠지? 라고 생각하실 수 있는데요, 리액트애서는 state 내부의 값을 직접적으로 수정하면 절대로 안됩니다. 이를 불변성 유지라고 하는데요, push, splice, unshift, pop 같은 내장함수는 배열 자체를 직접 수정하게 되므로 적합하지 않습니다. 그 대신에, 기존의 배열에 기반하여 새 배열을 만들어내는 함수인 concat, slice, map, filter 같은 함수를 사용해야합니다.

리액트에서 불변성 유지가 중요한 이유는 불변성을 유지해야, 리액트에서 모든것들이 필요한 상황에 리렌더링 되도록 설계 할 수 있고, 그렇게 해야 나중에 성능도 최적화 할 수 있기 때문입니다. 이것이 왜 그런건지에 대해서는, 우선 구현을 해보고 나중에 설명을 해드리겠습니다.

## 데이터 추가

우리 애플리케이션의 상태 데이터는 App 컴포넌트 에서 관리하겠습니다. 나중에 가면 상태를 컴포넌트에서 분리하여 따로 관리하는 방법도 알아볼텐데요, 일단은 지금은 리액트 기초에 집중을 해보겠습니다.

App 컴포넌트의 state 에 information 이라는 배열을 만들고, 그 안에 배열의 기본값들인 샘플 데이터 두개를 추가하겠습니다.

각 전화번호 정보는 다음과 같은 형식으로 담겠습니다.

```javascript
{
  id: 0,
  name: '이름',s
  phone: '010-0000-0000'
}
```

여기서 id 값은 각 데이터를 식별하기 위함입니다. 그리고 이 값은 데이터를 추가할때마다 숫자를 1씩 더해주겠습니다.

자, App 코드를 다음과 같이 작성해보세요.

```javascript
// file: src/App.js
import React, { Component } from 'react';
import PhoneForm from './components/PhoneForm';

class App extends Component {
  id = 2
  state = {
    information: [
      {
        id: 0,
        name: '김민준',
        phone: '010-0000-0000'
      },
      {
        id: 1,
        name: '홍길동',
        phone: '010-0000-0001'
      }
    ]
  }
  handleCreate = (data) => {
    const { information } = this.state;
    this.setState({
      information: information.concat({ id: this.id++, ...data })
    })
  }
  render() {
    const { information } = this.state;
    return (
      <div>
        <PhoneForm
          onCreate={this.handleCreate}
        />
        {JSON.stringify(information)}
      </div>
    );
  }
}

export default App;
```

id 값의 경우에는, 컴포넌트의 일반 클래스 내부 변수로서 선언해주었습니다. 컴포넌트 내부에서 필요한 값 중에서, 렌더링 되는것과 상관이 없는것들은 굳이 state 에 넣어줄 필요가 없습니다.

render 함수에서는 information 값을 문자열로 변환하여 보여주었습니다. 잠시 후에는 이 데이터를 컴포넌트 형태로 렌더링해보겠습니다.

일단 코드를 저장해보고 새 데이터를 입력해보세요.

![img](https://i.imgur.com/oBjdSd3.png)

데이터가 잘 나타났나요?

## 데이터 렌더링

자, 이제는 위 배열을 컴포넌트로 변환해서 바꿔주겠습니다. 이 튜토리얼 초반부에서도 언급했지만, 리액트를 다루는건 자바스크립트를 사용하는거랑 매우 비슷합니다. 컴포넌트를 여러개 렌더링 하기 위해서는, 앵귤러 뷰 처럼 디렉티브 같은걸 사용 할 필요 없이, 그냥 자바스크립트 배열의 내장함수인 map 을 사용하면 됩니다.

### map 함수 알아보기

자바스크립트에 익숙한 사람이라면 불필요한 설명일 수도 있겠지만, 그렇지 않은 분들을 위해서 이 함수에 대해서 간단히 알아보겠습니다.

예를들어 다음과 같은 배열이 있다고 가정해봅시다.

```javascript
const a = [1,2,3,4,5];
```

만약에 여러분들이 이 배열을 가지고, 내부에 있는 원소들에 2씩 곱하고 싶다고 가정해봅시다. 어떻게 하실건가요? 자바스크립트의 기초만 알고있다면 아마 이런 방법을 선택 하실 수도 있습니다.

```javascript
const a = [1,2,3,4,5];
const b = [];

b.forEach(number => b.push(number * 2));
```

하지만, forEach 대신에 map 을 사용하시면 조금 더 쉽게 해결 할 수 있습니다.

```javascript
const a = [1,2,3,4,5];
const b = a.map(number => number * 2);
```

어느정도 감이 잡혔나요? 조금 더 자세히 알고 싶다면 MDN 의 [Array.prototype.map()](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/map) 를 읽어보세요.

### 컴포넌트 만들기

우리는 두개의 컴포넌트를 만들겠습니다.

- **PhoneInfo**: 각 전화번호 정보를 보여주는 컴포넌트입니다.
- **PhoneInfoList**: 여러개의 PhoneInfo 컴포넌트들을 보여줍니다.

일단 PhoneInfo 부터 만들어보겠습니다.

```javascript
// file: src/components/PhoneInfo.js
import React, { Component } from 'react';

class PhoneInfo extends Component {
  static defaultProps = {
    info: {
      name: '이름',
      phone: '010-0000-0000',
      id: 0
    }
  }
  
  render() {
    const style = {
      border: '1px solid black',
      padding: '8px',
      margin: '8px'
    };

    const {
      name, phone, id
    } = this.props.info;
    
    return (
      <div style={style}>
        <div><b>{name}</b></div>
        <div>{phone}</div>
      </div>
    );
  }
}

export default PhoneInfo;
```

우리는 info 라는 객체를 props 로 받아와서 렌더링 해줄것입니다. 그런데, 우리가 실수로 info 값을 전달해주는것을 까먹게 된다면 컴포넌트가 크래쉬 될 것입니다. info 가 undefined 일 때에는 비구조화 할당을 통해 내부의 값을 받아올 수 없기 때문입니다.

그렇기 때문에 defaultProps 를 통하여 info 의 기본값을 설정해주었습니다.

그 다음에는, PhoneInfoList 컴포넌트를 만들어봅시다.

```javascript
// src/components/PhoneInfoList.js
import React, { Component } from 'react';
import PhoneInfo from './PhoneInfo';

class PhoneInfoList extends Component {
  static defaultProps = {
    data: []
  }

  render() {
    const { data } = this.props;
    const list = data.map(
      info => (<PhoneInfo key={info.id} info={info}/>)
    );

    return (
      <div>
        {list}    
      </div>
    );
  }
}

export default PhoneInfoList;
```

이 컴포넌트에서는 data 라는 배열을 가져와서 map 을 통하여 JSX 로 변환을 해줍니다. 이 과정에서, key 라는 값도 설정이 되었는데요, 여기서 key 는 리액트에서 배열을 렌더링을 할 때 꼭 필요한 값입니다. 리액트는 배열을 렌더링 할 때 값을 통하여 업데이트 성능을 최적화하는데요, 한번 다음 예시를 살펴보세요.

```javascript
<div>A</div>
<div>B</div>
<div>C</div>
<div>D</div>
```

만약에 key 를 부여하지 않으면, 배열의 index 값이 자동으로 key 로 설정이되는데요, 이 때 여기서 B와 C 사이에 X를 집어넣는다고 가정해봅시다. key 가 배열의 인덱스로 설정된다면 이렇게됩니다.

```javascript
<div key={0}>A</div>
<div key={1}>B</div>
<div key={2}>C</div>
<div key={3}>D</div>
```

배열의 인덱스가 key 값으로 사용됐습니다.

```javascript
<div key={0}>A</div>
<div key={1}>B</div>
<div key={2}>X</div> [C -> X]
<div key={3}>D -> C</div> [D -> C]
<div key={4}>D</div> [새로 생성됨]
```

보시면, 굉장히 비효율적이죠? 사실상 중간에 끼워넣기만 하면 되는건데, 배열의 index 를 key 로 사용하게되어 중간에 값이 들어가면 index 도 함께 바뀌어 버리게 되니, X 아래로 값이 다 바뀌게 되버리죠.

key 를 배열의 index 값으로 사용하는게 아니라, 우리가 데이터를 추가 할 때마다 고정적인 고유 값을 부여해주면, 리액트가 변화를 감지해내고 업데이트를 하게 될 떄 조금 더 똑똑하게 처리 할 수 있게됩니다.

```javascript
<div key={0}>A</div>
<div key={1}>B</div>
<div key={2}>C</div>
<div key={3}>D</div>
```

이 번에, 다시 B 와 C 사이에 다시 X 를 넣어보겠습니다. 이번에는 key 값은 고정된 고유값입니다.

```javascript
<div key={0}>A</div>
<div key={1}>B</div>
<div key={5}>X</div> [새로 생성됨]
<div key={2}>C</div> [유지됨]
<div key={3}>D</div> [유지됨]
```

결국 새로운 DOM 은 하나만 생성되고, 나머지는 그대로 유지됩니다.
key 값은 언제나 고유해야 합니다.

실제 프로젝트를 예를 들자면, 우리가 데이터베이스에 데이터를 추가하면 주로 해당 데이터를 가르키는 고유 id 가 있습니다. 그러한 데이터를 리액트에서 렌더링하게된다면 그 고유 id 를 가지고 key 로 사용하시면 됩니다.

지금 우리의 경우엔 전화번호 정보에서 id 값을 key 값으로 사용해주었습니다.

이제 PhoneInfoList 컴포넌트를 App 에서 렌더링해주세요. 그리고, data 값을 props 로 전달하세요.

```javascript
// file: src/App.js
import React, { Component } from 'react';
import PhoneForm from './components/PhoneForm';
import PhoneInfoList from './components/PhoneInfoList';

class App extends Component {
  id = 2
  state = {
    information: [
      {
        id: 0,
        name: '김민준',
        phone: '010-0000-0000'
      },
      {
        id: 1,
        name: '홍길동',
        phone: '010-0000-0001'
      }
    ]
  }
  handleCreate = (data) => {
    const { information } = this.state;
    this.setState({
      information: information.concat({ id: this.id++, ...data })
    })
  }
  render() {
    return (
      <div>
        <PhoneForm
          onCreate={this.handleCreate}
        />
        <PhoneInfoList data={this.state.information}/>
      </div>
    );
  }
}

export default App;
```

코드를 저장하고, 전화번호 정보들이 잘 나타나는지 확인하세요. 그리고, 새 데이터도 등록해보세요.

![img](https://i.imgur.com/s8ZTqHC.png)

잘 작동했나요?

가끔씩은, 데이터에 고유 값이 없을 수 도 있습니다. 그럴 때에는 만약에 key 값을 빼먹으면 렌더링이 되긴 하지만 개발자도구 콘솔에서 경고창이 뜨게 됩니다. 만약에 그 경고가 보고싶지 않다면 다음과 같이 작업 할 수 있습니다.

```javascript
    const list = data.map(
      (info, index) => (<PhoneInfo key={index} info={info}/>)
    );
```

하지만 기억하세요. 위처럼 하면 단순히 경고만 감출 뿐이고 성능상으로는 key 가 없는 것과 동일합니다.

## 정리

우리는 데이터를 배열에 어떻게 등록을 해야 할 지, 그리고 등록한 데이터를 어떻게 보여줄 지 배워보았습니다. 이번 튜토리얼에서 여러분이 꼭 기억해야 할 점은 배열을 렌더링 하게 될 때에는 꼭 고유값을 key 로 사용해야 한다는 것 입니다. 그리고, 불변성 유지를 위하여 데이터를 조작 할 때에는 기존의 배열을 건들이지 않는 방식으로 해야 하는데, 이 불변성 유지에 대해서는 나중에 더 자세히 알아보겠습니다.

다음 튜토리얼에서는, 우리가 만든 전화번호부에 있는 데이터를 제거도 하고, 수정도 하는 방법을 알아보겠습니다.





## <span style="color:green">8편: 배열 다루기 (2) 제거와 수정</span>

우리는 지난 섹션에서 배열에 데이터를 추가하는 방법과 배열 내부의 내용들을 화면에 보여주는 기능을 구현해보았습니다. 이번에는, 배열 내부의 데이터를 제거하는 방법과 수정을 하는 방법을 알아보겠습니다.

일단 제거부터 시작해볼까요?

## 데이터 제거

기존의 배열 데이터를 건들이지 않으면서 데이터를 제거하기 위해선, 여러가지 방법이 있을 수 있습니다.

컴포넌트에서 직접 구현을 하기 전에, 먼저 예제삼아 일반 자바스크립트 배열을 가지고 연습을 해보겠습니다.

```javascript
const arr = [1, 2, 3, 4, 5];
```

배열에서 3을 제거 할건데요, 기존의 배열은 그대로 유지하고 새 배열을 만들어서 3을 제외시키겠습니다.

첫번째 방법은 slice 와 concat 을 이용하는겁니다. 3 왼쪽의 배열과 그 우측의 배열을 서로 합쳐주는 것이죠.

```javascript
array.slice(0,2).concat(array.slice(3,5)) // [1, 2, 4, 5]
```

배열 전개 연산자를 사용하면 다음과 같이 구현을 할 수도 있습니다.

```javascript
[ ...array.slice(0,2), ...array.slice(3,5) ];
```

하지만 이것보다 훨씬 간단한 방법으로도 구현 할 수 있습니다. 우리는 단순히 값이 3인걸 없애는 것이죠?

배열에는 [filter](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/filter) 라는 내장함수가 있는데, 이 함수는 특정 조건에 부합되는 원소들만 뽑아내서 새 배열을 만들어줍니다.

따라서, 3이 제외된 배열을 만들기 위해서 이러한 코드를 작성 할 수도 있지요.

```javascript
array.filter(num => num !== 3); // [1, 2, 4, 5]
```

이렇게 하면, 3이 아닌 것들만 필터링을 해서 새 배열을 보여주겠죠?

그럼, 동일한 방식으로, 전화번호정보를 데이터에서 제외시키는 기능을 구현해보겠습니다.

id 를 파라미터로 받아오는 handleRemove 라는 함수를 만드시고, PhoneInfoList 로 전달하세요.

```javascript
// file: src/App.js
import React, { Component } from 'react';
import PhoneForm from './components/PhoneForm';
import PhoneInfoList from './components/PhoneInfoList';

class App extends Component {
  id = 2
  state = {
    information: [
      {
        id: 0,
        name: '김민준',
        phone: '010-0000-0000'
      },
      {
        id: 1,
        name: '홍길동',
        phone: '010-0000-0001'
      }
    ]
  }
  handleCreate = (data) => {
    const { information } = this.state;
    this.setState({
      information: information.concat({ id: this.id++, ...data })
    })
  }
  handleRemove = (id) => {
    const { information } = this.state;
    this.setState({
      information: information.filter(info => info.id !== id)
    })
  }
  render() {
    const { information } = this.state;
    return (
      <div>
        <PhoneForm
          onCreate={this.handleCreate}
        />
        <PhoneInfoList 
          data={information}
          onRemove={this.handleRemove}
        />
      </div>
    );
  }
}

export default App;
```

PhoneInfoList 에서는 props 로 전달받은 onRemove 를 그대로 전달해주겠습니다. 이 함수가 전달되지 않았을 경우를 대비하여 해당 props 를 위한 defaultProps 도 설정하세요.

```javascript
// file: src/components/PhoneInfoList.js
import React, { Component } from 'react';
import PhoneInfo from './PhoneInfo';

class PhoneInfoList extends Component {
  static defaultProps = {
    list: [],
    onRemove: () => console.warn('onRemove not defined'),
  }

  render() {
    const { data, onRemove } = this.props;
    const list = data.map(
      info => (
        <PhoneInfo
          key={info.id}
          info={info}
          onRemove={onRemove}
        />)
    );

    return (
      <div>
        {list}    
      </div>
    );
  }
}

export default PhoneInfoList;
```

그 다음에는, PhoneInfo 쪽에서 삭제 기능을 구현해주겠습니다. 우리는 삭제 버튼을 만들어서 해당 버튼에 이벤트를 설정하겠습니다.

```javascript
import React, { Component } from 'react';

class PhoneInfo extends Component {
  static defaultProps = {
    info: {
      name: '이름',
      phone: '010-0000-0000',
      id: 0
    },
  }

  handleRemove = () => {
    // 삭제 버튼이 클릭되면 onRemove 에 id 넣어서 호출
    const { info, onRemove } = this.props;
    onRemove(info.id);
  }

  render() {
    const style = {
      border: '1px solid black',
      padding: '8px',
      margin: '8px'
    };

    const {
      name, phone
    } = this.props.info;
    
    return (
      <div style={style}>
        <div><b>{name}</b></div>
        <div>{phone}</div>
        <button onClick={this.handleRemove}>삭제</button>
      </div>
    );
  }
}

export default PhoneInfo;
```

![img](https://i.imgur.com/d9NXB0D.png)

삭제 버튼을 눌러보세요. 데이터가 제대로 제거 되나요?

## 데이터 수정

이번엔 데이터 수정을 해보겠습니다. 수정할때도 마찬가지로 불변성을 지켜줘야합니다. 기존의 배열과, 그리고 그 내부에있는 객체를 절대로 직접적으로 수정하시면 안됩니다.

예를 들어서 다음과 같은 객체로 이뤄진 배열이 있다고 가정해봅시다.

```javascript
const array = [
  { id: 0, text: 'hello', tag: 'a' },
  { id: 1, text: 'world' , tag: 'b' },
  { id: 2, text: 'bye', tag: 'c' }
];
```

여기서 기존의 값을 건들이지 않고 id 가 1인 객체의 text 값을 ‘Korea’ 라는 값으로 바꾼 새로운 배열을 만들어보겠습니다.

```javascript
const modifiedArray = array.map(item => item.id === 1
  ? ({ ...item,. text: 'Korea' }) // id 가 일치하면 새 객체를 만들고, 기존의 내용을 집어넣고 원하는 값 덮어쓰기
  : item // 바꿀 필요 없는것들은 그냥 기존 값 사용
```

그러면 한번, 같은 원리를 사용하여 우리의 전화번호 정보를 수정해보겠습니다.

우리는 handleUpdate 라는 함수를 만들건데요, 이 함수는 id 와 data 라는 파라미터를 받아와서 필요한 정보를 업데이트 해줍니다.
이 handleUpdate 는 PhoneInfoList 의 onUpdate 로 전달해주세요.

```javascript
// file: src/App.js
import React, { Component } from 'react';
import PhoneForm from './components/PhoneForm';
import PhoneInfoList from './components/PhoneInfoList';

class App extends Component {
  id = 2
  state = {
    information: [
      {
        id: 0,
        name: '김민준',
        phone: '010-0000-0000'
      },
      {
        id: 1,
        name: '홍길동',
        phone: '010-0000-0001'
      }
    ]
  }
  handleCreate = (data) => {
    const { information } = this.state;
    this.setState({
      information: information.concat({ id: this.id++, ...data })
    })
  }
  handleRemove = (id) => {
    const { information } = this.state;
    this.setState({
      information: information.filter(info => info.id !== id)
    })
  }
  handleUpdate = (id, data) => {
    const { information } = this.state;
    this.setState({
      information: information.map(
        info => id === info.id
          ? { ...info, ...data } // 새 객체를 만들어서 기존의 값과 전달받은 data 을 덮어씀
          : info // 기존의 값을 그대로 유지
      )
    })
  }
  render() {
    const { information } = this.state;
    return (
      <div>
        <PhoneForm
          onCreate={this.handleCreate}
        />
        <PhoneInfoList 
          data={information}
          onRemove={this.handleRemove}
          onUpdate={this.handleUpdate}
        />
      </div>
    );
  }
}

export default App;
```

그럼 이제 PhoneInfoList 컴포넌트를 업데이트 해줘야 하겠죠?

```javascript
// file: src/components/PhoneInfoList.js
import React, { Component } from 'react';
import PhoneInfo from './PhoneInfo';

class PhoneInfoList extends Component {
  static defaultProps = {
    data: [],
    onRemove: () => console.warn('onRemove not defined'),
    onUpdate: () => console.warn('onUpdate not defined'),
  }

  render() {
    const { data, onRemove, onUpdate } = this.props;
    const list = data.map(
      info => (
        <PhoneInfo
          key={info.id}
          info={info}
          onRemove={onRemove}
          onUpdate={onUpdate}
        />)
    );

    return (
      <div>
        {list}    
      </div>
    );
  }
}

export default PhoneInfoList;
```

그리고, 데이터를 컴포넌트로 렌더링하는 과정에서 PhoneInfo 에 onUpdate 를 그대로 전달해주었습니다.

그럼 이젠 PhoneInfo 컴포넌트를 업데이트 해줄 차례입니다. 이번엔 수정할 코드는 꽤 많은데요, 주석을 읽어가면서 코드를 작성해주세요.

```javascript
import React, { Component } from 'react';

class PhoneInfo extends Component {
  static defaultProps = {
    info: {
      name: '이름',
      phone: '010-0000-0000',
      id: 0
    },
  }

  state = {
    // 우리는 수정 버튼을 눌렀을 떄 editing 값을 true 로 설정해줄것입니다.
    // 이 값이 true 일 때에는, 기존에 텍스트 형태로 보여주던 값들을
    // input 형태로 보여주게 됩니다.
    editing: false,
    // input 의 값은 유동적이겠지요? input 값을 담기 위해서 각 필드를 위한 값도
    // 설정합니다
    name: '',
    phone: '',
  }

  handleRemove = () => {
    // 삭제 버튼이 클릭되면 onRemove 에 id 넣어서 호출
    const { info, onRemove } = this.props;
    onRemove(info.id);
  }

  // editing 값을 반전시키는 함수입니다
  // true -> false, false -> true
  handleToggleEdit = () => {
    const { editing } = this.state;
    this.setState({ editing: !editing });
  }

  // input 에서 onChange 이벤트가 발생 될 때
  // 호출되는 함수입니다
  handleChange = (e) => {
    const { name, value } = e.target;
    this.setState({
      [name]: value
    });
  }


  componentDidUpdate(prevProps, prevState) {
    // 여기서는, editing 값이 바뀔 때 처리 할 로직이 적혀있습니다.
    // 수정을 눌렀을땐, 기존의 값이 input에 나타나고,
    // 수정을 적용할땐, input 의 값들을 부모한테 전달해줍니다.

    const { info, onUpdate } = this.props;
    if(!prevState.editing && this.state.editing) {
      // editing 값이 false -> true 로 전환 될 때
      // info 의 값을 state 에 넣어준다
      this.setState({
        name: info.name,
        phone: info.phone
      })
    }

    if (prevState.editing && !this.state.editing) {
      // editing 값이 true -> false 로 전환 될 때
      onUpdate(info.id, {
        name: this.state.name,
        phone: this.state.phone
      });
    }
  }
  
  render() {
    const style = {
      border: '1px solid black',
      padding: '8px',
      margin: '8px'
    };

    const { editing } = this.state;

    
    if (editing) { // 수정모드
      return (
        <div style={style}>
          <div>
            <input
              value={this.state.name}
              name="name"
              placeholder="이름"
              onChange={this.handleChange}
            />
          </div>
          <div>
            <input
              value={this.state.phone}
              name="phone"
              placeholder="전화번호"
              onChange={this.handleChange}
            />
          </div>
          <button onClick={this.handleToggleEdit}>적용</button>
          <button onClick={this.handleRemove}>삭제</button>
        </div>
      );
    }


    // 일반모드
    const {
      name, phone
    } = this.props.info;
    
    return (
      <div style={style}>
        <div><b>{name}</b></div>
        <div>{phone}</div>
        <button onClick={this.handleToggleEdit}>수정</button>
        <button onClick={this.handleRemove}>삭제</button>
      </div>
    );
  }
}

export default PhoneInfo;
```

코드를 다 작성하셨다면, 결과물이 다음과 같이 나타나는지 확인해보세요.
![img](https://i.imgur.com/OUjqcTt.png)

수정이 잘 되나요?

## 정리

이제 리액트 state 에 있는 배열 안의 데이터를 삭제하는 방법과, 수정하는 방법도 배워보았습니다. 작업을 하시면서, 왜 배열과 객체 값을 직접 수정하면 안되고 불변성을 유지하면서 데이터를 새로 생성하는 방식으로 교체해줘야 하는지에 궁금하실 수도 있습니다.

그것에 대해선, 다음 섹션에서 이름으로 전화번호를 찾는 기능을 구현하면서, 불변성을 왜 유지해야 하는지 알아보겠습니다.



## <span style="color:green">9편: 불변성을 지키는 이유와 업데이트 최적화</span>

우리는 지난 섹션에서 배열을 어떻게 다뤄야 하는지에 대해서 알아보았습니다. 데이터를 업데이트하는 과정에서 불변성을 지켜야한다는것을 강조했었는데요, 왜 그렇게 해야하는지 알아보겠습니다.

## 데이터 필터링 구현하기

우선, 불변성의 중요성을 알아보는 과정에서 이름으로 전화번호를 찾는 데이터 필터링 기능을 구현해보겠습니다.

먼저 App 컴포너트에서 input 하나를 렌더링하고 해당 input 의 값을 state 의 keyword 라는 값에 담겠습니다. 이를 위해서 이벤트 핸들러도 만들어줘야겠지요?

```javascript
// file: src/App.js
import React, { Component } from 'react';
import PhoneForm from './components/PhoneForm';
import PhoneInfoList from './components/PhoneInfoList';

class App extends Component {
  id = 2
  state = {
    information: [
      {
        id: 0,
        name: '김민준',
        phone: '010-0000-0000'
      },
      {
        id: 1,
        name: '홍길동',
        phone: '010-0000-0001'
      }
    ],
    keyword: ''
  }
  handleChange = (e) => {
    this.setState({
      keyword: e.target.value,
    });
  }
  handleCreate = (data) => {
    const { information } = this.state;
    this.setState({
      information: information.concat({ id: this.id++, ...data })
    })
  }
  handleRemove = (id) => {
    const { information } = this.state;
    this.setState({
      information: information.filter(info => info.id !== id)
    })
  }
  handleUpdate = (id, data) => {
    const { information } = this.state;
    this.setState({
      information: information.map(
        info => id === info.id
          ? { ...info, ...data } // 새 객체를 만들어서 기존의 값과 전달받은 data 을 덮어씀
          : info // 기존의 값을 그대로 렌더링
      )
    })
  }
  render() {
    const { information, keyword } = this.state;

    return (
      <div>
        <PhoneForm
          onCreate={this.handleCreate}
        />
        <p>
          <input 
            placeholder="검색 할 이름을 입력하세요.." 
            onChange={this.handleChange}
            value={keyword}
          />
        </p>
        <hr />
        <PhoneInfoList 
          data={information}
          onRemove={this.handleRemove}
          onUpdate={this.handleUpdate}
        />
      </div>
    );
  }
}

export default App;
```

![img](https://i.imgur.com/7uwRCJ0.png)

검색어를 입력했을 때 필터링을 하는것은 나중에 구현하도록 하겠습니다. 지금의 상황에선, input 에 입력을 했을때 업데이트가 필요한것은 오직 input 뿐입니다.

하지만, App 컴포넌트의 상태가 업데이트 되면, 컴포넌트의 리렌더링이 발생하게 되고, 컴포넌트가 리렌더링되면 그 컴포넌트의 자식 컴포넌트도 리렌더링됩니다.

한번 확인을 해볼까요? PhoneInfoList 컴포넌트에서 render 함수의 상단에 다음 코드를 넣어보세요.

```javascript
// file: src/components/PhoneInfoList.js
...
  render() {
    console.log('render PhoneInfoList');
    const { data, onRemove, onUpdate } = this.props;
    const list = data.map(
      info => (
        <PhoneInfo
          key={info.id}
          info={info}
          onRemove={onRemove}
          onUpdate={onUpdate}
        />)
    );

    return (
      <div>
        {list}    
      </div>
    );
  }
...
```

이렇게 하고 검색어 input 을 수정한다음에 콘솔을 확인해봅시다.

![img](https://i.imgur.com/VCMXJ3t.png)

App 이 리렌더링됨에 따라 PhoneInfoList 도 리렌더링이 되고 있죠. 물론, 실제로 변화가 일어나진 않으니 지금은 Virtual DOM 에만 리렌더링 합니다. 지금의 상황에는 별로 큰 문제가 되지 않는데, 리스트 내부의 아이템이 몇백개, 몇천개가 된다면 이렇게 Virtual DOM 에 렌더링 하는 자원은 아낄 수 있으면 아끼는게 좋습니다.

이러한 낭비되는 자원을 아끼기 위해선 우리가 이전에 배웠던 shouldComponentUpdate LifeCycle API 를 사용하면 됩니다.

자, PhoneInfoList 에서 shouldComponentUpdate 를 구현해보세요.

그냥 단순히 다음 받아올 data 가 현재 data 랑 다른 배열일 때 true 로 설정하게 하면 됩니다.

```javascript
import React, { Component } from 'react';
import PhoneInfo from './PhoneInfo';

class PhoneInfoList extends Component {
  static defaultProps = {
    data: [],
    onRemove: () => console.warn('onRemove not defined'),
    onUpdate: () => console.warn('onUpdate not defined'),
  }

  shouldComponentUpdate(nextProps, nextState) {
    return nextProps.data !== this.props.data;
  }
  

  render() {
    console.log('render PhoneInfoList');
    const { data, onRemove, onUpdate } = this.props;
    const list = data.map(
      info => (
        <PhoneInfo
          key={info.id}
          info={info}
          onRemove={onRemove}
          onUpdate={onUpdate}
        />)
    );

    return (
      <div>
        {list}    
      </div>
    );
  }
}

export default PhoneInfoList;
```

![img](https://i.imgur.com/UL4lWeP.png)

그러면 이제 변화가 필요하지 않을 때는 render 함수가 호출되지 않게 됩니다.

우리는 shouldComponentUpdate 로직을 굉장히 간단하게 작성해주었는데 어떻게 이런게 가능 한 것일까요?

### 불변성에 대해 알아보자.

그 이유는, 우리가 불변성을 지켜줬기 때문입니다.

만약에 우리가 배열을 직접 건들여서 수정해줬다고 가정해봅시다..
그럴때는 이렇게 !== 하나로 비교를 끝낼수가 없습니다.

```javascript
const array = [1,2,3,4];
const sameArray = array;
sameArray.push(5);

console.log(array !== sameArray); // false
```

우리가 sameArray = array 를 했다고 해서 기존에 있던 배열이 복사되는것이 아니라 똑같은 배열을 가르키고 있는 레퍼런스가 하나 만들어진 것이기 때문에, 우리가 sameArray 에 push 를 하게 된다고 해서 array 와 sameArray 가 달라지지 않습니다.

하지만, 우리가 불변성을 유지하면

```javascript
const array = [1,2,3,4];
const differentArray = [...array, 5];
  // 혹은 = array.concat(5)
console.log(array !== differentArray); // true
```

위 코드와 같이 바로바로 비교가 가능하다는 것이죠.

이는 객체를 다룰때도 마찬가지입니다.

```javascript
// NO
const object = {
  foo: 'hello',
  bar: 'world'
};
const sameObject = object;
sameObject.baz = 'bye';
console.log(sameObject !== object); // false
// YES
const object = {
  foo: 'hello',
  bar: 'world'
};
const differentObject = {
  ...object,
  baz: 'bye'
};
console.log(differentObject !== object); // true
```

### 기능 마저 구현하기

그러면, 구현하던 기능을 마저 끝내보겠습니다.

App 컴포넌트에서 keyword 값에 따라서 information 배열을 필터링 해주는 로직을 작성하고, 필터링된 결과를 PhoneInfoList 에 전달해주겠습니다.

```javascript
// file: src/App.js
import React, { Component } from 'react';
import PhoneForm from './components/PhoneForm';
import PhoneInfoList from './components/PhoneInfoList';

class App extends Component {
  id = 2
  state = {
    information: [
      {
        id: 0,
        name: '김민준',
        phone: '010-0000-0000'
      },
      {
        id: 1,
        name: '홍길동',
        phone: '010-0000-0001'
      }
    ],
    keyword: ''
  }
  handleChange = (e) => {
    this.setState({
      keyword: e.target.value,
    });
  }
  handleCreate = (data) => {
    const { information } = this.state;
    this.setState({
      information: information.concat({ id: this.id++, ...data })
    })
  }
  handleRemove = (id) => {
    const { information } = this.state;
    this.setState({
      information: information.filter(info => info.id !== id)
    })
  }
  handleUpdate = (id, data) => {
    const { information } = this.state;
    this.setState({
      information: information.map(
        info => id === info.id
          ? { ...info, ...data } // 새 객체를 만들어서 기존의 값과 전달받은 data 을 덮어씀
          : info // 기존의 값을 그대로 렌더링
      )
    })
  }
  render() {
    const { information, keyword } = this.state;
    const filteredList = information.filter(
      info => info.name.indexOf(keyword) !== -1
    );
    return (
      <div>
        <PhoneForm
          onCreate={this.handleCreate}
        />
        <p>
          <input 
            placeholder="검색 할 이름을 입력하세요.." 
            onChange={this.handleChange}
            value={keyword}
          />
        </p>
        <hr />
        <PhoneInfoList 
          data={filteredList}
          onRemove={this.handleRemove}
          onUpdate={this.handleUpdate}
        />
      </div>
    );
  }
}

export default App;
```

![img](https://i.imgur.com/7F5b48c.png)

필터링이 잘 돼었나요? 참고로, 지금 상황에서는 키워드 값에 따라 PhoneInfoList 가 전달받는 data 가 다르므로, 키워드 값이 바뀌면 shouldComponentUpdate 도 true 를 반환하게 됩니다.

### 계속해서 최적화

자, 이번에는 PhoneInfo 컴포넌트도 최적화해주겠습니다.

PhoneInfo 컴포넌트의 render 함수 상단에 다음 코드를 넣어보세요.

```javascript
  render() {
    console.log('render PhoneInfo ' + this.props.info.id);
```

그 다음에, 새 데이터를 등록하고나서 개발자 콘솔을 확인해보세요.

![img](https://i.imgur.com/M8wuhQJ.png)

보면 처음 렌더링이 됐을 때 0과 1이 렌더링됐습니다. 그 다음에, 새 데이터가 나타났을때 사실상 맨마지막 데이터만 새로 렌더링해주면 되는데, 그 위에 있는 컴포넌트도 렌더링되었는데요, 이것도 아까전에 다뤘던것과 마찬가지로 실제로 바뀌지 않는 컴포넌트들은 DOM 변화가 일어나지는 않겠지만, Virtual DOM 에 그리는 자원도 아껴주기 위해서 우리는 shouldComponentUpdate 를 통하여 최적화 해줄 수 있습니다.

```javascript
// file: src/components/PhoneInfo.js
  shouldComponentUpdate(nextProps, nextState) {
    // 수정 상태가 아니고, info 값이 같다면 리렌더링 안함
    if (!this.state.editing  
        && !nextState.editing
        && nextProps.info === this.props.info) {
      return false;
    }
    // 나머지 경우엔 리렌더링함
    return true;
  }
...
```

![img](https://i.imgur.com/inv8ezU.png)

낭비 렌더링이 사라졌지요?

## 정리

축하합니다! 여러분은 리액트의 기본 사용법부터 활용법까지 모두 배웠습니다. 다음 섹션에서는, 앞으로 여러분들이 무엇을 더 배워야 할 지에 대해서 다뤄보겠습니다.



## <span style="color:green">10편: 앞으로의 공부 방향</span>

리액트는 따지고보면 정말 간단한 라이브러리입니다. 지금까지 공부해본것들을 요약해보자면..

1. 재사용 가능한 컴포넌트를 만듭니다.
2. props 는 부모에게서 전달받는 값입니다.
3. state 는 자기 자신이 지니고 있는 데이터입니다.
4. props 나 state 가 바뀌면 컴포넌트는 리렌더링 합니다.
5. LifeCycle API 를 통해서 컴포넌트 마운트, 업데이트, 언마운트 전후로 처리 할 로직을 설정하거나 리렌더링을 막아줄수도 있습니다.

이제 우리가 배운것들을 통해서 앞으로 여러분들은 정말 멋진 프로젝트들을 만들어낼 수 있을 것 입니다.

이번 섹션은 누구든지 하는 리액트의 마지막 편인데요, 이번엔 앞으로 여러분들이 멋진 프로젝트를 만들어가기 위해서 어떤 것들을 더 공부해야 할 지 다뤄보겠습니다. 새로 배워야 할 것들 중에서는 제가 이미 정리해둔 것들도 있으니, 유용할만한 블로그 포스트들의 링크도 남겨두겠습니다.

## 스타일링

리액트 컴포넌트를 스타일링 하는 방법은 여러가지 입니다. 일단, 가장 기본적인 방법으로는 일반 .css 파일을 만들어서 사용하는 것 입니다. [React 기초 입문 프로젝트 – 흔하디 흔한 할 일 목록 만들기](https://velopert.com/3480) 에서는 우리가 이번 튜토리얼에서 했던 것 과 비슷한 난이도이며, CSS 로 스타일링을 하면서 할 일 목록 프로젝트를 만들게 됩니다.

또 다른 방법은 Sass 를 사용하는 것 입니다. [리액트 컴포넌트 스타일링, API 연동 실습 – NASA 에서 오늘의 우주 사진 가져오기](https://velopert.com/3503) 에서는 Sass 와, CSS Module 을 사용하여 프로젝트를 만들게 되며, HTTP 요청 라이브러리인 axios 로 NASA 의 오픈 API 를 요청하는 방법을 다뤄보게됩니다.

이 외에도, LESS 나 stylus 같은걸 사용하셔도 되고, 또는 js 내부에 스타일링을 바로 하는 방법인 [styled-components](https://github.com/styled-components/styled-components) 같은것을 사용하는 방법도 있습니다. styled-components 의 경우엔 [리액트 컴포넌트 스타일링 – CSS Module / Sass / styled-components](https://velopert.com/3447) 에서도 다루게 되니 한번 참고해보시면 도움이 될 수도 있습니다.

## 상태관리

이번 전화번호부 프로젝트는 비교적 소규모 프로젝트였기 때문에 상태관리 하는 과정이 그렇게 복잡하지 않았습니다. App >> PhoneInfoList >> PhoneInfo 이런식으로 데이터를 쭉 내려주는 방식으로 작동했었죠. 하지만, 프로젝트가 복잡해졌을 때를 가정해봅시다. 그렇게 된다면, App 컴포넌트에서 사용하는 state 가 매우 복잡해지고 이를 업데이트 하는 로직도 굉장히 복잡해지겠죠.

이를 조금 더 체계적으로, 그리고 편하게 상태관리를 하기 위한 라이브러리들도 존재합니다. 대표적으로 [Redux](https://github.com/reactjs/redux) 와 [MobX](https://github.com/mobxjs/mobx) 가 있는데요, 리덕스의 경우엔 [리덕스(Redux)를 왜 쓸까? 그리고 리덕스를 편하게 사용하기 위한 발악 (i)](https://velopert.com/3528) 에서 자세하게 공부해볼 수 있습니다.

## 불변성 유지

불변성을 유지하는건, 그렇게 어려운것 까지는 아니지만… 데이터의 깊이가 깊어지면 귀찮아지기 마련입니다. 불변성 유지 관련 라이브러리로는 대표적으로 [Immutable.js](https://facebook.github.io/immutable-js/) 가 있고, 그리고 올해들어 새로 만들어진 [Immer](https://github.com/mweststrate/immer) 라는 라이브러리가있습니다. Immutable.js 의 경우 [React ❤️ Immutable.js – 리액트의 불변함, 그리고 컴포넌트에서 Immutable.js 사용하기](https://velopert.com/3486) 에서 기초부터 활용방법까지 배워보실 수 있습니다.

## 라우팅

주소에 따라 다른 뷰를 보여줄 라이브러리도 필요하죠. 물론 직접 구현할수도 있겠지만, 오픈소스를 사용하는것이 더 안정적이고 효율적입니다. 지금 리액트 생태계에서 주요 라우터는 두 종류가 있는데요, 하나는 [react-router](https://github.com/ReactTraining/react-router) 입니다. 또 다른 라우터는 [Next.js](https://github.com/zeit/next.js/) 인데요, 이건 서버사이드 렌더링까지 매우 편하게 해주는 프레임워크 입니다. [리액트 라우터, 코드 스플리팅, 그리고 서버사이드 렌더링](https://velopert.com/3411) 에서는 리액트 라우터 기초부터 리액트 프로젝트 코드 스플리팅까지 배워보실 수 있으니 참고하세요.

## 테스팅

조금 더 탄탄한 코드를 작성하고, 여러분의 코드에 조금 더 자신감을 갖기 위해서 리액트 프로젝트에 테스팅을 하고 싶을 수도 있습니다. 테스트 관련해서도 많은 도구가 있는데요, [Jest, Enzyme 을 통한 리액트 컴포넌트 유닛 테스팅](https://velopert.com/3587) 에서는 테스트의 기초와, Jest 와 Enzyme 이라는 도구를 사용해서 컴포넌트 테스팅을 하는 방법을 다룹니다.

## 타입 시스템

조금 더 체계적인 코드를 작성하고 싶다면 리액트 프로젝트에 타입 시스템을 적용하고 싶을 수도 있습니다. 이는 두가지로 나뉘어질 수 있는데, 첫번째 방법은 TypeScript 를 사용하는 것 입니다. 이에 대해선 [TypeScript with React + Redux/Immutable.js 빠르게 배우기](https://velopert.com/3595) 에서 다룹니다. 또는 페이스북에서 만든 [Flow](https://flow.org/en/docs/frameworks/react/) 도 좋은 솔루션입니다 (이 도구에 대한 포스트는 조만간 올라올 예정입니다.)

## 가장 중요한것, 프로젝트 진행하기

아무리 많은것을 배워봤자, 여러분들이 프로젝트를 만들지 않으면 쓸모가 없습니다. 그래서 정말 강조해서 말씀드리고 싶습니다. 만들고싶은 프로젝트를 만들기 시작하면서, 여러분의 프로젝트에 필요하게 될 것들을 하나하나 공부해보세요! 자연스레 실력을 쌓을 수 있을 것 입니다. 이에 대해선 제가 장담합니다. 저도 이렇게 하면서 개발 공부를 했었으니까요. 경험담을 말씀드려보자면 프로젝트를 하나하나 완성할때마다 점프를 하는 느낌이였습니다. 프로젝트를 하나 만들고, 그 프로젝트에서 내가 잘한 것, 그리고 못한 것에대해서 정리해보고, 고칠건 고치고 유지할건 유지해가면 점점 더 성숙한 프로젝트를 만들어가게 될 수 있을 것입니다.

## 오프라인 강의

그리고 깨알같은 광고를 하자면 저는 패스트캠퍼스에서 [오프라인 강의](http://www.fastcampus.co.kr/dev_camp_react/) 를 하고 있습니다. 10주동안, 이 강의에선 위에서 다룬 내용들을 모두 다루게 되며, 다양한 실무 노하우와, 추가적으로 여러분들이 웹 개발을 하는데 도움이 될 수 있도록 백엔드 지식도 충분히 다루게 됩니다. 약 3개월마다 새로운 강의 기수가 시작되니, 제대로 공부해보고싶고, 기회가 된다면 한번 수강해보시는것을 추천드립니다.



