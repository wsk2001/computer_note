# 파일 시스템 보안 소개

출처: https://docs.microsoft.com/en-us/windows-hardware/drivers/ifs/introduction-to-file-systems-security



WDK를 사용하는 파일 시스템 개발자는 파일 시스템을 구현하는 동안 보안 고려 사항을 알고 있어야 합니다. 파일 시스템 필터 드라이버 개발자도 이러한 문제를 알고 있어야 하며 보안 고려 사항을 제품에 통합하기 위해 Microsoft Windows 보안 인터페이스에 익숙해야 합니다.

이 섹션에서는 Windows 보안 및 파일 시스템에 중점을 둡니다. Windows용 보안 확장을 개발하려는 사람이나 Windows 환경 내에서 Windows가 아닌 보안 모델을 구현하려는 파일 시스템 개발자를 위한 입문서가 아닙니다.

이 섹션에는 여러 코드 샘플이 포함되어 있습니다. 샘플은 실제 코드에서 추출되지만 여기에는 축약된 형식으로 표시됩니다. 개발자는 특정 환경에서 사용하기 위해 이러한 샘플을 조정해야 합니다.





## 일반적인 드라이버 보안 문제

### 드라이버 보안이란

드라이버와 관련하여 시스템이 충돌하거나 사용할 수 없게 되는 방식으로 드라이버가 오작동하도록 하는 사용자가 할 수 있는 모든 것은 보안 결함입니다. 대부분의 개발자가 드라이버에서 작업할 때 그들의 초점은 드라이버가 제대로 작동하도록 하는 것이지 악의적인 침입자가 시스템 내의 허점을 악용할 것인지 여부가 아닙니다. 작성하기에 가장 복잡한 유형의 드라이버인 파일 시스템 및 파일 시스템 필터 드라이버의 경우에는 더욱 그렇습니다.

그러나 제품 출시 후 보안 취약점을 조사하고 식별하려는 사용자가 있습니다. 따라서 개발자는 이러한 구멍이 존재할 가능성을 최소화하기 위해 설계 및 구현 단계에서 이러한 문제를 고려하는 것이 좋습니다. 목표는 출시된 제품의 일부가 되기 전에 가능한 한 많은 보안 허점을 제거하는 것입니다.

보안 드라이버를 달성하려면 설계자(드라이버에 대한 잠재적 위협을 의식적으로 생각), 구현자(공격의 소스가 될 수 있는 일반적인 작업을 방어적으로 코딩) 및 테스트 팀(공격을 사전에 찾으려고 시도)의 협력이 필요합니다. 이러한 모든 활동을 적절하게 조정함으로써 운전자의 보안이 크게 향상됩니다.



### 보안 위협 모델을 사용한 설계

#### 보안 위협 모델

보안을 고려할 때 일반적인 방법론은 가능한 공격 유형을 설명하는 특정 위협 모델을 만드는 것입니다. 이 기술은 개발자가 드라이버에 대한 잠재적인 공격 벡터를 고려하도록 하기 때문에 파일 시스템 또는 파일 시스템 필터 드라이버를 설계할 때 유용합니다. 잠재적인 위협을 식별한 드라이버 개발자는 드라이버 구성 요소의 전체 보안을 강화하기 위해 이러한 위협에 대한 방어 수단을 고려할 수 있습니다.

보안 위협 모델을 고려할 때 드라이버가 사용자 I/O 요청을 대신하여 관리하는 작업(보안 검사 대상)과 드라이버 자체에 의해 시작된 I/O 작업(기본적으로 적용되지 않음)을 구별하는 것도 중요합니다. 보안 검사). 한 드라이버에 대한 사용자 모드 요청은 내부 FSCTL 또는 IOCTL 요청(예: Srv.sys 드라이버)을 통해 다른 드라이버로 전달되어 이러한 문제를 더욱 복잡하게 만들 수도 있습니다.

커널 모드 드라이버 개발자의 경우 다음과 같은 중요한 문제를 고려해야 합니다.

- 드라이버가 시작한 I/O 작업은 로컬 시스템의 보안 검사를 우회합니다.
- 드라이버에 의해 시작된 I/O 작업은 대부분의 매개변수 유효성 검사를 우회합니다.
- 드라이버는 신뢰할 수 있는 컴퓨팅 기반의 일부이므로 전체 시스템을 제어할 수 있습니다.

예를 들어 시스템에 드라이버를 성공적으로 로드할 수 있었던 불량 프로그램을 상상해 보십시오. 이것은 엄청난 제어를 제공하고 본질적으로 시스템을 손상시킬 것입니다. 응용 프로그램이 드라이버의 기능을 악용하여 동일한 결과를 얻을 수 있다면 응용 프로그램에 제어권을 넘겨주고 시스템을 손상시킨 것입니다.

Microsoft는 보안을 고려할 때 "STRIDE" 모델을 사용합니다.

- S-- [신원 스푸핑](https://docs.microsoft.com/en-us/windows-hardware/drivers/ifs/spoofing-identity) .
- T-- [데이터 변조](https://docs.microsoft.com/en-us/windows-hardware/drivers/ifs/tampering-with-data) .
- R-- [부인](https://docs.microsoft.com/en-us/windows-hardware/drivers/ifs/repudiation) .
- I-- [정보 공개](https://docs.microsoft.com/en-us/windows-hardware/drivers/ifs/information-disclosure) .
- D-- [서비스 거부](https://docs.microsoft.com/en-us/windows-hardware/drivers/ifs/denial-of-service) .
- E-- [권한 상승](https://docs.microsoft.com/en-us/windows-hardware/drivers/ifs/elevation-of-privilege) .

여기에서 기본 원칙은 발생할 수 있는 특정 유형의 시스템 손상을 식별합니다. 이러한 원칙 중 일부는 일반적으로 드라이버에 유효하지만 모두 파일 시스템 및 파일 시스템 필터 드라이버에 유효합니다.

#### 신원 스푸핑

스푸핑 ID의 개념은 권한이 없는 코드가 다른 사람의 ID를 사용하여 보안 자격 증명을 사용할 수 있도록 하는 것입니다. 예를 들어, 어떤 형태의 암호 메커니즘을 사용하는 드라이버는 이러한 유형의 공격을 받을 수 있습니다. 이러한 드라이버가 모두 보안 결함이 있는 것은 아니지만 스푸핑 ID를 기반으로 하는 보안 결함에 취약합니다. 드라이버의 설계자와 구현자는 취약성 수준을 평가해야 합니다.

신원 스푸핑의 다른 더 미묘한 예가 있습니다. 예를 들어 암호 해독 키를 위해 스마트 카드에 의존하는 암호화 필터 드라이버는 스마트 카드를 분실하거나 도난당한 경우 물리적 스푸핑 공격을 받을 수 있습니다. 따라서 필터 드라이버는 이러한 공격 범주로부터 보호하기 위해 생체 인식 확인 또는 암호와 같은 몇 가지 추가 요구 사항을 추가할 수 있습니다.

자체 보안 검사를 수행하려는 드리이버는 보안 검사 중에 적절한 자격 증명을 사용하도록 특히 주의해야 합니다. 그렇게 하지 않으면 보안 설명자가 정확하기 때문에 이를 발견한 악의적인 사용자가 다른 사람이 수행한 것처럼 보이는 작업을 수행할 수 있는 스푸핑 악용을 쉽게 제공할 수 있습니다.

일반적으로 드라이버는 자체적으로 구성하기보다 운영 체제 내의 기존 보안 메커니즘을 활용하는 경우 가장 잘 설계되고 구현됩니다. 이렇게 하면 구현에 오류가 포함될 수 있는 잠재적 위치의 수가 최소화됩니다.



#### 데이터 변조

데이터 변조는 드라이버에 대한 위협이지만 파일 시스템 및 파일 시스템 필터 드라이버에 대한 심각한 위협입니다. 모든 드라이버에 대해 사용자 모드 구성 요소와 커널 모드 구성 요소 간에 공유되는 제어 구조가 커널 모드 구성 요소에서 사용 중인 동안 사용자 모드 구성 요소에 의해 수정될 수 있는 잠재적인 위협이 있습니다. 파일 시스템 및 필터 드라이버는 가상 주소를 통해 사용자 버퍼에 직접 액세스하는 METHOD_NEITHER 데이터 전송 유형에 크게 의존하기 때문에 이러한 유형의 공격에 특히 취약합니다. 또한 빠른 I/O는 원시 사용자 모드 버퍼에 직접 액세스합니다. 여기서 위험은 응용 프로그램이 데이터를 수정하는 동안 드라이버가 이 데이터를 사용할 수 있다는 것입니다. 일반적으로 드라이버는 데이터의 유효성을 검사하여 이에 대한 보호를 시도합니다. 하지만,

파일 시스템 및 파일 시스템 필터 드라이버의 경우 사용자 모드 응용 프로그램과 다양한 커널 모드 드라이버 간에 정보를 전송하는 데 사용되는 수많은 IOCTL 및 FSCTL 작업이 있습니다. 또한 이러한 드라이버가 사용자 모드 서비스와 커널 모드 드라이버 간에 제어 및 데이터 정보를 전송하는 개인 IOCTL 및 FSCTL 작업을 갖는 것은 매우 일반적입니다.

이 디자인 모델에는 드라이버의 서비스나 애플리케이션만이 인터페이스를 이용할 것이라는 가정이 내재되어 있습니다. 이러한 설계 및 구현은 다음과 같은 이유로 위험합니다.

악의적인 응용 프로그램은 드라이버에 유효한 버퍼를 보낸 다음 드라이버의 약점을 조사하고 찾기 위해 데이터를 수정할 수 있습니다.

제어 응용 프로그램 내에서 오류가 발생하면 제어 버퍼의 데이터 내용이 유효하지 않게 될 수 있습니다. 예를 들어, 예외가 제어 흐름을 변경하고 스택 영역을 재사용하는 경우 스택 기반 제어 영역이 무효화될 수 있습니다.

이러한 범주의 문제로부터 보호하려면 구현 측면에서 지속적인 주의가 필요합니다. 버퍼는 유효성을 검사하기 전에 비휘발성 메모리(커널 전용 또는 읽기 전용 메모리)에 있어야 합니다. 버퍼에 다른 버퍼나 제어 구조에 대한 참조가 포함되어 있으면 유효성이 검사되기 전에 비휘발성 메모리에 있어야 합니다.

또한 개발자는 FastIoDeviceControl 디스패치를 사용하는 IOCTL이 원시 사용자 버퍼의 데이터를 전달한다는 사실을 알고 있어야 합니다. 따라서 IOCTL용 고속 I/O 버전을 구현하는 드라이버는 문제를 방지하기 위해 적절한 조치를 취해야 합니다.

데이터를 검증하는 것만으로는 충분하지 않습니다. 예를 들어, ProbeForWrite 에 대한 성공적인 호출 은 버퍼가 유효함을 나타낼 수 있지만 애플리케이션 주소 공간의 후속 변경으로 인해 해당 상태가 변경될 수 있습니다. 예를 들어, 드라이버가 실제로 버퍼를 직접 사용하기 전에 애플리케이션이 종료될 수 있습니다. 따라서 드라이버는 응용 프로그램의 주소 공간 내 변경 사항에 대해 보호해야 합니다. 일반적으로 이것은 사용자 버퍼 주소에 직접 액세스하는 모든 코드 주변에서 __try 및 __except 를 사용하여 구조화된 예외 처리를 사용하여 수행 됩니다.



#### 부인

부인의 개념은 사용자가 특정 작업을 수행한 다음 나중에 수행한 것을 부인할 수 있다는 것입니다. 대부분의 드라이버에게 이것은 특이한 유형의 문제입니다. 그러나 파일 시스템의 경우 로깅은 작업(예: 중요한 파일 삭제)을 추적하고 작업의 명확한 흔적이 있는지 확인하는 데 사용됩니다. 이는 그러한 거부를 방지하기 위한 메커니즘을 제공합니다.

또한 운영 체제는 개체의 소유권을 특정 보안 식별자에 할당할 수 있습니다. <span style="color:red">특정 개체의 소유권을 추적할 수 있도록 적절한 권한( **SeTakeOwnershipPrivilege** ) 없이 소유권 정보를 변경할 수 없습니다 .</span>  객체 소유권은 거부에 대한 또 다른 형태의 보호를 제공합니다.



#### 정보 공개

드라이버의 경우 정보 공개는 일반적으로 잘못된 버퍼 처리를 통해 애플리케이션에 정보를 노출하는 것과 관련이 있습니다. 예를 들어, 버퍼링된 I/O 요청이 있는 드라이버는 일반적으로 *IOStatus* 블록 구조 의 **정보** 멤버를 설정하여 반환되는 데이터의 양을 나타냅니다. 그런 다음 I/O 관리자는 해당 정보를 사용하여 결과를 애플리케이션의 버퍼에 다시 복사합니다.

*드라이버가 더 많은 데이터가 반환되고 있다고 표시하면 I/O 관리자는 SystemBuffer* 에서 추가 데이터를 복사합니다 . *그러나 드라이버가 SystemBuffer* 의 잔액을 채우지 않으면 해당 메모리에 있던 것이 애플리케이션으로 다시 반환되어 잠재적으로 민감한 데이터가 애플리케이션에 노출될 수 있습니다. 사용된 데이터 버퍼가 지워지지 않았기 때문에 추가 정보가 다른 시스템으로 전송될 수 있는 네트워크 드라이버 문제를 확인하십시오. 예를 들어 ICMP ping 응답에는 추가 정보가 포함될 수 있습니다. 실수로 데이터를 노출하는 이 문제는 매우 현실적이며 다양한 시스템에서 발생합니다.

파일 시스템 또는 파일 시스템 필터 드라이버의 경우 데이터 액세스가 허용되지 않아야 하는 사용자에게 파일 정보를 공개할 위험이 추가됩니다. 이 작업은 여러 가지 방법으로 수행할 수 있습니다.

- [**ZwCreateFile**](https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/ntifs/nf-ntifs-ntcreatefile) 을 사용하여 파일을 연 다음 중간 핸들을 통해 데이터에 대한 액세스를 제공 하는 필터 드라이버 . **ZwCreateFile** 함수 는 기본적으로 파일을 열고 요청이 커널 모드에서 오기 때문에 보안 검사를 우회합니다. 따라서 이 핸들을 사용하여 액세스하면 일반적으로 응용 프로그램에서 사용할 수 없는 정보가 공개될 수 있습니다.

  필터 드라이버가 노출되어서는 안 되는 데이터를 노출하지 않도록 액세스 검사를 시행하려는 경우 필터 드라이버는 [**ZwCreateFile**](https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/ntifs/nf-ntifs-ntcreatefile) 함수 의 *ObjectAttributes* 매개변수에 OBJ_FORCE_ACCESS_CHECK를 지정해야 합니다.

- 커널 모드(액세스 검사 우회)에서 핸들을 열지만 OBJ_KERNEL_HANDLE을 지정하지 않는 필터 드라이버. 따라서 생성된 핸들은 현재 프로세스의 핸들 테이블에 배치됩니다. 데이터에 대한 전체 액세스 권한이 있는 이 핸들은 사용자 모드에서 볼 수 있습니다. 불량 애플리케이션은 이러한 핸들을 감시하고 이를 사용하여 데이터에 액세스하려고 할 수 있습니다.

- IRP_MJ_CREATE 요청을 게시한 다음 시스템 작업자 스레드의 컨텍스트에서 처리하는 파일 시스템 또는 파일 시스템 필터 드라이버입니다. IRP가 시스템 작업자 스레드에 의해 처리되면 일반적으로 시스템 스레드의 권한을 사용하여 생성 작업이 완료됩니다. 따라서 이러한 시스템 권한을 사용하여 액세스하면 일반적으로 응용 프로그램에서 사용할 수 없는 정보가 공개될 수 있습니다.

- 호출 프로세스가 지정된 데이터에 대한 액세스를 허용해야 하는지 확인하지 않고 파일 개체 기반 I/O를 수행하는 파일 시스템 또는 파일 시스템 필터 드라이버입니다.

정보를 관리하고 보호하는 고유한 역할 때문에 파일 시스템과 파일 시스템 필터 드라이버는 정보 보호에 특히 주의를 기울여야 합니다.





#### 서비스 거부

서비스 거부는 특정 서비스에 대한 액세스가 허용되어야 했지만 실제로는 부적절하게 거부된 경우 발생합니다. 예를 들어, 시스템을 사용할 수 없게 만드는 권한 없는 응용 프로그램이 수행할 수 있는 모든 작업은 사실상 서비스 거부입니다. 여기에는 다음과 같은 모든 작업 또는 작업 시퀀스가 포함됩니다.

시스템을 충돌시킵니다.

스레드 또는 프로세스의 조기 종료를 유발합니다.

교착 상태를 만듭니다. 교착 상태는 두 개 이상의 스레드가 영구적인 교착 상태에서 대기를 중지할 때 발생합니다. 각 스레드는 다른 스레드 중 하나가 보유한 리소스를 기다리고 있습니다.

라이브 잠금 조건을 생성합니다. 라이브 잠금은 두 개 이상의 프로세서가 리소스 획득(일반적으로 큐에 대한 잠금)을 기다리고 있고 해당 리소스를 소유하는 스레드가 유사한 진행되지 않는 상태에 있기 때문에 진행할 수 없을 때 발생할 수 있습니다.

이러한 문제는 일반 응용 프로그램에서 악용할 수 있는 잠재적인 버그가 포함되어 있기 때문에 드라이버 내에서 자주 발생합니다. 이러한 유형의 익스플로잇은 간단하고 보호하기 어려울 수 있습니다. 드라이버에서 이러한 문제의 일반적인 원인은 다음과 같습니다.

부적절한 사용자 버퍼 유효성 검사.

버퍼 오버플로 또는 언더플로.

파일 시스템 및 파일 시스템 필터 드라이버의 경우 이러한 문제가 많이 발생합니다. 예를 들어, MAX_PATH 값은 Win32 하위 시스템의 역사적 이유로 260으로 정의됩니다. 많은 드라이버 구성 요소는 이것이 가장 큰 경로의 크기를 나타내는 것으로 가정합니다. 불행히도 NTFS 파일 시스템의 최대 경로는 32,767 유니코드 문자(65,534바이트)이므로 그렇지 않습니다. 필터 드라이버가 MAX_PATH 길이 가정을 코드 기반으로 인코딩하는 경우 필터 드라이버가 관리하는 경로 내에서 이보다 큰 경로를 생성하는 애플리케이션에서 간단한 서비스 거부 공격이 발생합니다.

또 다른 일반적인 문제는 응용 프로그램이 종종 개인 FSCTL 요청에 사용자 모드 포인터를 포함한다는 것입니다. 파일 시스템은 서비스 거부 공격의 세 가지 범주에 속합니다.

사용 가능한 모든 디스크 공간을 사용합니다.

사용 가능한 모든 디스크 대역폭을 사용합니다.

사용자가 액세스해야 하는 파일에 대한 액세스를 차단합니다.

일반적으로 파일 시스템 개발자가 이러한 유형의 공격을 방지하기 위해 할 수 있는 일은 거의 없습니다. 그러나 관리자가 이러한 유형의 서비스 거부 공격을 제한할 수 있도록 개발자가 취할 수 있는 단계가 있습니다.

파일 시스템과 관련된 가장 간단한 서비스 거부 공격은 사용 가능한 디스크 공간을 모두 사용하는 것입니다. 이를 수행하는 애플리케이션을 작성하는 것은 간단하며 그 결과는 광범위합니다. 시스템의 많은 응용 프로그램과 서비스는 더 이상 디스크에 쓸 수 없는 경우 작동하지 않습니다. 완화 기술은 디스크 할당량으로, 관리자가 적절하게 사용할 때 사용자가 소유한 파일에 사용할 수 있는 디스크 공간을 제한할 수 있습니다. 따라서 파일 시스템을 개발할 때 디스크 할당량에 대한 지원을 포함하는 것이 좋습니다.

악의적이거나 잘못 작성된 응용 프로그램이 모든 디스크 대역폭을 사용하려고 할 수도 있습니다. 이러한 유형의 공격을 받는 일반 사용자는 시스템이 느려지거나 응답하지 않습니다. 현재 운영 체제에는 응용 프로그램에서 사용하는 대역폭을 조절하는 메커니즘이 없습니다. 파일 시스템은 또한 열려 있는 각 파일 개체 및 파일 핸들에 대해 커널 메모리를 사용합니다. 악성 응용 프로그램은 많은 수의 파일을 계속 열어 메모리가 소진될 때까지 파일을 열어 두려고 할 수 있습니다. 이러한 문제에 대한 주요 완화 기술은 관리자가 많은 양의 I/O를 수행하거나 많은 양의 다른 리소스를 사용하는 응용 프로그램에 대해 컴퓨터를 모니터링할 수 있도록 하는 감사 및 로깅입니다. 다시,

악성 응용 프로그램은 다른 사용자가 정상적인 사용에 필요한 파일에 액세스하지 못하도록 차단할 수 있습니다. 이러한 문제를 최소화하기 위한 중요한 전략은 파일 시스템을 개발할 때 파일 개체와 관련된 보안 정보가 제대로 구현되도록 하는 것입니다.

마지막으로 모든 드라이버는 악의적이거나 비정상적인 응용 프로그램의 요청에 대한 응답으로 사용 가능한 모든 메모리 또는 기타 리소스를 소비하는 것에 대해 우려해야 합니다.



#### 권한 상승

권한 상승은 응용 프로그램이 사용할 수 없어야 하는 권한(gains rights)이나 권한(privileges )을 얻을 때 발생합니다. 많은 권한 상승 익스플로잇은 다른 위협에 대한 익스플로잇과 유사합니다. 예를 들어, 실행 코드 작성을 교묘하게 시도하는 버퍼 오버런 공격. 이것은 버퍼가 스택에서 로컬 변수로 할당될 때 x86 기반 아키텍처에서 작동합니다. 스택에는 현재 프로시저 호출의 반환 주소도 포함되어 있습니다. 악의적인 개발자가 버퍼 오버플로 가능성이 있음을 확인하면 데이터가 버퍼에 저장되어 반환 주소를 덮어쓸 수 있습니다. CPU가 "ret" 명령을 실행하여 이전 호출자로 돌아가면 실제 호출자가 아닌 악의적인 개발자가 지정한 위치로 제어를 반환합니다.

파일 시스템 및 파일 시스템 필터 드라이버의 경우 다음과 같은 이유로 인해 권한 상승 공격의 가능성이 상당히 높습니다.

- 파일 시스템 및 파일 시스템 필터 드라이버는 권한을 포함하여 데이터에 대한 액세스를 관리하는 데 적극적으로 관여합니다.
- 파일 시스템 및 파일 시스템 필터 드라이버는 기능을 구현하기 위해 특수 권한과 액세스 권한을 이용합니다.
- 많은 운영 체제 권한은 파일 시스템과 직접적으로 관련되어 있습니다( 예를 들어 디렉토리 탐색 기능을 제어하는 **SeChangeNotifyPrivilege** ).

이러한 유형의 악용은 파일 시스템을 구현하는 사람들에게 가장 중요합니다. 이 악용은 정상적인 파일 시스템 보안 작업을 우회하거나 우회할 수 있는 데이터 저장소(예: 암호화 필터)를 적극적으로 관리하는 파일 시스템 필터 드라이버에 문제가 될 수 있습니다.



### 보안 위협을 최소화하기 위한 파일 시스템 구현

보안 위협을 야기하는 구현 문제는 다음과 같은 일반적인 문제로 분류됩니다.

- Buffer handling.
- Authentication and identification.
- Access control.
- Handle management.

이러한 문제 중 어느 것도 특별히 새로운 것은 아닙니다. 이러한 문제는 잘 알려져 있지만 이러한 문제는 드라이버에서 다시 발생합니다. 문제의 일부는 대부분의 기존 개발 도구가 사용자에게 이러한 유형의 문제를 경고하거나 완화하지 않는다는 것입니다. 그러나 신중한 방어 개발 기술을 사용하면 이러한 문제의 대부분을 제거할 수 있습니다.

이 섹션에는 다음 항목이 포함됩니다.

[버퍼 처리](https://docs.microsoft.com/en-us/windows-hardware/drivers/ifs/buffer-handling)

[인증 및 식별](https://docs.microsoft.com/en-us/windows-hardware/drivers/ifs/authentication-and-identification)

[액세스 제어](https://docs.microsoft.com/en-us/windows-hardware/drivers/ifs/access-control)

[핸들 관리](https://docs.microsoft.com/en-us/windows-hardware/drivers/ifs/handle-management)



#### 버퍼 처리

아마도 모든 드라이버에서 가장 흔한 오류는 버퍼가 유효하지 않거나 너무 작은 버퍼 처리와 관련이 있습니다. 이러한 오류로 인해 버퍼 오버플로가 발생하거나 시스템 충돌이 발생하여 시스템의 보안이 손상될 수 있습니다.

드라이버의 관점에서 버퍼는 두 가지 종류 중 하나로 제공됩니다.

메모리에 상주하거나 상주하지 않을 수 있는 페이징된 버퍼.

메모리에 상주해야 하는 비페이징 버퍼.

물론 유효하지 않은 주소는 페이징되거나 비페이징되지 않지만 운영 체제가 버퍼와 같은 페이지 오류를 해결하기 위해 작업을 시작함에 따라 잘못된 주소를 "표준" 주소 범위(페이징된 커널 주소, 페이징되지 않은 커널 주소 또는 사용자 주소) 적절한 유형의 오류를 발생시킵니다. 버퍼 오류는 항상 버그 검사(예: PAGE_FAULT_IN_NONPAGED_AREA) 또는 예외(예: STATUS_ACCESS_VIOLATION)에 의해 처리됩니다. 버그 체크의 경우 시스템이 작동을 중지합니다. 예외의 경우 스택 기반 예외 핸들러가 호출되고, 예외를 처리하는 핸들러가 없으면 버그 검사가 호출됩니다.

그럼에도 불구하고, 드라이버가 버그 검사를 하도록 하는 응용 프로그램에 의해 호출될 수 있는 모든 액세스 경로는 드라이버 내의 보안 위반입니다. 이를 통해 애플리케이션이 전체 시스템에 서비스 거부 공격을 일으킬 수 있습니다.

이 영역에서 가장 일반적인 문제 중 하나는 드라이버 작성자가 운영 환경에 대해 너무 많이 가정한다는 것입니다. 여기에는 다음이 포함될 수 있습니다.

주소에 상위 비트가 설정되어 있는지 확인합니다. 이것은 시스템이 Boot.ini 파일에서 /3GB 옵션을 설정하여 4기가바이트 튜닝(4GT)을 사용하는 x86 기반 컴퓨터에서는 작동하지 않습니다. 이 경우 사용자 모드 주소는 주소 공간의 세 번째 기가바이트(GB)에 대해 상위 비트를 설정합니다.

ProbeForRead 및 ProbeForWrite 를 사용 하여 주소를 확인합니다. 이렇게 하면 주소가 프로브 시점에 유효한 사용자 모드 주소인지 확인할 수 있지만 프로브 작업 후에 유효한 상태를 유지해야 하는 것은 아닙니다. 따라서 이 기술은 주기적으로 재현할 수 없는 충돌을 일으킬 수 있는 미묘한 경쟁 조건을 도입합니다. ProbeForRead 및 ProbeForWrite 호출은 다른 이유로 필요합니다. 주소가 사용자 모드 주소인지 여부와 버퍼 길이가 사용자 주소 범위 내에 있는지 확인하기 위함입니다. 프로브가 생략되면 사용자는 유효한 커널 모드 주소를 전달할 수 있습니다. 이 주소는 __try 및 __except 블록(구조적 예외 처리)에 의해 포착되지 않고 큰 보안 허점을 엽니다. 그래서ProbeForRead 및 ProbeForWrite 호출은 정렬을 보장하고 사용자 모드 주소와 길이가 사용자 주소 범위 내에 있는지 확인하는 데 필요합니다. 그러나 액세스를 방지하려면 __try 및 __except 블록이 필요합니다.

ProbeForRead 는 메모리 주소가 유효한지 여부가 아니라 주소와 길이가 가능한 사용자 모드 주소 범위(예: 4GT가 없는 시스템의 경우 2GB 미만) 내에 있는지만 확인합니다 . 대조적으로 ProbeForWrite 는 지정된 길이의 각 페이지에서 첫 번째 바이트에 액세스하여 이것이 유효한 메모리 주소인지 확인합니다.

메모리 관리자 기능( 예: MmIsAddressValid )에 의존하여 주소가 유효한지 확인합니다. 프로브 기능과 마찬가지로, 이는 재생 불가능한 충돌로 이어질 수 있는 경쟁 조건을 도입합니다.

구조적 예외 처리를 사용하지 못했습니다. 컴파일러 내의 __try 및 __except 함수는 예외 처리를 위해 운영 체제 수준 지원을 사용합니다. 커널 수준의 예외는 ExRaiseStatus 또는 관련 함수 중 하나를 호출하여 다시 발생합니다. 예외를 일으킬 수 있는 호출에 대해 구조적 예외 처리를 사용하지 않는 드라이버는 버그 검사(일반적으로 KMODE_EXCEPTION_NOT_HANDLED)로 이어집니다.

오류가 발생하지 않을 것으로 예상되는 코드 주변에서 구조적 예외 처리를 사용하는 것은 실수입니다. 그렇지 않으면 발견될 실제 버그를 마스킹합니다. __try 및 __except 래퍼를 루틴의 최상위 디스패치 수준에 두는 것은 이 문제에 대한 올바른 해결책이 아니지만 때때로 드라이버 작성자가 시도하는 반사 솔루션입니다.

안정적으로 남아 있는 사용자 메모리의 내용에 의존. 예를 들어, 드라이버가 사용자 모드 메모리 위치에 값을 쓰고 나중에 동일한 루틴에서 해당 메모리 위치를 참조한다고 가정합니다. 악의적인 응용 프로그램은 해당 메모리를 적극적으로 수정하여 드라이버를 충돌시킬 수 있습니다.

파일 시스템의 경우 이러한 문제는 일반적으로 사용자 버퍼(METHOD_NEITHER 전송 방법)에 직접 액세스하는 데 의존하기 때문에 특히 심각합니다. 이러한 드라이버는 사용자 버퍼를 직접 조작하므로 운영 체제 수준 충돌을 피하기 위해 버퍼 처리를 위한 예방적 방법을 통합해야 합니다. 빠른 I/O는 항상 원시 메모리 포인터를 전달하므로 드라이버는 빠른 I/O가 지원되는 경우 유사한 문제로부터 보호해야 합니다.

WDK에는 다음을 포함하여 FASTFAT 및 CDFS 파일 시스템 샘플 코드에 버퍼 유효성 검사의 다양한 예가 포함되어 있습니다.

fastfat\deviosup.c 의 FatLockUserBuffer 함수는 MmProbeAndLockPages 를 사용 하여 사용자 버퍼 뒤의 물리적 페이지를 잠그고 FatMapUserBuffer 의 MmGetSystemAddressForMdlSafe 를 사용하여 잠긴 페이지에 대한 가상 매핑을 만듭니다.

fastfat\fsctl.c 의 FatGetVolumeBitmap 함수는 ProbeForRead 및 ProbeForWrite 를 사용하여 조각 모음 API에서 사용자 버퍼의 유효성을 검사합니다.

cdfs\read.c 의 CdCommonRead 함수는 __try 및 __except 코드를 사용하여 사용자 버퍼를 0으로 만듭니다. CdCommonRead 의 샘플 코드 는 try 및 except 키워드를 사용하는 것으로 보입니다. WDK 환경에서 C의 이러한 키워드는 컴파일러 확장 __try 및 __except로 정의됩니다. C++ 코드를 사용하는 사람은 __try가 C++ 키워드이지만 C 키워드가 아니며 커널 드라이버에 유효하지 않은 C++ 예외 처리 형식을 제공하므로 예외를 적절하게 처리하기 위해 네이티브 컴파일러 유형을 사용해야 합니다.



#### 인증 및 식별

대부분의 드라이버는 인증 또는 식별 문제에 관여하지 않으므로 이 작업은 개별 서비스에 맡겨집니다. 드라이버가 인증 또는 식별 처리에 관여할 수 있는 한 가지 경우는 액세스 관리입니다. 이 경우 인증 단계는 일반적으로 보안 참조 모니터에 대한 호출을 통해 처리됩니다. 인증 및 식별 정보는 일반적으로 주어진 스레드 또는 프로세스에 대한 보안 자격 증명을 캡슐화하는 내부 데이터 구조인 보안 토큰에 의해 운영 체제에서 추적합니다.



#### 드라이버의 접근 제어

부적절한 액세스로부터 자신을 보호하기 위해 대부분의 드라이버는 장치 개체에 대해 I/O 관리자가 적용하는 기본 액세스 제어에 의존합니다. 드라이버는 다른 메커니즘을 사용할 수 있습니다. 아마도 일반 드라이버에 대한 가장 간단한 방법은 드라이버를 설치할 때 명시적 보안 설명자를 적용하는 것입니다. 장치 개체에 보안 설명자를 적용하는 예는 이후 섹션에서 설명합니다.

자체 보안 정책을 구현하는 드라이버는 보안 액세스 관리를 지원하기 위해 표준 Windows API에 의존할 수 있습니다. 이 경우 드라이버는 보안 설명자의 저장소를 관리하고 보안을 확인하기 위해 보안 참조 모니터 루틴을 호출하는 책임이 있습니다. 여기에는 다음과 같은 수많은 루틴이 포함됩니다.

- [**SeAccessCheck**](https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nf-wdm-seaccesscheck) --이 루틴은 보안 설명자를 호출자의 보안 자격 증명과 비교합니다.
- [**SePrivilegeCheck**](https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/ntifs/nf-ntifs-seprivilegecheck) --이 루틴은 호출자에 대해 주어진 권한이 활성화되었는지 여부를 결정합니다.
- [**SeSinglePrivilegeCheck**](https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/ntddk/nf-ntddk-sesingleprivilegecheck) --이 루틴은 호출자에 대해 특정 권한이 활성화되어 있는지 확인합니다.
- [**SeAuditingFileOrGlobalEvents**](https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/ntifs/nf-ntifs-seauditingfileorglobalevents) --이 루틴은 시스템이 감사를 활성화했는지 여부를 나타냅니다.
- [**SeOpenObjectAuditAlarm**](https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/ntifs/nf-ntifs-seopenobjectauditalarm) --이 루틴은 열린 개체 이벤트를 감사합니다.

이 목록은 불완전하지만 액세스 유효성 검사를 수행하기 위해 드라이버 내에서 사용할 수 있는 여러 주요 기능을 설명합니다.



#### 핸들 관리

드라이버 내 보안 문제의 중요한 원인은 사용자 모드와 커널 모드 구성 요소 간에 전달되는 핸들의 사용입니다. 다음을 포함하여 커널 환경 내에서 핸들 사용과 관련하여 알려진 문제가 많이 있습니다.

- 커널 드라이버에 잘못된 유형의 핸들을 전달하는 응용 프로그램입니다. 파일 개체가 필요한 이벤트 개체를 사용하려고 하면 커널 드라이버가 충돌할 수 있습니다.
- 필요한 액세스 권한이 없는 개체에 핸들을 전달하는 응용 프로그램입니다. 커널 드라이버는 사용자에게 적절한 권한이 없더라도 커널 모드에서 호출이 이루어지기 때문에 작동하는 작업을 수행할 수 있습니다.
- 주소 공간에서 유효한 핸들이 아니지만 시스템에 대해 악의적인 작업을 수행하기 위해 시스템 핸들로 표시된 값을 전달하는 응용 프로그램입니다.
- 장치 개체에 대한 적절한 핸들이 아닌 값을 전달하는 응용 프로그램(이 드라이버가 생성하지 않은 핸들).

이러한 문제를 방지하려면 커널 드라이버에 전달된 핸들이 유효한지 확인하기 위해 특히 주의해야 합니다. 가장 안전한 정책은 드라이버 컨텍스트 내에서 필요한 핸들을 만드는 것입니다. 커널 드라이버에 의해 생성된 이러한 핸들은 OBJ_KERNEL_HANDLE 옵션을 지정해야 합니다. 이 옵션은 임의의 프로세스 컨텍스트에서 유효한 핸들과 커널 모드 호출자에서만 액세스할 수 있는 핸들을 생성합니다.

응용 프로그램에서 만든 핸들을 사용하는 드라이버의 경우 이러한 핸들을 사용할 때는 각별히 주의해야 합니다.

- [**가장 좋은 방법은 ObReferenceObjectByHandle**](https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nf-wdm-obreferenceobjectbyhandle) 을 호출하여 핸들을 개체 포인터로 변환하고 IoFileObjectType 또는 ExEventObjectType과 같은 올바른 *AccessMode* (일반적으로 Irp->RequestorMode에서), *DesiredAccess* 및 *ObjectType 매개변수를 지정하는 것입니다.*
- 핸들을 호출 내에서 직접 사용해야 하는 경우 함수의 Zw 변형보다는 Nt 변형 함수를 사용하는 것이 가장 좋습니다. 이전 모드는 **UserMode** 이므로 신뢰할 수 없으므로 매개변수 검사를 시행하고 운영 체제의 유효성 검사를 처리합니다. 포인터인 Nt 함수에 전달된 매개변수는 이전 모드가 **UserMode** 인 경우 유효성 검사에 실패할 수 있습니다 . Nt 및 Zw 루틴 은 오류를 확인해야 하는 오류 정보 와 함께 *IoStatusBlock 매개변수를 반환합니다.*
- 필요에 따라 __try 및 __except를 사용하여 오류도 적절하게 트랩해야 합니다. 많은 캐시 관리자(Cc), 메모리 관리자(Mm) 및 파일 시스템 런타임 라이브러리 루틴(FsRtl)은 오류가 발생하면 예외를 발생시킵니다.

어떤 드라이버도 적절한 예방 조치 없이 사용자 모드 응용 프로그램에서 전달된 핸들이나 매개변수에 의존해서는 안 됩니다.

Nt 변형이 파일을 여는 데 사용되는 경우 Nt 변형도 파일을 닫는 데 사용해야 합니다.



### 보안 테스트

출처: https://docs.microsoft.com/en-us/windows-hardware/drivers/ifs/testing-for-security

보안 테스트는 자동화된 프로세스가 아닙니다. 오히려 기존 도구의 사용과 주어진 동인에 대한 철저한 위협 분석을 결합합니다. 따라서 드라이버 테스트는 여러 단계로 구성됩니다.

- 드라이버가 사용되는 환경 내에서 발생할 수 있는 공격 유형을 능동적으로 식별하기 위한 철저한 위협 분석. 예를 들어, 고도로 통제된 환경에 존재하는 동인은 임의 공격의 대상이 되는 대량 배포 동인보다 위협 분석이 더 간단할 수 있습니다.
- 장치 제어 공격 테스트 유틸리티인 Device Path Exerciser와 같은 WDK의 "Designed for Windows" 로고 테스트를 포함한 기존 도구를 사용한 테스트. WDK의 IFS 테스트는 저장소 스택 문제를 철저히 테스트하는 데에도 사용해야 합니다.
- 위협 분석의 일부로 식별된 특정 테스트 시나리오에 대한 일반적인 드라이버 개발의 일부로 추가 테스트를 개발해야 합니다. 이러한 테스트는 일반적으로 드라이버에 고유하며 특정 드라이버를 조사하려고 시도합니다.

이상적으로는 테스트 목적을 위해 검증 테스트 개발에는 소프트웨어의 원래 설계자로부터의 입력뿐만 아니라 개발 중인 특정 유형의 파일 시스템 또는 파일 시스템 필터 드라이버 제품에 익숙한 관련 없는 개발 리소스 및 한 명 이상의 사람이 포함됩니다. 보안 침입 분석 및 예방에 익숙합니다.



## 파일 시스템을 위한 보안 기능

출처: https://docs.microsoft.com/en-us/windows-hardware/drivers/ifs/security-features-for-file-systems

대부분의 다른 유형의 드라이버와 달리 파일 시스템은 일반적인 보안 처리와 밀접하게 관련되어 있습니다. 이는 보안의 특성과 Microsoft Windows 내에서 구현되기 때문입니다. 일반 Windows 보안 모델은 보안 설명자를 개체(이 경우 FILE_OBJECT)와 연결합니다. Windows 보안을 지원하는 파일 시스템은 보안 설명자의 저장 및 검색을 담당합니다. 또한 파일 시스템은 표준 커널 모드 드라이버의 일반적인 범위를 벗어나는 몇 가지 다른 특수 보안 고려 사항을 처리하는 역할을 합니다.

이 섹션에서는 Windows 보안을 지원하기 위해 파일 시스템에 추가할 수 있는 주요 기능에 대해 설명합니다. 이들 중 어느 것도 필수 사항은 아니며 이러한 인터페이스를 사용하지 않고 파일 시스템을 구성할 수 없습니다. 또한, 다른 보안 기능은 무시하면서 일부 보안 기능을 구현할 수 있습니다. 이는 파일 시스템 구현에만 해당됩니다.

이 섹션에는 다음 항목이 포함됩니다.

[보안 설명자](https://docs.microsoft.com/en-us/windows-hardware/drivers/ifs/security-descriptors)

[특권](https://docs.microsoft.com/en-us/windows-hardware/drivers/ifs/privileges)

[감사](https://docs.microsoft.com/en-us/windows-hardware/drivers/ifs/auditing)

[커널 확장 속성](https://docs.microsoft.com/en-us/windows-hardware/drivers/ifs/kernel-extended-attributes)



