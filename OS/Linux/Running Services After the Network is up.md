# Running Services After the Network is up

출처: https://www.freedesktop.org/wiki/Software/systemd/NetworkTarget/

본 문서는 네트워크 가동 후 서비스를 실행 하기 위한 방법을 기술 합니다.

등록된 서비스중 서비스 시작시 network 을 이용하여 다른 서버로 부터 정보를 받는 경우 접속 오류가 발생 하는 경우 해결 할 수 있는 방법을 기술 합니다.



## Running Services After the Network is up

따라서 network.target 이후에 서비스가 실행되도록 구성했지만 네트워크가 작동하기 전에 여전히 실행됩니까? 그리고 지금 그 이유와 그에 대해 무엇을 할 수 있는지 궁금합니다.

LSB init 스크립트는 $network 기능을 알고 있습니다. 이 시설은 매우 정확하게 정의되어 있으므로 사람들은 의미가 다른 아이디어를 갖는 경향이 있습니다. 사람들이 지금까지 생각해 낸 몇 가지 아이디어는 다음과 같습니다.

- 네트워크 관리 소프트웨어가 작동 중입니다
- 모든 '구성된'네트워크 인터페이스가 작동하고 IP 주소가 각각에 할당되었습니다
- 링크 비트가있는 검색된 모든 로컬 하드웨어 인터페이스에는 실제로 명시적인 로컬 구성이 있는지 여부에 관계없이 IP 주소가 할당됩니다.
- 네트워크가 DNS 서버에 도달 할 수있는 수준으로 정확하게 설정되었습니다
- 비슷하지만 특정 사이트 별 서버에 접근 할 수 있음
- 비슷하지만 '인터넷'에 접근 할 수 있습니다
- 모든 '구성된'이더넷 장치가 작동하지만 부팅시 시작되어야하는 '구성된'PPP 링크는 아직 필요하지 않습니다.
- 특정 '프로파일'이 활성화되고 위의 일부 조건이 유지됩니다. 다른 '프로필'이 활성화 된 경우 다른 조건을 확인해야합니다.
- 시스템 위치에 따라 다른 구성 세트를 설정하거나 점검해야합니다.
- 하나 이상의 글로벌 IPv4 주소가 구성되었습니다.
- 하나 이상의 글로벌 IPv6 주소가 구성되었습니다.
- 하나 이상의 글로벌 IPv4 또는 IPv6 주소가 구성되었습니다.



그리고 등등. 이 모든 것은 '네트워크가 언제 작동합니까?'라는 질문에 대한 유효한 접근 방법이지만, 일반적인 기본값으로 사용하기에 유용한 방법은 없습니다.



최신 네트워킹은 매우 동적입니다. 머신은 네트워크간에 이동하고, 네트워크 구성 변경, 하드웨어가 추가 및 제거되고, 가상 네트워크가 설정, 재구성 및 다시 종료됩니다. 네트워크 연결은 무조건 지속적으로 사용할 수 없으며 컴퓨터는 다른 시간에 다른 네트워크에 연결됩니다. 이는 핸드셋, 태블릿 및 랩톱과 같은 모바일 하드웨어뿐만 아니라 임베디드 및 서버에도 특히 해당됩니다. 네트워크 연결을 지속적으로 사용할 수 있으며 절대로 변경되지 않는다는 가정하에 작성된 소프트웨어는 최신 표준을 준수하지 않습니다. 잘 작성된 소프트웨어는 동적 구성 변경을 처리 할 수 있어야합니다. 변화하는 네트워크 구성에 대응하고 최대한 활용해야합니다. 서버에 연결할 수 없으면 다시 시도해야합니다. 네트워크 구성 연결이 끊어지면 응답해야합니다. 데몬 코드에서 로컬 네트워크 구성 변경에 반응하는 것은 그리 어렵지 않습니다. 실제로 Linux에서 실행되는 유명한 네트워크 연결 서비스는 수십 년 동안 이 작업을 해왔습니다. 이와 같이 작성된 서비스는 강력하고 언제든지 시작할 수 있으며 항상 실행중인 환경을 최대한 활용합니다.

$network는 연속 네트워크를 사용할 수 있다고 가정하는 소프트웨어 (즉, 잘 작성되지 않은 간단한 종류)를 처리하는 데만 필요한 메커니즘입니다. 어느 측면이 필요한지는 정의되어 있지 않습니다. IMAP 서버는 청취 할 수 있도록 특정 IP를 지정하기 만하면됩니다. 네트워크 파일 시스템 클라이언트는 DNS를 필요로하고 서비스를 연결해야 할 수도 있습니다. $network에 정확히 필요한 것은 분명하지 않으며 로컬 구성에 따라 다를 수 있습니다.

강력한 시스템은 외부 서비스와 독립적으로 부팅됩니다. 보다 구체적으로, 네트워크 DHCP 서버가 반응하지 않으면 대부분의 설정에서 부팅 속도를 늦추지 말고 네트워크 연결이 꼭 필요한 경우에만 (예를 들어 호스트가 실제로 네트워크에서 부팅하기 때문에) 부팅 속도를 늦추어 야합니다.



## Concepts in systemd

systemd에서 3 개의 대상 장치가 $network의 역할을합니다.

- network.target은 시작하는 동안 의미가 거의 없습니다. 네트워크 관리 스택에 도달 한 후에 만 작동 함을 나타냅니다. 네트워크 인터페이스가 도달했을 때 이미 구성되어 있는지 여부는 정의되어 있지 않습니다. 주요 목적은 시스템 종료시 항목을 올바르게 주문하는 것입니다. systemd에서 장치의 시스템 종료 순서는 시작 순서의 역순이므로 order After=network.target 인 모든 장치는 네트워크가 종료되기 전에 중지되었는지 확인할 수 있습니다. 시스템 전원이 꺼져있는 경우. 따라서 연결이 끊어지기 전에 서비스가 연결을 완전히 종료 할 수 있으므로 연결이 끊어지지 않고 정의되지 않은 상태가됩니다. Network.target은 수동 장치입니다. 직접 시작할 수 없으며 네트워크를 사용하려는 서비스에서 가져 오지 않습니다. 대신 네트워크 관리 서비스 자체에서 가져옵니다. 따라서 네트워크를 사용하는 서비스는 단순히 단위 파일에 After= network.target 종속성을 배치하고 Wants=network.target 또는 Need=network.target을 피해야합니다.
- network-online.target은 네트워크가 '업'될 때까지 적극적으로 대기하는 대상입니다. 여기서 '업'의 정의는 네트워크 관리 소프트웨어에 의해 정의됩니다. 일반적으로 구성 가능한 라우팅 가능한 IP 주소를 나타냅니다. 주요 목적은 네트워크가 설정 될 때까지 서비스 활성화를 적극적으로 지연시키는 것입니다. 활성 대상입니다. 즉, 네트워크를 가동해야하는 서비스에 의해 끌어 올 수 있지만 네트워크 관리 서비스 자체에 의해 끌어 당겨지지는 않습니다. 기본적으로 /etc/fstab에 정의 된 모든 원격 마운트는 네트워크 공유에 연결을 시도하기 전에 네트워크가 작동하는지 확인하기 위해이 서비스를 가져옵니다. 일반적으로 서비스가 필요하지 않고 원격 마운트 지점이 구성되어 있지 않으면이 대상이 부팅으로 풀링되지 않으므로 네트워크를 사용할 수없는 경우 부팅 중 지연이 발생하지 않습니다. 예를 들어 네트워크 서버 소프트웨어는 일반적으로 이것을 끌어 내지 않아야합니다 (서버 소프트웨어는 일반적으로 라우팅 가능한 네트워크 인터페이스가 설치되기 전에도 로컬 연결을 받아들이 기 때문에).이 목적은 네트워크입니다. 네트워크없이 작동 할 수없는 클라이언트 소프트웨어.
- network-pre.target은 네트워크 인터페이스를 구성하기 전에 서비스를 주문하는 데 사용할 수있는 대상입니다. 주요 목적은 네트워크 인터페이스가 작동하기 전에 방화벽을 설정하려는 방화벽 서비스와 함께 사용하는 것입니다. 수동 장치입니다. 직접 시작할 수 없으며 네트워크 관리 서비스가 아니라 이전에 실행하려는 서비스에 의해 가져옵니다. 따라서 네트워크 관리 서비스는 After=network-pre.target을 설정해야하지만 Wants =network-pre.target 또는 Need=network-pre.target을 피하십시오. 네트워크를 구성하기 전에 실행하려는 서비스는 Before=network-pre.target을 배치하고 Wants=network-pre.target을 설정하여 가져와야합니다. 실제로 서비스를 주문해야하는 경우가 아니라면 네트워크가 작동 중이므로 대상을 끌어 오지 않으므로 불필요한 동기화 지점을 피하십시오.

Systemd가 init 스크립트의 LSB 헤더에서 $network 의존성을 만날 때마다 network-online.target에 대한 Wants= 및 After= 의존으로 변환하므로 기존 LSB 동작에 상대적으로 가깝습니다.

자세한 내용은 [systemd.special (7)](http://www.freedesktop.org/software/systemd/man/systemd.special.html) 매뉴얼 페이지를 참조하십시오.



### 네트워크가 실제로 온라인 상태 인 후 서비스가 시작되도록하려면 어떻게해야합니까?

글쎄, 그것은 당신의 설정과 그 이후에 실행할 서비스에 달려 있습니다 (위 참조). 네트워크가 가동 된 후 서비스를 지연해야하는 경우 다음을 포함하십시오.

``` ini
After=network-online.target
Wants=network-online.target
```

.service 파일에 추가 합니다.

이렇게하면 구성된 모든 네트워크 장치가 작동하고 서비스가 시작되기 전에 IP 주소가 할당됩니다. Network-online.target은 90 초 후에 시간 초과됩니다. 이를 사용하면 시간 초과에 도달하지 않아도 부팅이 상당히 지연 될 수 있습니다.



## 이것이 개발자에게 어떤 의미입니까?

개발자 인 경우 network.target에 대해 어떻게해야할지 궁금해하는 대신 동적으로 변경되는 네트워크 구성에 맞게 프로그램을 수정하십시오. 이렇게하면 작업이 시작되기 때문에 사용자를 만족시킬 수 있으며, 내용이 매우 견고하기 때문에 버그 보고서가 줄어 듭니다. 또한 사용자가 더 이상 네트워크에 대한 임의의 서비스를 지연시킬 필요가 없기 때문에 부팅 속도가 빨라집니다 (DHCP 서버에서 주소 할당이 느린 응답자에게는 특히 귀찮음).

가능한 몇 가지 접근 방식은 다음과 같습니다.

- [rtnetlink](https://www.kernel.org/doc/man-pages/online/pages/man7/rtnetlink.7.html) 를보고 네트워크 구성 변경이 발생할 때 적절히 대응하십시오. 이것이 가장 좋은 해결책이지만 항상 가장 쉬운 방법은 아닙니다.
- 서버를 작성하는 경우 : [::], [:: 1], 0.0.0.0 및 127.0.0.1에서만 청취하십시오. 이러한 의사 주소는 무조건 사용할 수 있습니다. 이 주소에 항상 바인딩하면 네트워크 변경에 반응하지 않아도되는 코드가 있습니다. 모두 수신 대기하는 주소는 개인 주소입니다.
- 서버를 쓰는 경우: 명시적으로 구성된 다른 주소를 수신하려면 Linux 커널의 [IP_FREEBIND sockopt](https://www.kernel.org/doc/man-pages/online/pages/man7/ip.7.html) 기능 사용을 고려하십시오. 이렇게하면 코드가 실제로 (아직 또는 아직) 로컬로 구성되지 않은 경우에도 코드를 주소에 바인딩 할 수 있습니다. 또한 네트워크 구성 변경에 대한 코드를 강력하게 만듭니다.



