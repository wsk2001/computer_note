# How To Defragment An XFS File System

출처: https://www.rootusers.com/how-to-defragment-an-xfs-file-system/

XFS 파일 시스템은 일반적으로 자신을 깨끗하고 깔끔하게 유지하는 데 꽤 잘 작동하지만 시간이 지남에 따라 여전히 조각화 될 수 있습니다. 여기서는 XFS 파일 시스템에있는 조각화 수준을 확인하는 방법과 필요한 경우 조각 모음을 수행하여 디스크 성능을 더욱 향상시키는 방법을 보여줍니다.

## Defining Fragmentation

단편화는 파일이 인접하지 않은 범위의 디스크에 저장 될 때 발생합니다. 즉, 기본적으로 파일이 디스크 전체에 분할되어 저장되어 디스크가 이제 여러 다른 위치에서 데이터를 검색해야하므로 전체 성능이 저하됩니다. 조각 모음은 이를 되돌리고 파일이 연속 된 순차적 범위에 저장되도록하는 프로세스입니다.

XFS 파일 시스템은 연속적인 데이터 블록 인 파일 범위에서 작동합니다. 즉, 파일 시스템은 기본적으로 디스크 조각화에 대한 저항을 증가시키는 순서대로 디스크를 사용하려고 시도합니다. 그러나 XFS의 최선의 노력에도 불구하고 유사한 방식으로 작동하지 않는 다른 파일 시스템과 비교할 때 더 낮은 수준이지만 조각화가 계속 발생할 수 있습니다.

XFS 파일 시스템의 또 다른 이점은 조각 모음 프로세스를 완전히 온라인으로 수행 할 수 있다는 것입니다. 즉, 파일 시스템을 해제하고 조각 모음 프로세스를 수행하기 위해 중단 시간을 예약 할 필요가 없지만 실행 중 디스크 I / O가 증가하여 시스템 성능에 부정적인 영향을 미칠 수 있습니다.

**Note:**  일반적으로 조각 모음은 SSD (솔리드 스테이트 디스크)가 아닌 회전하는 녹 (기존 하드 디스크 드라이브라고도 함)을 사용하는 시스템에 대해서만 실행해야합니다. 이는 SSD가 기존 HDD에 비해 연속적인 데이터 블록을 갖는 것보다 훨씬 적은 이점이 있기 때문입니다. SSD에서 불필요한 조각 모음을 수행하면 시간이 지남에 따라 수명이 단축 될 수 있습니다. 일반적으로 TRIM이 처리하도록하는 것이 좋습니다. Red Hat은 전체 XFS 파일 시스템을 주기적으로 조각 모음하지 말라고 조언하며 이는 일반적으로 보증되지 않는다고 말합니다.



## Viewing Current XFS Fragmentation Levels

XFS 파일 시스템에서 조각 모음 도구를 맹목적으로 실행하기 전에 조각 모음이 필요하지 않을 수도 있으므로 먼저 현재 조각화 수준에 대한 아이디어를 얻고 싶습니다!

먼저 XFS 파일 시스템을 찾아야합니다.이 작업은 몇 가지 다른 방법으로 수행 할 수 있습니다. 간단한 방법 중 하나는 아래와 같이‘blkid’명령을 실행하는 것입니다.

``` shell
[root@centos7 ~]# blkid
/dev/xvda1: UUID="1f790447-ebef-4ca0-b229-d0bc1985d47f" TYPE="xfs"
```

이 Linux 시스템의 / dev / xvda1에는 XFS 파일 시스템이 포함되어 있습니다.

Xfs_db 명령은 -r 옵션과 함께 사용하여 마운트 된 파일 시스템에 필요한 읽기 전용으로 장치 또는 파일을 열 수 있습니다. 여기서 우리는 XFS 파일 시스템 / dev / xvda1을 지정합니다.

``` shell
[root@centos7 ~]# xfs_db -r /dev/xvda1
xfs_db>
```

추가 명령을 실행할 수있는 xfs_db 프롬프트가 표시됩니다. 여기에서 실행할 수있는 전체 목록을 보려면 'help'를 입력하십시오.

이 특정 인스턴스에서는 조각화 데이터를 가져 오는 데 사용되는 'frag'명령을 사용할 것입니다. -d 플래그는 디렉토리 데이터를 표시하는 데 사용되고 -f 플래그는 파일 데이터에 사용됩니다.

``` shell
xfs_db> frag -d
actual 5933, ideal 5617, fragmentation factor 5.33%

xfs_db> frag -f
actual 132484, ideal 129817, fragmentation factor 2.01%
```

xfs_db 프롬프트를 종료하려면 'quit'를 입력하고 Enter를 누르십시오.

이 특정 인스턴스에서 너무 심각한 것은 없습니다. XFS 파일 시스템을 조각 모음하여 조각화 수준을 개선 할 수 있는지 살펴 보겠습니다.



## Defragmenting An XFS File System

조각 모음은 XFS 용 파일 시스템 재구성자인 xfs_fsr 도구를 사용하여 수행됩니다. 연속 공간이 사용되고 있는지 확인하기 위해 모든 파일의 디스크 범위 구성을 개선하여 작동합니다.

이 도구는 온라인 조각 모음을 수행합니다. 즉, 현재 마운트되어 사용중인 파일 시스템에서 실행할 수 있습니다. 결과적으로 증가하는 I / O 사용량에 유의하십시오. 일정 기간 동안 실행하는 것이 가장 좋습니다. 프로덕션 시스템에서 가능한 경우 디스크 활동이 적습니다.

xfs_fsr을 실행하려면 아래와 같이 해당 명령을 입력하면됩니다.

``` shell
[root@centos7 ~]# xfs_fsr
xfs_fsr -m /proc/mounts -t 7200 -f /var/tmp/.fsrlast_xfs ...
Completed all 10 passes
```

기본적으로 다른 인수가없는 xfs_fsr은 / etc / mtab 파일에 나열된 마운트 된 XFS 파일 시스템에 대해 실행됩니다. 사용 가능한 모든 조각 모음을 수행하지 않으려면 / dev / xvda1과 같은 파일 시스템 또는 특정 파일을 지정할 수도 있습니다. xfs_fsr이 실행되는 기본 시간은 2 시간 인 7200 초입니다. 이 시간이 지나면 현재 진행 상황을 /var/tmp/.fsrlast_xfs 파일에 저장하므로 기본적으로 XFS 조각 모음 프로세스를 일시 중지하고 다시 시작할 수 있습니다. 이 세 가지 옵션은 각각 -m, -t 또는 -f 플래그를 지정하여 수동으로 수정할 수 있습니다.

다음은 기본 옵션으로 xfs_fsr을 실행 한 후 xfs_db에서보고하는 조각화 수준입니다.

``` shell
xfs_db> frag -d
actual 5935, ideal 5619, fragmentation factor 5.32%

xfs_db> frag -f
actual 129878, ideal 129863, fragmentation factor 0.01%
```

이 특별한 경우 디렉토리 조각화는 거의 변경되지 않았지만 파일 조각화는 거의 제거되었습니다.

Xfs_fsr은 현재 메모리에 매핑 된 파일에서 실행되지 않습니다. Xfs_fsr을 실행 한 다음 재부팅을 수행하고 xfs_fsr을 다시 실행 한 후 조각 모음 수준이 0.01 % 더 떨어졌음을 발견했습니다. 이는 정확히 실용적이거나 매우 유용하지는 않지만 이전에 메모리에 열려 있던 조각난 파일이 피하는 것을 보여줍니다. 조각 모음 과정.



## XFS Degragmentation Performance Information

내 조사에서 xfs_fsr 도구가 다중 스레드로 표시되지 않는 것으로 보였습니다. 4 CPU 코어 Linux 시스템에서 코어 중 하나만 I / O 대기가 99 %이고 나머지는 0 % 인 것으로 나타났습니다. 필요한 디스크 작업. 아래는 xfs_fsr을 실행하는 동안 찍은 'top'의 스냅 샷입니다.

``` shell
[root@centos7 ~]# top
top - 21:42:21 up 66 days, 22:46,  3 users,  load average: 0.40, 0.12, 0.08
Tasks: 185 total,   2 running, 183 sleeping,   0 stopped,   0 zombie
%Cpu0  :  0.0 us,  0.0 sy,  0.0 ni, 99.7 id,  0.3 wa,  0.0 hi,  0.0 si,  0.0 st
%Cpu1  :  0.0 us,  0.0 sy,  0.0 ni,100.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
%Cpu2  :  0.3 us,  1.7 sy,  0.0 ni,  0.3 id, 97.3 wa,  0.0 hi,  0.0 si,  0.3 st
%Cpu3  :  0.0 us,  0.0 sy,  0.0 ni,100.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
KiB Mem : 16005736 total, 13166964 free,   657916 used,  2180856 buff/cache
KiB Swap:   520188 total,   520188 free,        0 used. 15037076 avail Mem

  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND
11653 root      20   0  126380  17212    680 R   1.7  0.1   0:00.40 xfs_fsr
```

또한 읽기 / 쓰기가 때때로 최대가되는 것을 발견 했으므로 조각 모음을 수행하는 동안 감소 된 디스크 성능에 대비하십시오. Xfs_fsr을 실행하는 것 외에는 아무것도하지 않는 동안 'iotop'명령을 사용하여 다음 I / O 사용법을 확인했습니다. 이것은 아래와 같습니다. Xfs_fsr이 테스트 서버에서 읽기 / 쓰기를 실행하지 않는 동안 초당 0 바이트로 모든 I / O가 xfs_fsr에서 온다는 것을 확인했습니다.

``` shell
Total DISK READ :     180.74 M/s | Total DISK WRITE :     212.45 M/s
Actual DISK READ:     180.74 M/s | Actual DISK WRITE:     212.83 M/s
  TID  PRIO  USER     DISK READ  DISK WRITE  SWAPIN     IO>    COMMAND
  26455 be/4 root      107.73 M/s  122.63 M/s  0.00 % 99.99 % xfs_fsr
```

별로 보이지 않을 수도 있지만 테스트 시스템의 디스크가 수행 할 수있는만큼 빠릅니다.

xfs_fsr을 완료하는 데 걸리는 전체 시간은 디스크 크기, 디스크 I / O 속도 및 조각화 정도에 따라 다릅니다. 내가 테스트 한 8GB 디스크의 경우 거의 모든 디스크 I / O를 사용하면서 완료하는 데 몇 분도 걸리지 않았습니다.

조각화가 많지 않았기 때문에 조각 모음 전후의 성능 차이를 비교하기 위해 디스크 I / O 테스트 전후에 의미있는 테스트를 수행 할 수 없었습니다.

'allocsize'를 지정하여 마운트하여 조각화 수준을 줄이는 데 XFS 파일 시스템을 추가로 도울 수 있습니다. 예를 들어 / etc / fstab의 아래 구성 줄을 참조하십시오.

``` shell
/dev/xvda1  /  xfs  defaults,allocsize=512m  0 0
```

마운트되었을 때 이것은 추측 적으로 우리에게 512MB의 연속적인 순차적 공간을 미리 할당했습니다. 대부분의 사용자에게 XFS가 제공하는 기본값은 일반적으로 괜찮습니다. XFS 튜닝에 대한 자세한 정보는 XFS FAQ를 좋은 출발점으로 살펴 보는 것이 좋습니다.



## Conclusion

xfs_db 도구를 사용하면 XFS 파일 시스템에 존재하는 현재 수준의 조각화를 볼 수 있습니다. 제자리에있는 조각화 수준을 처리해야한다는 것을 확인하면 xfs_fsr 도구를 사용하여 XFS 파일 시스템의 온라인 조각 모음을 수행 할 수 있습니다. XFS는 이미 디스크에서 연속적인 파일 범위를 사용하는 좋은 작업을 수행하고 있기 때문에 일반적으로 자주 실행할 필요는 없지만 필요에 따라 조각 모음을 실행하면 시스템이 사용하는 경우 시스템 디스크 I / O 성능을 높일 수 있습니다.