# how to empty or truncate a file in linux

출처: https://www.lostsaloon.com/technology/how-to-empty-or-truncate-files-in-linux/

종종 시스템에서 큰 파일, 특히 큰 로그 파일로 끝날 수 있습니다. 때로는 디스크 공간을 최소화하려는 경우 특히 파일을 비워서 다시 시작하려고합니다. 이는 많은 양의 오래된 데이터가 포함 된 로그 파일의 경우 특히 그렇습니다. 이것은 로그 파일로 강등 될뿐만 아니라 파일 또는 다른 파일도 출력 할 수 있습니다.

truncation 프로세스는 기본적으로 파일의 모든 내용을 제거합니다. 그러나 파일 자체는 제거하지 않지만 디스크에 0 바이트 파일로 남겨 둡니다. 이를 통해 파일을 재사용하거나 다른 프로그램에서 계속 사용하여 전체 크기를 확인할 수 있습니다. 이 프로세스를 '**zero out a file**'또는 '**empty a file**'라고도합니다.

항상 파일을 삭제하고 파일을 다시 만들 수 있으며 대부분의 경우 작동 할 수 있습니다. 그러나 truncation  프로세스는 서로 다른 두 단계의 필요성을 줄이고 파일의 inode를 보존합니다.

우리는 파일을 완전히 비우거나 제로화하려는 경우에만 처리하지만 파일의 일부를 제거하거나 특정 줄 수 또는 바이트 크기로 파일을 자르려는 경우는 처리하지 않습니다.



## truncate

truncate는 대부분의 Linux 배포판에서 찾을 수있는 명령 줄 유틸리티입니다. 파일 크기를 원하는 크기로 줄이는 데 사용됩니다. 크기를 0으로 설정하여 파일을 비 웁니다.

```bash
bash$ truncate -s 0 myfile.txt
```

-s 또는 –size : 파일을 자를 크기를 바이트 단위로 지정합니다.



## I/O redirection

파일을 비우는 가장 쉽고 빠른 방법 중 하나는 I/O 리디렉션을 사용하는 것입니다. 비어있는 새 파일이 없으면 새로 만듭니다. 파일이 이미 존재하면 모든 내용을 삭제하고 0 바이트 파일로 저장합니다.



위에서 언급 한 잘라 내기 시스템 호출과 정확히 동일하지는 않지만 거의 모든 실제 사용 사례에서 작동합니다. 또한 이것은 여기에 언급 된 모든 방법 중 가장 빠릅니다. 실제로 큰 파일이 있으면 I/O 리디렉션이 훨씬 빠를 수 있습니다.



```bash
bash$ > myfile.txt
```

리디렉션이 포함 된 빈 출력을 생성하는 다양한 명령의 출력을 사용할 수도 있습니다. 예를 들어, 아래와 같이 echo 명령을 사용할 수 있습니다. “:”또는 true와 같은 다른 no-op 명령도 사용할 수 있습니다. 아래의 모든 명령은 파일을 0 바이트로 자릅니다.

```bash
bash$ echo > myfile.txt
```

```bash
bash$ :> myfile.txt
```

```bash
bash$ true > myfile.txt
```



## /dev/null

대부분의 최신 Linux 버전에는 /dev/null 장치가 구현되어 있습니다. 이전 버전 인 경우 구현되지 않았을 수 있습니다. 위에서 언급 한 것처럼 cp 명령을 사용하여 파일을 자르거나 리디렉션을 사용하도록 선택할 수 있습니다.

```bash
bash$ cp /dev/null myfile.txt
```

이전 섹션에서 언급했듯이 리디렉션도 사용할 수 있습니다.

``` bash
bash$ cat /dev/null > myfile.txt
```



## noclobber

noclobber는 우발적 인 파일 덮어 쓰기를 방지하는 데 사용되는 Linux의 기능입니다. 시스템에 클로버가 설정되어 있지 않으면 위의 I/O 리디렉션 방법에서 오류가 발생합니다. noclobber 옵션을 오버라이드하려면 명령을 수정해야합니다.

명령 셸에 따라 다음을 시도 할 수 있습니다. csh와 파생 쉘에서!를 사용할 수 있습니다. noclobber 구성을 재정의하는 대신. ksh와 그 파생물에서 | 사용. 일부 쉘은 두 구문을 모두 지원합니다.

```bash
bash$ >! myfile.txt
```

```bash
bash$ >| myfile.txt
```

사용중인 쉘에 대해 잘 모르면 위의 명령을 차례로 시도하여 어떤 명령이 작동하는지 확인할 수 있습니다.



